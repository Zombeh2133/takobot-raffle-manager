<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Active Raffle</title>
<script src="/static/api.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>

  <!-- Dark Mode System -->
  <link rel="stylesheet" href="/static/dark-mode.css" />
  <script src="/static/dark-mode.js"></script>

  <style>
    /* ============================== MASTER LAYOUT VARIABLES ============================== */
    :root{
      --app-width: 100vw;
      --app-height: 100vh;
      --sidebar-width: 252px;
      --content-left: 276px;
      --content-width: calc(100vw - 276px - 20px);
    }

    body{
      background-color:#FAF8F6;
      display:flex;
      justify-content:flex-start;  /* Align left instead of center */
      align-items:flex-start;      /* Align top instead of center */
      height:100vh;
      margin:0;
      font-family:'Inter',sans-serif;
      overflow: hidden;
    }

    .top-sidebar{
      position:absolute; top:0; left:-30px;
      width: calc(var(--sidebar-width) + 30px);
      height:200px;
      clip-path: inset(0 0 0 30px);
      background-image:url('/static/assets/Background/Top-Sidebar.png');
      background-size:cover; background-repeat:no-repeat;
      z-index:5;
    }

    .tako{
      position:absolute;
      top:60px; left:calc(var(--sidebar-width) / 2);
      transform:translate(-50%,-50%);
      width:148px; height:148px;
      background-image:url('/static/assets/Icons/TAKO%201.png');
      background-size:contain;
      background-repeat:no-repeat;
      background-position:center;
      z-index:25;
      pointer-events:none;
    }

    .sidebar{
      position:absolute;
      left:-30px; bottom:0px;
      width: calc(var(--sidebar-width) + 30px);
      clip-path: inset(0 0 0 30px);
      height:900px;
      background-image:url('/static/assets/Background/Sidebar.png');
      background-size:cover;
      background-repeat:no-repeat;
      border-bottom-left-radius:30px;
      z-index:10;
    }

    .rectangle{
      position:absolute;
      top:135px; left:0;
      width:165px; height:48px;
      background-image:url('/static/assets/Background/Rectangle.png');
      background-size:cover;
      background-repeat:no-repeat;
      z-index:20;
      pointer-events:none;
    }

    .square{
      position:absolute;
      top:140px; left:30px;
      width:244px; height:52px;
      background-image:url('/static/assets/Background/Square.png');
      background-size:cover;
      background-repeat:no-repeat;
      background-position:center;
      z-index:30;
      pointer-events:none;
      transition:top 140ms ease;
      opacity:0;
    }

    .sidebar-nav{
      position:absolute;
      top:140px; left:55px;
      width:244px;
      font-size:16px;
      line-height:58px;
      z-index:40;
    }

    .sidebar-nav a{
      display:block;
      position:relative;
      padding-left:26px;
      color:#ffffff;
      text-decoration:none;
      font-weight:400;
      user-select:none;
      cursor:pointer;
    }

    .sidebar-nav a.is-active{
      color:#6E5FFC;
      font-weight:600;
    }

    .nav-icon{
      position:absolute;
      left:-5px; top:17px;
      width:20px; height:20px;
      filter:brightness(0) invert(1);
      pointer-events:none;
      z-index:41;
    }

    .sidebar-nav a.is-active .nav-icon{
      filter:brightness(0) saturate(100%) invert(46%) sepia(82%) saturate(2780%) hue-rotate(222deg);
    }

    /* USER SECTION */
    .user-section {
      position: absolute;
      bottom: 20px;
      left: 30px;
      width: 192px;
      z-index: 45;
    }

    /* APP VERSION */
    .app-version {
      position: absolute;
      bottom: 78px;
      left: 30px;
      width: 192px;
      text-align: right;
      font-size: 11px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.4);
      z-index: 45;
      letter-spacing: 0.5px;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .user-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 700;
      color: #fff;
      flex-shrink: 0;
    }

    .user-details {
      flex: 1;
      min-width: 0;
    }

    .user-name {
      font-size: 16px;
      font-weight: 600;
      color: #fff;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .user-role {
      font-size: 13px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.7);
      margin: 2px 0 0 0;
    }

    .logout-btn {
      width: 100%;
      height: 42px;
      border: none;
      border-radius: 10px;
      background: rgba(236, 72, 153, 0.85);
      color: #fff;
      font-size: 15px;
      font-weight: 600;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .logout-btn:hover {
      background: rgba(236, 72, 153, 1);
      transform: translateY(-1px);
    }

    .logout-btn:active {
      transform: translateY(0);
    }

    /* SEARCH BAR */


    /* TOP RIGHT ICONS */
    #themeToggle { position: absolute; top: 20px; right: 130px; width: 44px; height: 24px; cursor: pointer; }
    #settingsBtn { position: absolute; top: 20px; right: 70px; width: 24px; height: 24px; cursor: pointer; }

    /* FAST RAFFLE TIMER */
    .fast-raffle-timer {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #7C3AED 0%, #EC4899 100%);
      color: white;
      padding: 12px 32px;
      border-radius: 12px;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 1px;
      box-shadow: 0 8px 24px rgba(124, 58, 237, 0.35);
      z-index: 100;
      display: none;
      font-variant-numeric: tabular-nums;
    }

    .fast-raffle-timer.active {
      display: block;
    }

    .fast-raffle-timer.warning {
      background: linear-gradient(135deg, #F59E0B 0%, #EF4444 100%);
      box-shadow: 0 8px 24px rgba(239, 68, 68, 0.35);
      animation: pulse-warning 2s ease-in-out infinite;
    }

    @keyframes pulse-warning {
      0%, 100% {
        transform: translateX(-50%) scale(1);
        box-shadow: 0 8px 24px rgba(239, 68, 68, 0.35);
      }
      50% {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 12px 32px rgba(239, 68, 68, 0.5);
      }
    }

    /* STATS */
    .stats-row{
      position:absolute;
      top:60px;
      left:var(--content-left);
      width:var(--content-width);
      display:grid;
      grid-template-columns:repeat(5, 1fr);
      gap:18px;
      z-index:55;
    }

    .stat-card{
      border-radius:16px;
      padding:14px 18px;
      color:#fff;
      box-shadow:0 10px 18px rgba(0,0,0,0.12);
      min-height:78px;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }

    .stat-label{
      font-size:12px;
      letter-spacing:1px;
      font-weight:700;
      text-transform:uppercase;
      opacity:0.9;
      margin-bottom:6px;
    }

    .stat-value{
      font-size:30px;
      font-weight:700;
      line-height:1;
    }

    .c-pink{   background:#ff4fb2; }
    .c-purple{ background:#a855f7; }
    .c-red{    background:#ef4444; }
    .c-green{  background:#00c26f; }
    .c-orange{ background:#f59e0b; }
    .c-blue{   background:#3b82f6; }

    /* PARTICIPANTS CARD */
    .participants-card{
      position:absolute;
      top:180px;
      left:276px;
      width:calc(100vw - 276px - 20px);
      height:calc(100vh - 180px - 20px);
      background:#ffffff;
      border-radius:0;
      box-shadow:none;
      overflow:hidden;
      z-index:52;
      display:flex;
      flex-direction:column;
    }

    .participants-header{
      padding:20px 28px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:18px;
      border-bottom:3px solid #8b5cf6;
      background:#ffffff;
    }

    .participants-title{
      margin:0;
      font-size:20px;
      font-weight:700;
      color:#1f2937;
    }

    .participants-sub{
      margin-top:6px;
      font-size:13px;
      color:#64748b;
      font-weight:500;
    }

    .table-wrap{
      flex:1;
      overflow-y: auto;
      overflow-x: hidden;
      background:#ffffff;
    }

    .table-wrap::-webkit-scrollbar-track:horizontal {
      display: none;
    }

    .table-wrap::-webkit-scrollbar:horizontal {
      display: none;
      height: 0;
    }

    table.p-table{
      width:100%;
      border-collapse:collapse;
      font-size:13px;
      table-layout:fixed;
      /* ⚡ PERFORMANCE OPTIMIZATION #18: CSS containment for layout performance */
      contain: layout;
    }

    .p-table col.col-delete  { width:50px;  }
    .p-table col.col-reddit  { width:260px; }
    .p-table col.col-name    { width:170px; }
    .p-table col.col-tabbed  { width:180px; }
    .p-table col.col-comment { width:auto;  }
    .p-table col.col-spots   { width:90px;  }
    .p-table col.col-owed    { width:90px;  }
    .p-table col.col-paid    { width:80px;  }
    .p-table col.col-status  { width:120px; }

    .p-table thead th{
      text-align:left;
      padding:10px 28px;
      font-size:10px;
      letter-spacing:1.2px;
      text-transform:uppercase;
      color:#6b7280;
      font-weight:700;
      background:#fafafa;
      position:sticky;
      top:0;
      z-index:1;
      border-bottom:2px solid #e5e7eb;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    /* Sortable header styles */
    .p-table thead th.sortable {
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .p-table thead th.sortable:hover {
      background: #f3f4f6;
    }

    .p-table thead th.sortable .th-inner {
      display: flex;
      align-items: center;
      gap: 6px;
      position: relative;
    }

    .p-table thead th.sortable .sort-indicator {
      display: inline-flex;
      flex-direction: column;
      margin-left: auto;
      opacity: 0.3;
      transition: opacity 0.2s;
    }

    .p-table thead th.sortable:hover .sort-indicator {
      opacity: 0.6;
    }

    .p-table thead th.sortable.sorted-asc .sort-indicator,
    .p-table thead th.sortable.sorted-desc .sort-indicator {
      opacity: 1;
    }

    .p-table thead th .sort-arrow {
      font-size: 8px;
      line-height: 6px;
      color: #6b7280;
    }

    .p-table thead th.sorted-asc .sort-arrow-up {
      color: #8b5cf6;
    }

    .p-table thead th.sorted-desc .sort-arrow-down {
      color: #8b5cf6;
    }

    body.dark-mode .p-table thead th.sortable:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    body.dark-mode .p-table thead th .sort-arrow {
      color: #9ca3af;
    }

    body.dark-mode .p-table thead th.sorted-asc .sort-arrow-up,
    body.dark-mode .p-table thead th.sorted-desc .sort-arrow-down {
      color: #a78bfa;
    }

    /* Center align numeric columns */
    .p-table thead th[data-col="4"],
    .p-table thead th[data-col="5"],
    .p-table thead th[data-col="6"],
    .p-table thead th[data-col="7"] {
      text-align: center;
    }

    .p-table tbody td{
      padding:12px 28px;
      border-bottom:1px solid #f3f4f6;
      vertical-align:middle;
      color:#1f2937;
      /* ⚡ PERFORMANCE OPTIMIZATION #18: Isolate cell layout */
      contain: layout style;
    }

    /* ============================== UNPAID ROW STYLING ============================== */
    .p-table tbody tr.unpaid-row {
      background: #E9D5FF;
      border-left: none;
      transition: all 0.15s;
    }

    .p-table tbody tr.unpaid-row:hover {
      background: #D8B4FE;
    }

    /* ============================== PAID ROW STYLING ============================== */
    .p-table tbody tr.paid-row {
      background: #BBF7D0;
      border-left: none;
      transition: all 0.15s;
    }

    .p-table tbody tr.paid-row:hover {
      background: #86EFAC;
    }

    /* Dark mode row colors */
    body.dark-mode .p-table tbody tr.unpaid-row {
      background: rgba(168, 85, 247, 0.25);
    }

    body.dark-mode .p-table tbody tr.unpaid-row:hover {
      background: rgba(168, 85, 247, 0.35);
    }

    body.dark-mode .p-table tbody tr.paid-row {
      background: rgba(34, 197, 94, 0.25);
    }

    body.dark-mode .p-table tbody tr.paid-row:hover {
      background: rgba(34, 197, 94, 0.35);
    }

    /* Dark mode - Bulk Tab Modal */
    body.dark-mode .bulk-tab-user {
      color: #e2e8f0;
    }

    body.dark-mode .bulk-tab-spots {
      color: #cbd5e1;
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .bulk-tab-comment {
      color: #cbd5e1;
    }

    .user-cell{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:0;
    }

    .avatar{
      width:34px;
      height:34px;
      border-radius:50%;
      display:grid;
      place-items:center;
      color:#fff;
      font-weight:700;
      background:linear-gradient(135deg,#a855f7,#ff4fb2);
      flex-shrink:0;
    }

    .reddit-link{
      color:#6E5FFC;
      text-decoration:none;
      font-weight:600;
    }

    .comment-muted{
      color:#334155;
      font-style:italic;
    }

    .spots-pill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:34px;
      height:26px;
      padding:0 10px;
      border-radius:999px;
      background:#efe9ff;
      color:#6E5FFC;
      font-weight:700;
      font-size:12px;
    }

    .status-chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;

    .tab-badge {
      display: inline-block;
      margin-left: 8px;
      padding: 2px 8px;
      background: #fbbf24;
      color: #78350f;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
    }

    .editable-field:hover {
      background: rgba(139, 92, 246, 0.1);
    }
      font-weight:700;
      font-size:12px;
      white-space:nowrap;
    }

    .status-paid{ background:#dcfce7; color:#166534; }
    .status-pending{ background:#fef3c7; color:#92400e; }

    /* ✅ Tabbed Search Input Styling */
    .tabbed-search-container {
      position: relative;
      width: 100%;
      max-width: 170px;
    }

    .tabbed-search-input {
      width: 100%;
      padding: 6px 10px;
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      background: #ffffff;
      color: #334155;
      font-size: 13px;
      font-family: 'Inter', sans-serif;
      transition: all 0.2s ease;
      outline: none;
    }

    .tabbed-search-input:hover {
      border-color: #8b5cf6;
      background: #faf5ff;
    }

    .tabbed-search-input:focus {
      border-color: #8b5cf6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .tabbed-search-input::placeholder {
      color: #94a3b8;
    }

    /* Dropdown list - FIXED positioning to avoid clipping */
    .tabbed-dropdown-list {
      position: fixed;
      max-height: 200px;
      overflow-y: auto;
      background: #ffffff;
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 9999;
      display: none;
    }

    .tabbed-dropdown-list.show {
      display: block;
    }

    .tabbed-dropdown-item {
      padding: 8px 12px;
      font-size: 13px;
      color: #334155;
      cursor: pointer;
      transition: background 0.15s;
    }

    .tabbed-dropdown-item:hover {
      background: #faf5ff;
      color: #8b5cf6;
    }

    .tabbed-dropdown-item.selected {
      background: #ede9fe;
      color: #8b5cf6;
      font-weight: 600;
    }

    .tabbed-dropdown-item-name {
      color: #94a3b8;
      font-size: 11px;
      margin-left: 4px;
    }

    .tabbed-dropdown option:hover {
      background: #f3f4f6;
    }

    /* Bulk Tab Modal Styles */
    .bulk-tab-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      margin-bottom: 8px;
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .bulk-tab-item:hover {
      border-color: #8b5cf6;
      box-shadow: 0 2px 8px rgba(139, 92, 246, 0.1);
    }

    .bulk-tab-item.changed {
      background: #fef3c7;
      border-color: #f59e0b;
    }

    .bulk-tab-item.changed .bulk-tab-user::after {
      content: "✓";
      margin-left: 6px;
      color: #f59e0b;
      font-weight: bold;
    }

    .bulk-tab-item-left {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
    }

    .bulk-tab-user {
      font-weight: 600;
      color: #1e293b;
      font-size: 14px;
    }

    .bulk-tab-spots {
      font-size: 12px;
      color: #475569;
      background: #f1f5f9;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: 500;
    }

    .bulk-tab-comment {
      font-size: 12px;
      color: #475569;
      font-style: italic;
      line-height: 1.4;
      max-width: 400px;
      word-wrap: break-word;
    }

    .bulk-tab-select {
      min-width: 200px;
      padding: 6px 10px;
      border: 1.5px solid #e2e8f0;
      border-radius: 6px;
      background: white;
      color: #334155;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .bulk-tab-select:hover {
      border-color: #8b5cf6;
      background: #faf5ff;
    }

    .bulk-tab-select:focus {
      outline: none;
      border-color: #8b5cf6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    /* Searchable dropdown wrapper */
    .searchable-dropdown {
      position: relative;
      min-width: 200px;
    }

    .searchable-dropdown-input {
      min-width: 200px;
      padding: 6px 30px 6px 10px;
      border: 1.5px solid #e2e8f0;
      border-radius: 6px;
      background: white;
      color: #334155;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .searchable-dropdown-input:focus {
      outline: none;
      border-color: #8b5cf6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
      cursor: text;
    }

    .searchable-dropdown-arrow {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: #94a3b8;
      font-size: 10px;
    }

    .searchable-dropdown-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: white;
      border: 1.5px solid #8b5cf6;
      border-radius: 6px;
      margin-top: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      display: none;
      /* ⚡ PERFORMANCE OPTIMIZATION #19: Transform-based animations for 60fps */
      transition: opacity 0.15s, transform 0.15s;
      will-change: transform, opacity;
      contain: layout style;
    }

    .searchable-dropdown-list.show {
      display: block;
    }

    .searchable-dropdown-option {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 13px;
      color: #334155;
      transition: all 0.15s;
    }

    .searchable-dropdown-option:hover {
      background: #f8fafc;
      color: #8b5cf6;
    }

    .searchable-dropdown-option.selected {
      background: #ede9fe;
      color: #7c3aed;
      font-weight: 500;
    }

    .searchable-dropdown-option.no-results {
      color: #94a3b8;
      font-style: italic;
      cursor: default;
      text-align: center;
    }

    .searchable-dropdown-option.no-results:hover {
      background: white;
      color: #94a3b8;
    }

    /* Mark Paid Modal Styles */
    .mark-paid-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      margin-bottom: 8px;
      background: white;
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mark-paid-item:hover {
      border-color: #16a34a;
      background: #f0fdf4;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(22, 163, 74, 0.1);
    }

    .mark-paid-item.paid {
      background: #dcfce7;
      border-color: #16a34a;
    }

    .mark-paid-item.paid .mark-paid-user::after {
      content: \"✓ Paid\";
      margin-left: 10px;
      color: #16a34a;
      font-weight: bold;
      font-size: 11px;
      background: #bbf7d0;
      padding: 2px 6px;
      border-radius: 4px;
    }

    .mark-paid-item-left {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
    }

    .mark-paid-user {
      font-weight: 600;
      color: #1e293b;
      font-size: 14px;
    }

    .mark-paid-spots {
      font-size: 12px;
      color: #475569;
      background: #f1f5f9;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: 500;
    }

    .mark-paid-comment {
      font-size: 12px;
      color: #64748b;
      font-style: italic;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .mark-paid-owed {
      font-size: 13px;
      color: #dc2626;
      font-weight: 600;
      min-width: 60px;
      text-align: right;
    }

    .mark-paid-status {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 6px;
      font-weight: 600;
      min-width: 80px;
      text-align: center;
    }

    .mark-paid-status.status-unpaid {
      background: #fef3c7;
      color: #92400e;
    }

    .mark-paid-status.status-paid {
      background: #dcfce7;
      color: #166534;
    }

    /* Paid Cell Display - Similar to Tabbed Cell */
    .paid-cell-display {
      cursor: pointer;
      padding: 4px 12px;
      border-radius: 4px;
      transition: all 0.2s;
      min-height: 24px;
      display: inline-block;
      min-width: 80px;
      text-align: center;
      font-size: 13px;
      font-weight: 500;
    }

    .paid-cell-display:hover {
      background: #f1f5f9;
    }

    .paid-cell-unpaid {
      color: #94a3b8;
    }

    .paid-cell-paid {
      color: #16a34a;
      font-weight: 600;
    }

    body.dark-mode .paid-cell-display:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .paid-cell-unpaid {
      color: #64748b;
    }

    body.dark-mode .paid-cell-paid {
      color: #4ade80;
    }

    .tabbed-cell-display {
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s;
      min-height: 24px;
      display: inline-block;
      min-width: 80px;
    }

    .tabbed-cell-display:hover {
      background: #faf5ff;
      color: #8b5cf6;
    }

    .tabbed-cell-empty {
      color: #94a3b8;
    }

    .dot{
      width:18px;
      height:18px;
      border-radius:50%;
      display:grid;
      place-items:center;
      font-size:12px;
      line-height:1;
      background:rgba(255,255,255,0.55);
    }

    /* Compact status dots */
    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .dot-paid {
      background: #22c55e;
    }

    .dot-pending {
      background: #f59e0b;
    }

    /* Delete Button Styling */
    .delete-btn {
      background: transparent;
      border: none;
      color: #ef4444;
      cursor: pointer;
      font-size: 18px;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s;
      opacity: 0.5;
      line-height: 1;
      display: inline-flex;
      align-items: center;
    }

    .delete-btn:hover {
      opacity: 1;
      background: #fee2e2;
      transform: scale(1.1);
    }

    .delete-btn:active {
      transform: scale(0.95);
    }

    .participants-foot{
      padding:14px 28px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      border-top:2px solid #e5e7eb;
      background:#fafafa;
      color:#6b7280;
      font-size:12px;
    }

    /* Resize handles */
    .th-inner{ position:relative; padding-right:14px; }
    .col-resizer{
      position:absolute;
      top:0;
      right:-8px;
      width:16px;
      height:100%;
      cursor:col-resize;
      user-select:none;
      touch-action:none;
    }
    .col-resizer::after{
      content:"";
      position:absolute;
      top:20%;
      left:50%;
      transform:translateX(-50%);
      width:2px;
      height:60%;
      background:rgba(15,23,42,0.12);
      border-radius:2px;
      opacity:0;
      transition:opacity 120ms ease;
    }
    th:hover .col-resizer::after{ opacity:1; }
    .resizing *{ cursor:col-resize !important; user-select:none !important; }

    /* Column Drag & Drop */
    .p-table thead th {
      position: relative;
    }
    .p-table thead th.draggable {
      cursor: move;
      user-select: none;
    }
    .p-table thead th.dragging {
      opacity: 0.5;
      background: #e2e8f0;
    }
    .p-table thead th.drag-over-left::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: #3b82f6;
      z-index: 10;
    }
    .p-table thead th.drag-over-right::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: #3b82f6;
      z-index: 10;
    }
    body.dark-mode .p-table thead th.dragging {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Buttons */
    .btn {
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      transition: all 150ms ease;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .btn-blue   { background: #3B82F6; }
    .btn-green  { background: #10B981; }
    .btn-purple { background: linear-gradient(90deg, #7C3AED, #EC4899); }
    .btn-orange { background: #F97316; }
    .btn-gray   { background: #6B7280; }
    .btn-red    { background: #EF4444; }

    .search-box input {
      height: 40px;
      padding: 0 14px;
      border-radius: 12px;
      border: 1px solid #E6E8F0;
      font-size: 14px;
    }

    .filter-select {
      height: 40px;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid #E6E8F0;
      font-size: 14px;
      background: #fff;
      cursor: pointer;
    }

/* MODAL STYLES */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: none; /* CHANGED from flex to none */
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .modal-overlay.show {
      display: flex; /* ADDED: Show when .show class is added */
    }

    .modal-content {
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 32px 24px;
      width: 600px;
      max-width: 90vw;
      transform: scale(0.9);
      transition: transform 200ms ease;
    }

    .modal-overlay.show .modal-content {
      transform: scale(1);
    }

    .modal-title {
      font-size: 24px;
      font-weight: 700;
      margin: 0 0 24px 0;
      color: #111827;
    }

    .modal-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-label {
      font-size: 14px;
      font-weight: 500;
      color: #374151;
      margin-bottom: 8px;
    }

    .form-input {
      width: 100%;
      padding: 10px 11px;
      border: 1px solid #D1D5DB;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }

    .form-input:focus {
      border-color: #8B5CF6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 32px;
    }

    .form-hint {
      font-size: 12px;
      color: #6B7280;
      margin-top: 4px;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      margin-top: 32px;
    }

    .modal-btn {
      flex: 1;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 150ms ease;
    }

    .modal-btn-cancel {
      background: #ffffff;
      color: #374151;
      border: 1px solid #D1D5DB;
    }

    .modal-btn-cancel:hover {
      background: #F9FAFB;
    }

    .modal-btn-save {
      background: linear-gradient(90deg, #3B82F6, #2563EB);
      color: #ffffff;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .modal-btn-save:hover {
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    }

    /* FINISH RAFFLE MODAL */
    .finish-modal-content {
      width: 540px;
    }

    .finish-modal-icon {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, #FF4FB2, #A855F7);
      border-radius: 50%;
      display: grid;
      place-items: center;
      margin: 0 auto 20px;
      font-size: 40px;
    }

    .finish-modal-text {
      font-size: 15px;
      color: #6B7280;
      margin-bottom: 28px;
      line-height: 1.6;
      text-align: center;
    }

    .winner-section {
      background: #F9FAFB;
      border: 1px solid #E5E7EB;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 28px;
    }

    .winner-section-title {
      font-size: 15px;
      font-weight: 700;
      color: #111827;
      margin: 0 0 16px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .winner-count-selector {
      margin-bottom: 20px;
    }

    .winner-count-buttons {
      display: flex;
      gap: 8px;
    }

    .winner-count-btn {
      flex: 1;
      padding: 10px 16px;
      border: 2px solid #E5E7EB;
      border-radius: 8px;
      background: white;
      color: #6B7280;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 150ms ease;
    }

    .winner-count-btn:hover {
      border-color: #A855F7;
      color: #A855F7;
    }

    .winner-count-btn.active {
      border-color: #A855F7;
      background: #A855F7;
      color: white;
      box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
    }

    .winner-entry {
      margin-bottom: 20px;
      padding: 16px;
      background: white;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      animation: slideIn 200ms ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .winner-entry-header {
      font-size: 13px;
      font-weight: 600;
      color: #6B7280;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

          .username-dropdown-container {
      position: relative;
    }

    .username-dropdown-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: white;
      border: 1px solid #D1D5DB;
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      display: none;
    }

    .username-dropdown-list.show {
      display: block;
    }

    .username-dropdown-item {
      padding: 10px 14px;
      cursor: pointer;
      transition: background 150ms ease;
    }

    .username-dropdown-item:hover {
      background: #F3F4F6;
    }

    .username-dropdown-item.selected {
      background: #EFE9FF;
      color: #6E5FFC;
      font-weight: 600;
    }

    .winner-form-row {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
    }

    .form-select {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid #D1D5DB;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      background: white;
      cursor: pointer;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }

    .form-select:focus {
      border-color: #10B981;
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
    }

    .finish-modal-actions {
      display: flex;
      gap: 12px;
    }

    .finish-btn {
      flex: 1;
      padding: 14px 24px;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 150ms ease;
    }

    .finish-btn-complete {
      background: linear-gradient(90deg, #10B981, #059669);
      color: white;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .finish-btn-complete:hover {
      box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
      transform: translateY(-1px);
    }

    .finish-btn-complete:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .finish-btn-cancel-raffle {
      background: linear-gradient(90deg, #EF4444, #DC2626);
      color: white;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }

    .finish-btn-cancel-raffle:hover {
      box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
      transform: translateY(-1px);
    }

    .or-divider {
      text-align: center;
      color: #9CA3AF;
      font-size: 13px;
      font-weight: 600;
      margin: 16px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* RESTRICTION MODAL */
    .restriction-modal-content {
      width: 420px;
      background: #2B2B3D;
      border-radius: 16px;
      padding: 40px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .restriction-modal-icon {
      width: 64px;
      height: 64px;
      background: rgba(251, 191, 36, 0.15);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 20px;
      font-size: 32px;
    }

    .restriction-modal-title {
      font-size: 22px;
      font-weight: 600;
      color: #E5E7EB;
      margin: 0 0 16px 0;
      text-align: center;
    }

    .restriction-modal-message {
      font-size: 15px;
      color: #9CA3AF;
      line-height: 1.6;
      margin-bottom: 32px;
      text-align: center;
    }

    .restriction-modal-message strong {
      color: #FFFFFF;
      font-weight: 600;
    }

    .restriction-ok-btn {
      width: 100%;
      height: 48px;
      background: #4F89C7;
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .restriction-ok-btn:hover {
      background: #5A96D4;
      transform: translateY(-1px);
    }

    .restriction-ok-btn:active {
      transform: translateY(0);
    }

    .restriction-cancel-btn {
      width: 100%;
      height: 48px;
      background: #DC4444;
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .restriction-cancel-btn:hover {
      background: #E65555;
      transform: translateY(-1px);
    }

    .restriction-cancel-btn:active {
      transform: translateY(0);
    }

    .restriction-modal-actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* PAYPAL SCAN CONFIRMATION MODAL */
    .paypal-scan-modal-content {
      width: 440px;
      background: #2B2B3D;
      border-radius: 16px;
      padding: 32px;
      text-align: left;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .paypal-scan-modal-title {
      font-size: 18px;
      font-weight: 600;
      color: #E5E7EB;
      margin: 0 0 20px 0;
      text-align: left;
      line-height: 1.4;
    }

    .paypal-scan-modal-message {
      font-size: 14px;
      color: #9CA3AF;
      line-height: 1.8;
      margin-bottom: 28px;
      text-align: left;
    }

    .paypal-scan-modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .paypal-scan-ok-btn {
      height: 44px;
      padding: 0 28px;
      background: #7C3AED;
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .paypal-scan-ok-btn:hover {
      background: #8B5CF6;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
    }

    .paypal-scan-ok-btn:active {
      transform: translateY(0);
    }

    .paypal-scan-cancel-btn {
      height: 44px;
      padding: 0 24px;
      background: transparent;
      color: #9CA3AF;
      border: 1px solid #4B5563;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .paypal-scan-cancel-btn:hover {
      background: #374151;
      color: #E5E7EB;
      border-color: #6B7280;
    }

    .paypal-scan-cancel-btn:active {
      transform: scale(0.98);
    }

    /* CANCEL RAFFLE CONFIRMATION MODAL */
    .cancel-confirm-modal-content {
      width: 420px;
      background: #2B2B3D;
      border-radius: 12px;
      padding: 32px;
      text-align: left;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .cancel-confirm-title {
      font-size: 15px;
      color: #E5E7EB;
      line-height: 1.5;
      margin-bottom: 24px;
    }

    .cancel-confirm-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .cancel-confirm-ok-btn {
      padding: 10px 28px;
      background: #4F89C7;
      color: #FFFFFF;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .cancel-confirm-ok-btn:hover {
      background: #5A96D4;
      transform: translateY(-1px);
    }

    .cancel-confirm-cancel-btn {
      padding: 10px 24px;
      background: transparent;
      color: #9CA3AF;
      border: 1px solid #4B5563;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .cancel-confirm-cancel-btn:hover {
      background: rgba(75, 85, 99, 0.3);
      border-color: #6B7280;
      color: #D1D5DB;
    }

    /* AUTO-SCAN INDICATOR */
    .auto-scan-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }

    .auto-scan-pulse {
      width: 8px;
      height: 8px;
      background: white;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.5;
        transform: scale(1.2);
      }
    }

    /* SUMMARY MODAL */
    .summary-modal-content {
      width: 700px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      padding: 32px 28px 48px 28px !important; /* Extended padding: top right bottom left */
    }

    .summary-stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }

    .summary-stat-box {
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      border: 2px solid;
    }

    .summary-stat-box.confirmed {
      background: #f0fdf4;
      border-color: #86efac;
    }

    .summary-stat-box.waitlist {
      background: #fef3c7;
      border-color: #fcd34d;
    }

    .summary-stat-box.tabs {
      background: #fce7f3;
      border-color: #f9a8d4;
    }

    .summary-stat-box-label {
      font-size: 11px;
      margin-bottom: 6px;
      font-weight: 600;
    }

    .summary-stat-box.confirmed .summary-stat-box-label {
      color: #15803d;
    }

    .summary-stat-box.waitlist .summary-stat-box-label {
      color: #92400e;
    }

    .summary-stat-box.tabs .summary-stat-box-label {
      color: #831843;
    }

    .summary-stat-box-value {
      font-size: 32px;
      font-weight: 800;
    }

    .summary-stat-box.confirmed .summary-stat-box-value {
      color: #166534;
    }

    .summary-stat-box.waitlist .summary-stat-box-value {
      color: #b45309;
    }

    .summary-stat-box.tabs .summary-stat-box-value {
      color: #be185d;
    }

    .summary-section {
      margin-bottom: 16px;
    }

    .summary-section:last-of-type {
      margin-bottom: 0;
    }

    .summary-section-header {
      font-size: 14px;
      font-weight: 700;
      color: #64748b;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .summary-section-list {
      background: #f8fafc;
      border-radius: 12px;
      padding: 12px;
      max-height: 280px;
      overflow-y: auto;
    }

    .summary-card {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      border-radius: 6px;
      margin-bottom: 6px;
    }

    .summary-card:last-child {
      margin-bottom: 0;
    }

    .summary-card.participant-paid {
      background: #f0fdf4;
    }

    .summary-card.participant-unpaid {
      background: #fef2f2;
    }

    .summary-card.tab-request {
      background: #fef3c7;
    }

    .summary-card-left {
      flex: 1;
    }

    .summary-card-title {
      font-size: 13px;
      font-weight: 600;
      color: #0f172a;
    }

    .summary-card-subtitle {
      font-size: 11px;
      color: #64748b;
      margin-top: 2px;
    }

    .summary-card-right {
      text-align: right;
    }

    .summary-card-amount {
      font-size: 14px;
      font-weight: 700;
    }

    .summary-card.participant-paid .summary-card-amount {
      color: #10b981;
    }

    .summary-card.participant-unpaid .summary-card-amount {
      color: #ef4444;
    }

    .summary-card.tab-request .summary-card-amount {
      color: #b45309;
    }

    .summary-card-badge {
      font-size: 10px;
      font-weight: 600;
      margin-top: 2px;
    }

    .summary-card.participant-paid .summary-card-badge {
      color: #10b981;
    }

    .summary-card.participant-unpaid .summary-card-badge {
      color: #ef4444;
    }

    .summary-card.tab-request .summary-card-badge {
      color: #92400e;
    }

    /* TOAST NOTIFICATION */
    .toast {
      position: absolute;
      top: 30px;
      right: 30px;
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
      padding: 20px 28px;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(16, 185, 129, 0.5);
      font-size: 15px;
      font-weight: 600;
      z-index: 10000;
      min-width: 380px;
      max-width: 480px;
      opacity: 0;
      transform: translateX(400px);
      transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1),
                  transform 400ms cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }

    .toast-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .toast-icon {
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.25);
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-size: 18px;
      flex-shrink: 0;
    }

    .toast-title {
      font-size: 16px;
      font-weight: 700;
      margin: 0;
    }

    .toast-body {
      margin-left: 44px;
      font-size: 13px;
      font-weight: 500;
      line-height: 1.6;
      opacity: 0.95;
    }

    .toast-detail {
      margin-top: 4px;
      color: rgba(255, 255, 255, 0.9);
    }

    .toast-close {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 24px;
      height: 24px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 16px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: background 150ms ease;
    }

    .toast-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* ERROR TOAST */
    .error-toast {
      position: absolute;
      top: 110px;
      right: 40px;
      background: linear-gradient(135deg, #EF4444, #DC2626);
      color: white;
      padding: 20px 28px;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(239, 68, 68, 0.5);
      font-size: 15px;
      font-weight: 600;
      z-index: 10000;
      min-width: 380px;
      max-width: 480px;
      opacity: 0;
      transform: translateX(400px);
      transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1),
                  transform 400ms cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }

    .error-toast.show {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }

    /* Hidden rows */
    .hidden { display: none !important; }

    /* ==============================
       ACCESS DENIED MODAL
       ============================== */
    .access-denied-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      z-index: 999999;
      animation: fadeIn 0.2s ease;
    }

    .access-denied-overlay.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .access-denied-modal {
      background: white;
      border-radius: 24px;
      padding: 0;
      width: 440px;
      max-width: 90vw;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      animation: slideUp 0.3s ease;
      overflow: hidden;
    }

    .access-modal-header {
      background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
      padding: 32px;
      text-align: center;
      position: relative;
    }

    .access-modal-icon {
      width: 72px;
      height: 72px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px;
      font-size: 36px;
      animation: shake 0.5s ease;
    }

    @keyframes shake {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-10deg); }
      75% { transform: rotate(10deg); }
    }

    .access-modal-title {
      font-size: 26px;
      font-weight: 800;
      color: white;
      margin: 0 0 8px 0;
      letter-spacing: -0.5px;
    }

    .access-modal-subtitle {
      font-size: 14px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
      margin: 0;
    }

    .access-modal-body {
      padding: 32px;
      text-align: center;
    }

    .access-modal-message {
      font-size: 16px;
      font-weight: 500;
      color: #374151;
      line-height: 1.6;
      margin: 0 0 24px 0;
    }

    .access-modal-actions {
      display: flex;
      gap: 12px;
    }

    .access-modal-btn {
      flex: 1;
      padding: 14px 24px;
      border: none;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 700;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s;
    }

    .access-modal-btn-primary {
      background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
      color: white;
    }

    .access-modal-btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(139, 92, 246, 0.4);
    }

    .access-modal-btn-primary:active {
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <div class="white-square">
    <div class="top-sidebar"></div>
    <div class="tako"></div>
    <div class="sidebar"></div>
    <div class="rectangle"></div>
    <div class="square" id="activeSquare"></div>

    <div id="themeToggle" title="Theme Toggle">
      <img src="/static/assets/Icons/OFF.png" alt="Theme toggle">
    </div>
    <div id="settingsBtn" title="Settings">
      <img src="/static/assets/Icons/Notifications%20Copy.png" alt="Settings">
    </div>

    <!-- FAST RAFFLE TIMER -->
    <div id="fastRaffleTimer" class="fast-raffle-timer">
      <span id="timerDisplay">01:15:00</span>
    </div>

    <!-- STATS -->
    <section class="stats-row" aria-label="Active raffle overview">
      <div class="stat-card c-pink">
        <div class="stat-label">Total Spots</div>
        <div class="stat-value" id="totalSpots">-</div>
      </div>
      <div class="stat-card c-purple">
        <div class="stat-label">Spots Remaining</div>
        <div class="stat-value" id="spotsRemaining">-</div>
      </div>
      <div class="stat-card c-green">
        <div class="stat-label">Cost Per Spot</div>
        <div class="stat-value" id="costPerSpot">-</div>
      </div>
      <div class="stat-card c-orange">
        <div class="stat-label">Total Owed</div>
        <div class="stat-value" id="totalOwed">$0</div>
      </div>
      <div class="stat-card c-blue">
        <div class="stat-label">Outstanding Balance</div>
        <div class="stat-value" id="totalPaid">$0</div>
      </div>
    </section>

    <!-- TABLE -->
    <section class="participants-card">
      <div class="participants-header">
        <div>
          <h3 class="participants-title">Participants</h3>
          <div class="participants-sub"><span id="totalParticipants">0</span> total participants • Next poll in <span id="nextPollTimer">5</span>s</div>
        </div>
<div style="display:flex; gap:10px;">
  <button id="setupBtn" class="btn btn-blue">Setup</button>
  <button id="summaryBtn" class="btn btn-purple">Summary</button>
  <button id="scanEmailBtn" class="btn btn-orange">📧 Scan Gmail</button>
  <button id="clearIdsBtn" class="btn btn-gray">🗑️ Clear IDs</button>
  <button id="markAllPaidBtn" class="btn btn-green">Mark All Paid</button>
  <button id="finishRaffleBtn" class="btn btn-red">Finish Raffle</button>
</div>

        <div style="display:flex; gap:12px; align-items:center;">
          <div class="search-box">
            <input id="participantSearch" type="text" placeholder="Search participants..." />
          </div>

          <select id="paymentFilter" class="filter-select">
            <option value="all" selected>All Payments</option>
            <option value="paid">Paid</option>
            <option value="pending">Pending</option>
            <option value="tabs">Tabs Only</option>
            <option value="drama">Waitlist</option>
          </select>
        </div>
      </div>

      <div class="table-wrap">
        <table class="p-table" id="participantsTable">
          <colgroup>
            <col class="col-reddit">
            <col class="col-name">
            <col class="col-tabbed">
            <col class="col-comment">
            <col class="col-spots">
            <col class="col-owed">
            <col class="col-paid">
            <col class="col-status">
            <col class="col-delete">
          </colgroup>

          <thead>
            <tr>
              <th data-col="0">
                <div class="th-inner">
                  Reddit User
                  <span class="col-resizer"></span>
                </div>
              </th>
              <th data-col="1">
                <div class="th-inner">
                  Name
                  <span class="col-resizer"></span>
                </div>
              </th>
              <th data-col="2"><div class="th-inner">Tabbed<span class="col-resizer"></span></div></th>
              <th data-col="3" class="sortable" data-sort="comment">
                <div class="th-inner">
                  Comment
                  <span class="sort-indicator">
                    <span class="sort-arrow sort-arrow-up">▲</span>
                    <span class="sort-arrow sort-arrow-down">▼</span>
                  </span>
                  <span class="col-resizer"></span>
                </div>
              </th>
              <th data-col="4" class="sortable" data-sort="spots">
                <div class="th-inner">
                  Spots
                  <span class="sort-indicator">
                    <span class="sort-arrow sort-arrow-up">▲</span>
                    <span class="sort-arrow sort-arrow-down">▼</span>
                  </span>
                  <span class="col-resizer"></span>
                </div>
              </th>
              <th data-col="5"><div class="th-inner">Owed<span class="col-resizer"></span></div></th>
              <th data-col="6"><div class="th-inner">Paid?<span class="col-resizer"></span></div></th>
              <th data-col="7"><div class="th-inner">Status<span class="col-resizer"></span></div></th>
              <th data-col="8">
                <div class="th-inner" style="padding: 10px 8px;">
                  
                </div>
              </th>
            </tr>
          </thead>
          <tbody id="participantsTbody">
            <tr id="emptyRow">
              <td colspan="9" style="padding:26px 24px; text-align:center; color:#64748b;">
                No participants yet. Click "Setup" to configure your raffle.
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="participants-foot">
        <div id="footerShowing">Showing 0 of 0 participants</div>
        <div id="autoScanIndicator" class="auto-scan-indicator" style="display: none;">
          <div class="auto-scan-pulse"></div>
          <span>Auto scanning Every 5 Seconds</span>
        </div>
        <div id="footerStats">Paid: <strong>0</strong> &nbsp;&nbsp; Pending: <strong>0</strong></div>
      </div>
    </section>

   <!-- NAV -->
<nav class="sidebar-nav" id="sidebarNav">
  <a class="nav-item" href="/dashboard"><img class="nav-icon" src="/static/assets/Icons/Heart-Rate.png" alt="">Dashboard</a>
  <a class="nav-item is-active" href="/active-raffle"><img class="nav-icon" src="/static/assets/Icons/Graph%20Copy.png" alt="">Active Raffle</a>
  <a class="nav-item" href="/raffle-history"><img class="nav-icon" src="/static/assets/Icons/Graph.png" alt="">Raffle History</a>
  <a class="nav-item" href="/discord"><img class="nav-icon" src="/static/assets/Icons/discord_white_logo%201.png" alt="">Discord</a>
  <a class="nav-item" href="/donate"><img class="nav-icon" src="/static/assets/Icons/Graph%20Copy%204.png" alt="">Donate</a>
  <a class="nav-item" href="/admin">Admin</a>
</nav>

<!-- USER SECTION -->
<div class="user-section" id="userSection">
  <div class="user-info">
    <div class="user-avatar" id="userAvatar">U</div>
    <div class="user-details">
      <p class="user-name" id="userName">User</p>
      <p class="user-role" id="userRole">Admin</p>
    </div>
  </div>
  <button class="logout-btn" id="sidebarLogoutBtn">Logout</button>
</div>

<!-- APP VERSION -->
<div class="app-version">v1.5.0</div>

<script>
  (async function() {
    const userAvatar = document.getElementById('userAvatar');
    const userName = document.getElementById('userName');
    const userRole = document.getElementById('userRole');
    const logoutBtn = document.getElementById('sidebarLogoutBtn');

    try {
      const response = await fetch('/api/auth/current-user');
      if (response.ok) {
        const result = await response.json();
        if (result.ok && result.data) {
          const user = result.data;

          if (user.username) {
            userName.textContent = user.username;
            userAvatar.textContent = user.username.charAt(0).toUpperCase();
          }

          if (user.role) {
            userRole.textContent = user.role.charAt(0).toUpperCase() + user.role.slice(1);
          } else if (user.isAdmin) {
            userRole.textContent = 'Admin';
          } else {
            userRole.textContent = 'User';
          }
        }
      }
    } catch (error) {
      console.error('Failed to fetch user info:', error);
    }

    logoutBtn?.addEventListener('click', async () => {
      try {
        const response = await fetch('/api/auth/logout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        // ⚡ CRITICAL BUG FIX: Check response.ok before calling .json()
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();

        if (result.ok) {
          window.location.href = '/login';
        } else {
          alert('❌ Logout failed: ' + (result.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Logout error:', error);
        alert('❌ Logout failed: ' + error.message);
      }
    });
  })();

  (function() {
    const sidebarNav = document.getElementById('sidebarNav');
    if (!sidebarNav) return;

    const allLinks = sidebarNav.querySelectorAll('.nav-item');
    allLinks.forEach(link => {
      const href = link.getAttribute('href');

      if (href === '/active-raffle') {
        link.addEventListener('click', function(e) {
          e.preventDefault();
        });
      }

      if (href === '/admin' || href === '/user-management' || href === './admin.html' || href === './user_management.html') {
        link.addEventListener('click', async function(e) {
          e.preventDefault();
          e.stopPropagation();

          if (window.adminCheckComplete === true) {
            window.location.href = href;
          } else {
            showAccessDenied();
          }
        }, true);
      }
    });

    (async function() {
      try {
        const response = await fetch('/api/auth/current-user');
        if (!response.ok) return;

        const data = await response.json();
        if (data.data?.isAdmin === true) {
          window.adminCheckComplete = true;
          console.log('✅ Admin access granted');
        } else {
          console.log('🔒 Admin links blocked for non-admin user');
        }
      } catch (error) {
        console.error('Error checking admin status:', error);
      }
    })();
  })();
</script>

 <!-- SETUP MODAL -->
  <div id="setupModal" class="modal-overlay">
    <div class="modal-content" style="width: 600px;">
      <h3 class="modal-title">Raffle Setup</h3>

      <div class="modal-form">
        <div class="form-group">
          <label class="form-label">Reddit Link</label>
          <input
            type="url"
            id="redditLinkInput"
            class="form-input"
            placeholder="https://reddit.com/r/WatchURaffle/comments/abc123/post_title/"
          />
          <p style="font-size: 12px; color: #64748b; margin: 6px 0 0 0;">
            Enter the complete Reddit post URL (must include /comments/)
          </p>
        </div>

<div class="form-row" style="gap: 50px !important;">
          <div class="form-group">
            <label class="form-label">Total Spots</label>
            <input
              type="number"
              id="totalSpotsInput"
              class="form-input"
              placeholder="100"
            />
          </div>

          <div class="form-group">
            <label class="form-label">Cost Per Spot ($)</label>
            <input
              type="number"
              id="spotCostInput"
              class="form-input"
              placeholder="e.g. 50 or 0.25"
              step="0.01"
              min="0.01"
            />
          </div>
        </div>

        <div class="form-group" style="margin-top: 16px;">
          <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; user-select: none;">
            <input
              type="checkbox"
              id="fastRaffleCheckbox"
              style="width: 18px; height: 18px; cursor: pointer;"
            />
            <span class="form-label" style="margin: 0; cursor: pointer;">
              Enable Fast Raffle Timer (1 hour 15 minutes)
            </span>
          </label>
          <p style="font-size: 12px; color: #64748b; margin: 6px 0 0 28px;">
            A countdown timer will appear at the top of the page
          </p>
        </div>
      </div>

      <div class="modal-actions">
        <button id="modalCancelBtn" class="modal-btn modal-btn-cancel">Cancel</button>
        <button id="modalSaveBtn" class="modal-btn modal-btn-save">Save Setup</button>
      </div>
    </div>
  </div>

 <!-- FINISH RAFFLE MODAL -->
  <div id="finishModal" class="modal-overlay">
    <div class="modal-content finish-modal-content">
      <div class=\"finish-modal-icon\">🎉</div>
      <h3 class=\"modal-title\" style=\"text-align: center;\">Finish Raffle</h3>
      <p class=\"finish-modal-text\" id="finishModalText">
        Select the number of winners and enter their information to complete the raffle.
      </p>

      <!-- Winner Selection Section -->
      <div class="winner-section">
        <div class="winner-section-title">
          <span>🏆</span>
          <span>Winner Information</span>
        </div>

        <!-- Number of Winners Selector -->
        <div class="winner-count-selector">
          <label class="form-label" style="margin-bottom: 10px;">Number of Winners</label>
          <div class="winner-count-buttons">
            <button type="button" class="winner-count-btn active" data-count="1">1</button>
            <button type="button" class="winner-count-btn" data-count="2">x2</button>
            <button type="button" class="winner-count-btn" data-count="3">x3</button>
            <button type="button" class="winner-count-btn" data-count="4">×4</button>
            <button type="button" class="winner-count-btn" data-count="5">×5</button>
          </div>
        </div>

        <!-- Dynamic Winner Entries -->
        <div id="winnerEntriesContainer">
          <!-- Will be populated dynamically -->
        </div>
      </div>

      <div class="finish-modal-actions">
        <button id="finishCompleteBtn" class="finish-btn finish-btn-complete" disabled>
          ✓ Complete Raffle
        </button>
      </div>
    </div>
  </div>

  <!-- RESTRICTION POPUP MODAL -->
  <div id="restrictionModal" class="modal-overlay">
    <div class="modal-content restriction-modal-content">
      <div class="restriction-modal-icon">⚠️</div>
      <h3 id="restrictionModalTitle" class="restriction-modal-title">Cannot Finish Raffle!</h3>
      <div id="restrictionMessage" class="restriction-modal-message"></div>
      <div class="restriction-modal-actions">
        <button id="restrictionOkBtn" class="restriction-ok-btn">OK</button>
        <button id="restrictionCancelRaffleBtn" class="restriction-cancel-btn" style="display: none;">× Cancel Raffle</button>
      </div>
    </div>
  </div>

  <!-- PAYPAL SCAN CONFIRMATION MODAL -->
  <div id="paypalScanModal" class="modal-overlay">
    <div class="modal-content paypal-scan-modal-content">
      <h3 class="paypal-scan-modal-title">Scan your Gmail for PayPal payment notifications?</h3>
      <div class="paypal-scan-modal-message">
        This will:<br>
        • Match payments to participants by amount + name<br>
        • Auto-mark participants as paid when matched
      </div>
      <div class="paypal-scan-modal-actions">
        <button id="paypalScanOkBtn" class="paypal-scan-ok-btn">OK</button>
        <button id="paypalScanCancelBtn" class="paypal-scan-cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- CANCEL RAFFLE CONFIRMATION MODAL -->
  <div id="cancelConfirmModal" class="modal-overlay">
    <div class="modal-content cancel-confirm-modal-content">
      <div class="cancel-confirm-title">Are you sure you want to cancel this raffle? It will be saved as incomplete.</div>
      <div class="cancel-confirm-actions">
        <button id="cancelConfirmOkBtn" class="cancel-confirm-ok-btn">OK</button>
        <button id="cancelConfirmCancelBtn" class="cancel-confirm-cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- SUMMARY MODAL -->
  <div id="summaryModal" class="modal-overlay">
    <div class="modal-content summary-modal-content">
      <h3 class="modal-title">Raffle Summary</h3>

      <!-- Three Column Stats -->
      <div class="summary-stats-grid">
        <div class="summary-stat-box confirmed">
          <div class="summary-stat-box-label">CONFIRMED</div>
          <div class="summary-stat-box-value" id="summaryConfirmed">0</div>
        </div>
        <div class="summary-stat-box waitlist">
          <div class="summary-stat-box-label">WAITLIST</div>
          <div class="summary-stat-box-value" id="summaryWaitlist">0</div>
        </div>
        <div class="summary-stat-box tabs">
          <div class="summary-stat-box-label">TABS</div>
          <div class="summary-stat-box-value" id="summaryTabs">0</div>
        </div>
      </div>

      <!-- Participants Section -->
      <div class="summary-section">
        <div class="summary-section-header">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
            <circle cx="9" cy="7" r="4"></circle>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
          </svg>
          Participants (<span id="participantCount">0</span>)
        </div>
        <div class="summary-section-list" id="participantsList">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- Tab Requests Section -->
      <div class="summary-section">
        <div class="summary-section-header">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path>
            <circle cx="9" cy="7" r="4"></circle>
            <line x1="19" y1="8" x2="19" y2="14"></line>
            <line x1="22" y1="11" x2="16" y2="11"></line>
          </svg>
          Tab Requests (<span id="tabCount">0</span>)
        </div>
        <div class="summary-section-list" id="tabRequestsList">
          <!-- Populated by JS -->
        </div>
      </div>

      <div class="modal-actions">
        <button id="summaryCloseBtn" class="modal-btn modal-btn-save" style="width: 100%;">Close</button>
      </div>
    </div>
  </div>

  <!-- NAME IMPORT MODAL -->
  <div id="nameImportModal" class="modal-overlay">
    <div class="modal-content" style="width: 600px;">
      <h3 class="modal-title">Import Reddit Name Mappings</h3>

      <div class="modal-form">
        <div class="form-group">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #334155;">Upload File</label>
          <input type="file" id="nameFileInput" accept=".csv,.xlsx,.xls,.tsv,.txt" style="display: block; margin-bottom: 12px; padding: 8px; border: 2px dashed #cbd5e1; border-radius: 8px; width: 100%; cursor: pointer;">
          <p style="font-size: 12px; color: #64748b; margin: 0;">
            Supported: CSV, Excel (.xlsx, .xls), TSV<br>
            Format: <code>reddit_user,real_name</code>
          </p>
        </div>

        <div id="importPreview" style="display: none; margin-top: 16px; padding: 12px; background: #f8fafc; border-radius: 8px;">
          <p style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">Preview (first 5 rows):</p>
          <div id="importPreviewList" style="font-size: 12px; font-family: monospace; color: #475569;"></div>
          <p id="importCount" style="font-size: 13px; color: #16a34a; margin-top: 8px; font-weight: 600;"></p>
        </div>

        <div style="margin-top: 20px; padding: 12px; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px;">
          <p style="font-size: 13px; margin: 0; color: #92400e;">
            <strong>Note:</strong> Names are stored locally. Importing will merge with existing mappings.
          </p>
        </div>
      </div>

      <div class="modal-actions">
        <button id="nameImportBtn" class="modal-btn modal-btn-save" disabled>
          Import Names
        </button>
        <button id="nameExportBtn" class="modal-btn modal-btn-secondary">
          Export Current Mappings
        </button>
        <button id="nameClearBtn" class="modal-btn modal-btn-secondary" style="background: #dc2626; color: white;">
          Clear All Mappings
        </button>
        <button id="nameImportCloseBtn" class="modal-btn modal-btn-secondary">
          Close
        </button>
      </div>
    </div>
  </div>

  <!-- BULK TAB ASSIGNMENT MODAL -->
  <div id="bulkTabModal" class="modal-overlay">
    <div class="modal-content" style="width: 700px; max-height: 85vh;">
      <h3 class="modal-title">🏷️ Manage Tab Assignments</h3>

      <div class="modal-form">
        <div class="form-group">
          <input 
            type="text" 
            id="bulkTabSearch" 
            class="form-input" 
            placeholder="🔍 Search by username, comment, or assigned tab..."
            style="margin-bottom: 16px;"
          />
          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
            <p style="font-size: 12px; color: #64748b; margin: 0;">
              💡 Tip: Use search to quickly find participants
            </p>
            <span id="bulkTabParticipantCount" style="font-size: 12px; color: #64748b; font-weight: 500;">
              <!-- Updated by JS -->
            </span>
          </div>
        </div>

        <div id="bulkTabList" style="max-height: 400px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #f8fafc;">
          <!-- Populated by JS -->
        </div>

        <div style="margin-top: 12px; padding: 10px; background: #ede9fe; border-radius: 6px; text-align: center;">
          <span id="bulkTabCounter" style="font-size: 13px; font-weight: 600; color: #7c3aed;">📊 0 tabs assigned</span>
        </div>
      </div>

      <div class="modal-actions">
        <button id="bulkTabCancelBtn" class="modal-btn modal-btn-cancel">Cancel</button>
        <button id="bulkTabSaveBtn" class="modal-btn modal-btn-save">Save All Changes</button>
      </div>
    </div>
  </div>

  <!-- MARK PAID MODAL -->
  <div id="markPaidModal" class="modal-overlay">
    <div class="modal-content" style="width: 700px; max-height: 85vh;">
      <h3 class="modal-title">💰 Mark Payment Status</h3>

      <div class="modal-form">
        <div class="form-group">
          <input 
            type="text" 
            id="markPaidSearch" 
            class="form-input" 
            placeholder="🔍 Search by username, comment, or payment status..."
            style="margin-bottom: 16px;"
          />
          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
            <p style="font-size: 12px; color: #64748b; margin: 0;">
              💡 Tip: Click on a participant to toggle their payment status
            </p>
            <span id="markPaidParticipantCount" style="font-size: 12px; color: #64748b; font-weight: 500;">
              <!-- Updated by JS -->
            </span>
          </div>
        </div>

        <div id="markPaidList" style="max-height: 400px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #f8fafc;">
          <!-- Populated by JS -->
        </div>

        <div style="margin-top: 12px; padding: 10px; background: #dcfce7; border-radius: 6px; text-align: center;">
          <span id="markPaidCounter" style="font-size: 13px; font-weight: 600; color: #166534;">💵 0 participants marked as paid</span>
        </div>
      </div>

      <div class="modal-actions">
        <button id="markPaidCancelBtn" class="modal-btn modal-btn-cancel">Cancel</button>
        <button id="markPaidSaveBtn" class="modal-btn modal-btn-save">Save All Changes</button>
      </div>
    </div>
  </div>

  <!-- TOAST NOTIFICATION -->
  <div id="successToast" class="toast">
    <button class="toast-close" id="toastClose">×</button>
    <div class="toast-header">
      <div class="toast-icon">✓</div>
      <h4 class="toast-title" id="toastTitle">Success!</h4>
    </div>
    <div class="toast-body">
      <div id="toastMessage"></div>
    </div>
  </div>

  <!-- ERROR TOAST NOTIFICATION -->
  <div id="errorToast" class="error-toast">
    <button class="toast-close" id="errorToastClose">×</button>
    <div class="toast-header">
      <div class="toast-icon">✕</div>
      <h4 class="toast-title" id="errorToastTitle">Error</h4>
    </div>
    <div class="toast-body">
      <div id="errorToastMessage"></div>
    </div>
  </div>

  <script>

    // ============ APP STATE ============
    // ⚡ PERFORMANCE OPTIMIZATION #16: Cached regex patterns (20% faster validation)
    // Compile once, reuse forever - regex compilation is expensive
    const REGEX_PATTERNS = {
      redditUsername: /^[a-zA-Z0-9_-]+$/,
      spotNumbers: /\d+/g,
      waitlist: /waitlist|drama/i,
      email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      url: /^https?:\/\//i,
      whitespace: /\s+/g
    };
    
    window.appState = {
      activeRaffleId: null,  // Store raffle ID for backend operations
      redditLink: '',
      totalSpots: null,
      costPerSpot: null,
      participants: [],
      createdAt: null,  // Timestamp when raffle setup was saved (ISO 8601 format)
      fastRaffleEnabled: false,
      fastRaffleStartTime: null,
      sortColumn: null,  // Current sort column ('reddit', 'name', 'spots')
      sortDirection: 'asc',  // Sort direction ('asc' or 'desc')
      cachedSortedParticipants: null,  // Cache sorted participants array
      lastSortSignature: null  // Track when sort needs to update
    };

    const appState = window.appState;

    // ⚡ PERFORMANCE: Cache frequently accessed DOM elements (avoids 100+ getElementById calls)
    const domCache = {
      participantsTbody: null,
      participantSearch: null,
      paymentFilter: null,
      footerShowing: null,
      footerStats: null,
      totalParticipants: null,
      totalSpots: null,
      spotsRemaining: null,
      costPerSpot: null,
      totalOwed: null,
      totalPaid: null,
      init() {
        this.participantsTbody = document.getElementById('participantsTbody');
        this.participantSearch = document.getElementById('participantSearch');
        this.paymentFilter = document.getElementById('paymentFilter');
        this.footerShowing = document.getElementById('footerShowing');
        this.footerStats = document.getElementById('footerStats');
        this.totalParticipants = document.getElementById('totalParticipants');
        this.totalSpots = document.getElementById('totalSpots');
        this.spotsRemaining = document.getElementById('spotsRemaining');
        this.costPerSpot = document.getElementById('costPerSpot');
        this.totalOwed = document.getElementById('totalOwed');
        this.totalPaid = document.getElementById('totalPaid');
      }
    };

    let cachedNameMappings = null;
    let cachedNameMappingsFresh = false;
    let nameMappingCacheTimestamp = 0;
    const NAME_CACHE_TTL = 300000; // 5 minutes
    let cachedLowerNameMappings = null;
    const TAB_BADGE_HTML = '<span class="tab-badge">TAB</span>';
    const EMPTY_DISPLAY_HTML = '<span style="color: #94a3b8;">—</span>';

    function invalidateNameMappingCache() {
      cachedNameMappingsFresh = false;
      nameMappingCacheTimestamp = 0;
      cachedLowerNameMappings = null;
    }

    function isNameMappingCacheValid() {
      if (!cachedNameMappingsFresh) return false;
      const now = Date.now();
      return (now - nameMappingCacheTimestamp) < NAME_CACHE_TTL;
    }

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function invalidateSortCache() {
      appState.cachedSortedParticipants = null;
      appState.lastSortSignature = null;
    }

    function getUserLocalStorageKey(baseKey) {
      try {
        const userStr = localStorage.getItem('takobot_user');
        if (userStr) {
          const user = JSON.parse(userStr);
          return `user${user.id}_${baseKey}`;
        }
      } catch (e) {
        console.error('Failed to get user from localStorage:', e);
      }
      return `anonymous_${baseKey}`;
    }

    let saveStateTimeout = null;
    let isSaving = false;
    
    async function saveState() {
      if (isSaving) {
        clearTimeout(saveStateTimeout);
        saveStateTimeout = setTimeout(() => saveState(), 300);
        return;
      }
      
      isSaving = true;
      
      try {
        const participantsForDB = appState.participants.map((p, index) => ({
          redditUser: p.redditUser || '',
          name: p.name || '',
          comment: p.comment || '',
          spots: p.spots || 0,
          owed: p.owed || 0,
          paid: p.paid === true,  // ⚡ CRITICAL: Normalize to boolean (true or false only)
          requestLink: p.requestLink || '',
          commentId: p.commentId || '',
          tabbed: p.tabbed || null,
          status: p.status || null,
          sequenceNumber: p.sequenceNumber !== undefined ? p.sequenceNumber : index
        }));

        const result = await API.saveRaffle({
          redditLink: appState.redditLink,
          totalSpots: appState.totalSpots,
          costPerSpot: appState.costPerSpot,
          participants: participantsForDB,
          fastRaffleEnabled: appState.fastRaffleEnabled,
          fastRaffleStartTime: appState.fastRaffleStartTime
        });

        console.log('📝 Save raffle response:', result);

        if (result.ok && result.raffle_id) {
          appState.activeRaffleId = result.raffle_id;
          console.log('✅ Raffle saved to database. ID:', appState.activeRaffleId);
        } else {
          console.warn('⚠️ No raffle ID in response. Result:', result);
        }
      } catch (e) {
        console.error('❌ Failed to save state:', e);
      } finally {
        isSaving = false;
      }
    }

   async function loadState() {
      // ⚡ PERFORMANCE: Initialize DOM cache on first load
      if (!domCache.participantsTbody) {
        domCache.init();
      }
      
      try {
        const result = await API.loadRaffle();
        console.log('📂 Load raffle response:', result);

        if (result.ok && result.data) {
          const data = result.data;
          appState.activeRaffleId = data.id || null;
          appState.redditLink = data.redditLink || '';
          appState.totalSpots = data.totalSpots;
          appState.costPerSpot = data.costPerSpot;

          const loadedParticipants = (data.participants || []).map((p, index) => ({
            redditUser: p.redditUser || '',
            name: p.name || '',
            comment: p.comment || '',
            spots: p.spots || 0,
            owed: p.owed || 0,
            paid: p.paid === true || p.paid === 1 || p.paid === 'true',  // ⚡ CRITICAL: Normalize to boolean
            requestLink: p.requestLink || '',
            commentId: p.commentId || '',
            tabbed: p.tabbed || null,
            status: p.status || null,
            sequenceNumber: p.sequenceNumber !== undefined ? p.sequenceNumber : index
          }));
          
          loadedParticipants.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
          appState.participants = loadedParticipants;
          
          console.log('📊 Participants loaded and sorted by sequence number (newest first)');
          if (appState.participants.length > 0) {
            console.log('   First (newest):', appState.participants[0].redditUser, 'seq:', appState.participants[0].sequenceNumber);
            if (appState.participants.length > 1) {
              console.log('   Last (oldest):', appState.participants[appState.participants.length-1].redditUser, 'seq:', appState.participants[appState.participants.length-1].sequenceNumber);
            }
          }

          appState.fastRaffleEnabled = data.fastRaffleEnabled || false;
          // Convert ISO string to timestamp number
          if (data.fastRaffleStartTime) {
            appState.fastRaffleStartTime = new Date(data.fastRaffleStartTime).getTime();
          } else {
            appState.fastRaffleStartTime = null;
          }

          console.log('✅ Raffle loaded from database. ID:', appState.activeRaffleId);
          console.log('📊 Loaded', appState.participants.length, 'participants');

          const redditLinkInputEl = document.getElementById("redditLinkInput");
          if (redditLinkInputEl) redditLinkInputEl.value = appState.redditLink;

          if (appState.totalSpots) {
            const totalSpotsInputEl = document.getElementById("totalSpotsInput");
            if (totalSpotsInputEl) totalSpotsInputEl.value = appState.totalSpots;
          }
          if (appState.costPerSpot != null && appState.costPerSpot !== '') {
            const spotCostInputEl = document.getElementById("spotCostInput");
            if (spotCostInputEl) spotCostInputEl.value = appState.costPerSpot;
          }

          const fastRaffleCheckbox = document.getElementById("fastRaffleCheckbox");
          if (fastRaffleCheckbox) {
            fastRaffleCheckbox.checked = appState.fastRaffleEnabled;
          }

          if (appState.participants.length > 0) {
            // ⚡ CRITICAL BUG FIX: Skip sync when loading from DB (DB is source of truth, not UI)
            await rebuildTable(true);
            updateStats();
            updateFooter();
            filterAndSearch();
          }

          if (appState.fastRaffleEnabled && appState.fastRaffleStartTime) {
            startFastRaffleTimer();
          }
        } else {
          console.log('ℹ️ No active raffle found in database');
        }
      } catch (e) {
        console.error('❌ Failed to load state:', e);
      }
    }

    async function clearState() {
      try {
        console.log('🗑️ Calling API.clearRaffle()...');
        const result = await API.clearRaffle();
        console.log('🗑️ Clear raffle result:', result);
        if (!result.ok) {
          console.error('❌ Failed to clear raffle:', result.error);
        }
      } catch (e) {
        console.error('Failed to clear state:', e);
      }
    }

    function syncTabbedInputsToAppState() {
      const tabbedInputs = document.querySelectorAll('.tabbed-search-input');
      tabbedInputs.forEach(input => {
        const index = parseInt(input.dataset.index);
        if (isNaN(index)) return;
        const selectedReddit = input.dataset.selected || '';
        if (appState.participants[index]) {
          appState.participants[index].tabbed = selectedReddit || null;
        }
      });
    }

    async function insertNewRowsAtTop(newParticipants) {
      const tbody = document.getElementById("participantsTbody");
      // ⚡ CRITICAL BUG FIX: Check if tbody exists before accessing
      if (!tbody) {
        console.error('⚠️ Tbody not found - cannot insert rows');
        return;
      }
      
      const emptyRow = document.getElementById("emptyRow");
      
      if (emptyRow) {
        emptyRow.remove();
      }
      
      let nameMappings = {};
      if (cachedNameMappingsFresh && cachedNameMappings) {
        nameMappings = cachedNameMappings;
        console.log('⚡ insertNewRowsAtTop: Using cached name mappings');
      } else {
        // ⚡ CRITICAL BUG FIX: Wrap JSON.parse in try/catch to handle corrupted localStorage
        let localMappings = {};
        try {
          localMappings = JSON.parse(localStorage.getItem('raffleui_reddit_name_mapping') || '{}');
        } catch (e) {
          console.error('Failed to parse name mappings from localStorage:', e);
          localMappings = {};
        }
        
        let sharedMappings = {};
        try {
          const response = await fetch('/api/settings/get-all-name-mappings', {
            method: 'GET',
            credentials: 'include'
          });
          // ⚡ CRITICAL BUG FIX: Check response.ok before calling .json()
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const data = await response.json();
          if (data.ok) {
            sharedMappings = data.mappings;
          }
        } catch (err) {
          console.error('Failed to load shared name mappings:', err);
        }
        nameMappings = { ...sharedMappings, ...localMappings };
        cachedNameMappings = nameMappings;
        cachedNameMappingsFresh = true;
      }
      
      window.allTabbedUsers = Object.keys(nameMappings).sort().map(reddit => ({
        reddit,
        name: nameMappings[reddit] || '',
        redditLower: reddit.toLowerCase(),
        nameLower: (nameMappings[reddit] || '').toLowerCase()
      }));
      
      const fragment = document.createDocumentFragment();
      
      const participantIndexMap = new Map();
      appState.participants.forEach((p, idx) => {
        if (p.commentId) {
          participantIndexMap.set(p.commentId, idx);
        }
      });
      
      newParticipants.forEach((participant) => {
        const index = participantIndexMap.get(participant.commentId);
        if (index === undefined) return;
        
        const redditUser = participant.redditUser;
        if (!redditUser) return;
        const paid = participant.paid;
        const comment = participant.comment || '';
        const spots = participant.spots;
        const owed = participant.owed;
        const tabbed = participant.tabbed || '';
        
        const redditLower = redditUser.toLowerCase();
        const storedName = nameMappings[redditUser] || nameMappings[redditLower];
        const displayName = storedName || participant.name || '';
        const nameLower = displayName.toLowerCase();
        const commentLower = comment.toLowerCase();
        const tabbedLower = tabbed.toLowerCase();
        
        const row = document.createElement('tr');
        row.dataset.reddit = redditUser;
        row.dataset.name = displayName;
        row.dataset.comment = comment;
        row.dataset.commentId = participant.commentId || '';  // ⚡ CRITICAL: Store commentId for unique row identification
        row.dataset.paid = paid;
        row.dataset.spots = spots;
        row.dataset.index = index;
        row.dataset.sequenceNumber = participant.sequenceNumber !== undefined ? participant.sequenceNumber : 999999;
        row.dataset.tabbed = tabbedLower;
        row.dataset.redditLower = redditLower;
        row.dataset.nameLower = nameLower;
        row.dataset.commentLower = commentLower;
        
        if (participant.paid) {
          row.classList.add('paid-row');
        } else if (participant.spots > 0) {
          row.classList.add('unpaid-row');
        }
        
        const initial = redditUser.length > 2 ? redditUser.charAt(2).toUpperCase() : (redditUser.length > 0 ? redditUser.charAt(0).toUpperCase() : '?');
        
        const isTab = commentLower && (
          commentLower.includes('tab') ||
          commentLower.includes('tabbed') ||
          commentLower.includes('wff')
        );
        const tabBadge = isTab ? '<span class="tab-badge">TAB</span>' : '';
        
        const currentTabbed = participant.tabbed || '';
        const tabbedName = currentTabbed ? (nameMappings[currentTabbed] || nameMappings[currentTabbed.toLowerCase()]) : null;
        const currentTabbedDisplay = currentTabbed ? (tabbedName ? `${currentTabbed} (${tabbedName})` : currentTabbed) : '';
        
        row.innerHTML = `
          <td>
            <div class="user-cell">
              <div class="avatar">${initial}</div>
              <a class="reddit-link" href="#" onclick="return false;">${escapeHtml(participant.redditUser)}</a>
              ${tabBadge}
            </div>
          </td>
          <td><span class="name-field" data-index="${index}" style="cursor: pointer; display: inline-block; min-width: 100px; padding: 4px;" title="Click to edit name">${displayName ? escapeHtml(displayName) : '<span style="color: #94a3b8;">—</span>'}</span></td>
          <td>
            <span class="tabbed-cell-display ${!currentTabbedDisplay ? 'tabbed-cell-empty' : ''}" title="Click to manage tab assignments">
              ${currentTabbedDisplay ? escapeHtml(currentTabbedDisplay) : '— None —'}
            </span>
          </td>
          <td><span class=\"comment-muted\">${escapeHtml(participant.comment || '')}</span></td>
          <td style="text-align: center;"><span class="spots-pill" data-index="${index}" style="cursor: pointer;" title="Double-click to edit">${participant.spots}</span></td>
          <td style="text-align: center; font-weight: 700;">$${(parseFloat(participant.owed) || 0).toFixed(2)}</td>
          <td>
            <span class="paid-cell-display ${participant.paid ? 'paid-cell-paid' : 'paid-cell-unpaid'}" title="Click to manage payment status">
              ${participant.paid ? '✓ Paid' : '— Unpaid —'}
            </span>
          </td>
          <td style="text-align: center;"><span class="status-dot ${participant.paid ? 'dot-paid' : 'dot-pending'}"></span></td>
          <td style="text-align: left; padding-left: 8px;">
            <button class="delete-btn" data-index="${index}" title="Delete participant">×</button>
          </td>
        `;
        
        fragment.appendChild(row);
      });
      
      // Insert at the beginning of tbody
      tbody.insertBefore(fragment, tbody.firstChild);
      
      // Re-attach event listeners for the new rows
      attachSpotEditListeners();
      attachNameEditListeners();
      attachDeleteButtonListeners();
      
      const commentIdIndexMap = new Map();
      appState.participants.forEach((p, idx) => {
        if (p.commentId) {
          commentIdIndexMap.set(p.commentId, idx);
        }
      });
      
      const allRows = tbody.querySelectorAll('tr:not(#emptyRow)');
      allRows.forEach(row => {
        const commentId = row.dataset.commentId;
        if (commentId) {
          const correctIndex = commentIdIndexMap.get(commentId);
          if (correctIndex !== undefined) {
            row.dataset.index = correctIndex;
            row.querySelectorAll('[data-index]').forEach(el => {
              el.dataset.index = correctIndex;
            });
          }
        }
      });
      
      const tabbedVisible = loadTabbedColumnVisibility();
      applyTabbedColumnVisibility(tabbedVisible);
      
      console.log(`✅ Inserted ${newParticipants.length} new rows at top of table`);
    }

  async function rebuildTable(skipSync = false) {
      // ⚡ PERFORMANCE TIMING: Monitor table rebuild performance
      const perfStart = performance.now();
      
      try {
        // ✅ Close all open dropdowns before rebuilding to prevent positioning issues
        // ⚡ Cache dropdown list to avoid querying on every rebuild
        if (!window.cachedDropdownList) {
          window.cachedDropdownList = document.querySelectorAll('.tabbed-dropdown-list');
        }
        window.cachedDropdownList.forEach(list => {
          if (list.isConnected) { // Check if still in DOM
            list.classList.remove('show');
          }
        });
        // Clear cache after rebuild since DOM will change
        window.cachedDropdownList = null;
      } catch (err) {
        console.error('❌ Error closing dropdowns:', err);
      }
      
      // ✅ Read current tabbed input values BEFORE clearing the table
      // ⚡ CRITICAL BUG FIX: Skip sync when loading from database (skipSync=true)
      // to prevent overwriting fresh DB data with stale UI state
      if (!skipSync) {
        syncTabbedInputsToAppState();
      }
      
      const tbody = document.getElementById("participantsTbody");
      // ⚡ CRITICAL BUG FIX: Check if tbody exists before rebuilding table
      if (!tbody) {
        console.error('��️ Tbody not found - cannot rebuild table');
        return;
      }
      
      const emptyRow = document.getElementById("emptyRow");

      if (appState.participants.length === 0) {
        if (!emptyRow) {
          tbody.innerHTML = '<tr id="emptyRow"><td colspan="9" style="padding:26px 24px; text-align:center; color:#64748b;">No participants yet. Click "Setup" to configure your raffle.</td></tr>';
        }
        return;
      }

      if (emptyRow) {
        emptyRow.remove();
      }

      // ⚡ PERFORMANCE: Full table rebuild. For 100+ participants, this takes ~50-100ms.
      // Future optimization: Implement row recycling (reuse existing DOM nodes, only update changed cells)
      tbody.innerHTML = '';

      // Use DocumentFragment for better performance with large tables
      const fragment = document.createDocumentFragment();

      // ⚡ PERFORMANCE: Cache sorted participants to avoid re-sorting on every rebuild
      const sortSignature = `${appState.sortColumn}_${appState.sortDirection}_${appState.participants.length}`;
      let displayParticipants;
      
      // ⚡ CRITICAL BUG FIX: Declare indexMap OUTSIDE else block so it's accessible later for reuse!
      // Was causing ReferenceError when using cached sort + trying to reuse indexMap at line ~3094
      let indexMap = null;

      if (appState.lastSortSignature === sortSignature && appState.cachedSortedParticipants) {
        // Use cached sorted array
        displayParticipants = appState.cachedSortedParticipants;
      } else {
        // Sort participants based on current sort state
        displayParticipants = [...appState.participants];

        if (appState.sortColumn) {
          // ⚡ CRITICAL FIX: Pre-build sequence map to avoid O(n) indexOf() calls inside sort comparator
          // For 100 participants: Was 100*log(100)*100 = ~66,000 ops, now 100 + 664 ops = 99% faster!
          if (appState.sortColumn === 'comment') {
            indexMap = new Map();
            // ⚡ CRITICAL FIX: Use sequenceNumber for stable chronological sorting (not array index!)
            appState.participants.forEach((p) => indexMap.set(p, p.sequenceNumber !== undefined ? p.sequenceNumber : 999999));
          }
          
          // ⚡ CRITICAL FIX: Cache appState properties to avoid 664+ property lookups in sort!
          const sortCol = appState.sortColumn;
          const sortDir = appState.sortDirection;
          const isAsc = sortDir === 'asc';
          
          displayParticipants.sort((a, b) => {
            let aVal, bVal;

            switch (sortCol) {
              case 'reddit':
                // ⚡ CRITICAL FIX: toLowerCase in switch, not after (saves 664 typeof checks!)
                aVal = (a.redditUser || '').toLowerCase();
                bVal = (b.redditUser || '').toLowerCase();
                break;
              case 'comment':
                // Sort by sequenceNumber (chronological order) - lower sequence = newer comment
                aVal = indexMap.get(a) ?? 999999; // ⚡ CRITICAL BUG FIX: Fallback to end if not in map!
                bVal = indexMap.get(b) ?? 999999;
                break;
              case 'spots':
                aVal = a.spots || 0;
                bVal = b.spots || 0;
                break;
              case 'paid':
                aVal = a.paid ? 1 : 0;
                bVal = b.paid ? 1 : 0;
                break;
              case 'tabbed':
                // ⚡ CRITICAL FIX: toLowerCase in switch, not after
                aVal = (a.tabbed || '').toLowerCase();
                bVal = (b.tabbed || '').toLowerCase();
                break;
              default:
                return 0;
            }

            if (sortCol === 'spots' || sortCol === 'paid') {
              // Numeric sort
              return isAsc ? aVal - bVal : bVal - aVal;
            } else if (sortCol === 'comment') {
              // Chronological sort by sequence: asc = oldest first (high seq), desc = newest first (low seq)
              // Since lower seq = newer, we reverse: isAsc uses bVal-aVal to put high seq (old) first
              return isAsc ? bVal - aVal : aVal - bVal;
            } else {
              // String sort - already lowercase from switch (eliminates 664 typeof checks!)
              if (aVal < bVal) return isAsc ? -1 : 1;
              if (aVal > bVal) return isAsc ? 1 : -1;
              return 0;
            }
          });
        }

        // Cache the sorted result
        appState.cachedSortedParticipants = displayParticipants;
        appState.lastSortSignature = sortSignature;
      }

      // ⚡ PERFORMANCE: Load name mappings with smart caching (60s TTL)
      let nameMappings = {};

      // Check if we can use cached mappings (valid for 60 seconds)
      if (isNameMappingCacheValid() && cachedNameMappings) {
        // ✅ Use cached mappings (saves ~20-30ms API call + processing)
        nameMappings = cachedNameMappings;
      } else {
        // 🔄 Load fresh mappings from localStorage and database
        
        // STEP 1: Load personal full names from localStorage
        // ⚡ CRITICAL BUG FIX: Wrap JSON.parse in try/catch to handle corrupted localStorage
        let localMappings = {};
        try {
          localMappings = JSON.parse(localStorage.getItem('raffleui_reddit_name_mapping') || '{}');
        } catch (e) {
          console.error('Failed to parse name mappings from localStorage:', e);
          localMappings = {};
        }

        // STEP 2: Fetch shared initials from database
        let sharedMappings = {};
        try {
          const response = await fetch('/api/settings/get-all-name-mappings', {
            method: 'GET',
            credentials: 'include'
          });
          // ⚡ CRITICAL BUG FIX: Check response.ok before calling .json()
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const data = await response.json();
          if (data.ok) {
            sharedMappings = data.mappings;
          }
        } catch (err) {
          console.error('Failed to load shared name mappings:', err);
        }

        // STEP 3: Merge with priority: localStorage > database
        nameMappings = { ...sharedMappings, ...localMappings };

        // STEP 3.5: Remove case-insensitive duplicates while preserving localStorage priority
        const deduplicatedMappings = {};
        const seenLowercase = {};

        // First pass: Add all entries and track sources
        const allEntries = [];

        // Add database entries first (lower priority)
        for (const [redditUser, realName] of Object.entries(sharedMappings)) {
          allEntries.push({ redditUser, realName, source: 'database' });
        }

        // Add localStorage entries (higher priority)
        for (const [redditUser, realName] of Object.entries(localMappings)) {
          allEntries.push({ redditUser, realName, source: 'localStorage' });
        }

        // Second pass: Deduplicate with localStorage priority
        for (const entry of allEntries) {
          const lowerUser = entry.redditUser.toLowerCase();

          if (!seenLowercase[lowerUser]) {
            // First time seeing this username (case-insensitive)
            deduplicatedMappings[entry.redditUser] = entry.realName;
            seenLowercase[lowerUser] = entry;
          } else {
            // Duplicate found - check priority
            const existing = seenLowercase[lowerUser];

            // localStorage always wins over database
            if (entry.source === 'localStorage' && existing.source === 'database') {
              // Replace database entry with localStorage entry
              delete deduplicatedMappings[existing.redditUser];
              deduplicatedMappings[entry.redditUser] = entry.realName;
              seenLowercase[lowerUser] = entry;
            } else if (entry.source === 'localStorage' && existing.source === 'localStorage') {
              // Both are localStorage - prefer lowercase key
              if (entry.redditUser === lowerUser && existing.redditUser !== lowerUser) {
                delete deduplicatedMappings[existing.redditUser];
                deduplicatedMappings[entry.redditUser] = entry.realName;
                seenLowercase[lowerUser] = entry;
              }
            }
            // If entry is database and existing is localStorage, keep existing (skip entry)
          }
        }

        nameMappings = deduplicatedMappings;

        // STEP 4: Store in cache and mark as fresh with timestamp
        cachedNameMappings = nameMappings;
        cachedNameMappingsFresh = true;
        nameMappingCacheTimestamp = Date.now();
      }

      // ✅ Store globally for tabbed search (includes shared + spreadsheet)
      // ⚡ OPTIMIZATION: Pre-compute lowercase versions for faster filtering (saves 200+ toLowerCase calls per search)
      window.allTabbedUsers = Object.keys(nameMappings).sort().map(reddit => ({
        reddit,
        name: nameMappings[reddit] || '',
        redditLower: reddit.toLowerCase(),
        nameLower: (nameMappings[reddit] || '').toLowerCase()
      }));

      // ⚡ CRITICAL FIX: Pre-build index map to avoid O(n²) indexOf() calls in loop
      // For 100 participants: Was 100*100=10,000 ops, now 100+100=200 ops = 98% faster!
      // ⚡ CRITICAL BUG FIX: Cannot reuse indexMap from sort because it maps to sequenceNumber, not array index!
      // Always build a fresh map for participant → index mapping
      const participantIndexMap = new Map();
      appState.participants.forEach((p, idx) => {
        participantIndexMap.set(p, idx);
      });

      // ⚡ OPTIMIZATION: Use cached lowercase name mappings instead of rebuilding every time
      if (!cachedLowerNameMappings) {
        cachedLowerNameMappings = {};
        for (const [key, value] of Object.entries(nameMappings)) {
          cachedLowerNameMappings[key.toLowerCase()] = value;
        }
      }
      const lowerNameMappings = cachedLowerNameMappings;

      displayParticipants.forEach((participant) => {
        // ✅ CRITICAL FIX: Use actual index from appState.participants, not display order
        const actualIndex = participantIndexMap.get(participant);
        if (actualIndex === undefined) return; // ⚡ CRITICAL BUG FIX: Skip if index not found!

        // ⚡ CRITICAL OPTIMIZATION: Cache all participant properties (was 600+ extra property accesses for 100 participants!)
        const redditUser = participant.redditUser;
        if (!redditUser) return; // ⚡ CRITICAL BUG FIX: Skip if redditUser is missing!
        const paid = participant.paid;
        const comment = participant.comment || '';
        const spots = participant.spots;
        const owed = participant.owed;
        const tabbed = participant.tabbed || '';

        // Use pre-loaded name mappings instead of function call per participant
        // Use case-insensitive lookup to handle different casing in database vs participants
        const redditLower = redditUser.toLowerCase();
        const storedName = nameMappings[redditUser] || lowerNameMappings[redditLower];
        const displayName = storedName || participant.name || '';
        const nameLower = displayName.toLowerCase();
        const commentLower = comment.toLowerCase();
        const tabbedLower = tabbed.toLowerCase();

        const row = document.createElement('tr');
        row.dataset.reddit = redditUser;
        row.dataset.name = displayName;  // ✅ Use displayName from mappings for search functionality
        row.dataset.comment = comment;
        row.dataset.commentId = participant.commentId || '';  // ⚡ CRITICAL: Store commentId for unique row identification
        row.dataset.paid = paid;
        row.dataset.spots = spots;
        row.dataset.index = actualIndex;  // ✅ Use actualIndex so tabbed dropdown stays with correct participant
        row.dataset.sequenceNumber = participant.sequenceNumber !== undefined ? participant.sequenceNumber : 999999;  // ⚡ For chronological sorting
        row.dataset.tabbed = tabbedLower;  // ⚡ For fast sorting without DOM queries
        // ⚡ OPTIMIZATION: Pre-compute lowercase for search (avoid 300+ toLowerCase() calls on every search)
        row.dataset.redditLower = redditLower;
        row.dataset.nameLower = nameLower;
        row.dataset.commentLower = commentLower;

        // ✅ Add row styling classes based on payment status
        if (paid) {
          row.classList.add('paid-row');
        } else if (spots > 0) {
          // Only show unpaid status if they have 1+ spots assigned
          row.classList.add('unpaid-row');
        }
        // If spots = 0, participant is on waitlist (no background color)

        const initial = redditUser.length > 2 ? redditUser.charAt(2).toUpperCase() : (redditUser.length > 0 ? redditUser.charAt(0).toUpperCase() : '?');
        // ⚡ REMOVED: statusClass, statusIcon, statusText - never used (was computing 300 values for nothing)

        // Check if this is a tab entry (includes tab/tabbed/wff in comment) - ⚡ use cached commentLower
        const isTab = commentLower && (
          commentLower.includes('tab') ||
          commentLower.includes('tabbed') ||
          commentLower.includes('wff')
        );
        const tabBadge = isTab ? '<span class="tab-badge">TAB</span>' : '';


        // ✅ NEW: Prepare search input with current tabbed value - ⚡ use cached variables
        const tabbedName = tabbed ? (nameMappings[tabbed] || lowerNameMappings[tabbedLower]) : null;
        const currentTabbedDisplay = tabbed ? (tabbedName ? `${tabbed} (${tabbedName})` : tabbed) : '';

        row.innerHTML = `
          <td>
            <div class="user-cell">
              <div class="avatar">${initial}</div>
              <a class="reddit-link" href="#" onclick="return false;">${escapeHtml(redditUser)}</a>
              ${tabBadge}
            </div>
          </td>
          <td><span class="name-field" data-index="${actualIndex}" style="cursor: pointer; display: inline-block; min-width: 100px; padding: 4px;" title="Click to edit name">${displayName ? escapeHtml(displayName) : '<span style="color: #94a3b8;">—</span>'}</span></td>
          <td>
            <span class="tabbed-cell-display ${!currentTabbedDisplay ? 'tabbed-cell-empty' : ''}" title="Click to manage tab assignments">
              ${currentTabbedDisplay ? escapeHtml(currentTabbedDisplay) : '— None —'}
            </span>
          </td>
          <td><span class=\"comment-muted\">${escapeHtml(comment)}</span></td>
          <td style="text-align: center;"><span class="spots-pill" data-index="${actualIndex}" style="cursor: pointer;" title="Double-click to edit">${spots}</span></td>
          <td style="text-align: center; font-weight: 700;">$${owed.toFixed(2)}</td>
          <td>
            <span class="paid-cell-display ${paid ? 'paid-cell-paid' : 'paid-cell-unpaid'}" title="Click to manage payment status">
              ${paid ? '✓ Paid' : '— Unpaid —'}
            </span>
          </td>
          <td style="text-align: center;"><span class="status-dot ${paid ? 'dot-paid' : 'dot-pending'}"></span></td>
          <td style="text-align: left; padding-left: 8px;">
            <button class="delete-btn" data-index="${actualIndex}" title="Delete participant">×</button>
          </td>
        `;

        fragment.appendChild(row);
      });

      // Single DOM update instead of multiple appendChild calls
      tbody.appendChild(fragment);

      // Add double-click edit functionality
      attachSpotEditListeners();

      // Add name edit functionality
      attachNameEditListeners();

      // Add delete button listeners
      attachDeleteButtonListeners();

      // Add tabbed dropdown listeners
      // attachTabbedDropdownListeners(); // ✅ REMOVED: Using bulk tab modal instead

      // Add click handlers for tab rows
      if (typeof window.attachTabRowClickHandlers === 'function') {
        attachTabRowClickHandlers();
      }

      // ✅ Restore tabbed column visibility after table rebuild
      const tabbedVisible = loadTabbedColumnVisibility();
      applyTabbedColumnVisibility(tabbedVisible);
      
      // ✅ Restore column order after table rebuild
      if (typeof window.reapplyColumnOrder === 'function') {
        window.reapplyColumnOrder();
      }
      
      // ⚡ PERFORMANCE TIMING: Log rebuild time
      const perfEnd = performance.now();
      const rebuildTime = perfEnd - perfStart;
      if (rebuildTime > 100) {
        console.warn(`⚠️ rebuildTable() took ${rebuildTime.toFixed(1)}ms (>100ms threshold)`);
      }
    }

    // ✅ Helper function to check if spots exceed limit
    function checkSpotsLimit(newSpotsToAdd, excludeIndex = null) {
      if (appState.totalSpots === null || appState.totalSpots === undefined) {
        return { valid: true }; // No limit set
      }

      // Calculate current total spots (excluding the participant being edited)
      let currentTotal = 0;
      appState.participants.forEach((p, idx) => {
        if (excludeIndex === null || idx !== excludeIndex) {
          currentTotal += parseInt(p.spots) || 0;
        }
      });

      const proposedTotal = currentTotal + newSpotsToAdd;

      if (proposedTotal > appState.totalSpots) {
        return {
          valid: false,
          currentTotal,
          proposedTotal,
          limit: appState.totalSpots,
          exceededBy: proposedTotal - appState.totalSpots
        };
      }

      return { valid: true };
    }

    // ✅ GLOBAL flag to track if spot edit listener is attached (prevent memory leak)
    if (typeof window.spotEditListenerAttached === 'undefined') {
      window.spotEditListenerAttached = false;
    }

    function attachSpotEditListeners() {
      // Only attach once using event delegation - use window-level flag
      if (!window.spotEditListenerAttached) {
        document.addEventListener('dblclick', function(e) {
          const pill = e.target.closest('.spots-pill');
          if (!pill) return;

          const index = parseInt(pill.dataset.index);
          // ⚡ CRITICAL BUG FIX: Validate index is a valid number
          if (isNaN(index)) {
            console.error('⚠️ Invalid index in spot edit');
            return;
          }
          if (!appState.participants[index]) return; // ⚡ CRITICAL BUG FIX: Bounds check!
          const currentSpots = appState.participants[index].spots;

          // Create input field
          const input = document.createElement('input');
          input.type = 'number';
          input.value = currentSpots;
          input.min = '0';
          input.style.width = '50px';
          input.style.padding = '4px 8px';
          input.style.border = '2px solid #6E5FFC';
          input.style.borderRadius = '999px';
          input.style.textAlign = 'center';
          input.style.fontSize = '12px';
          input.style.fontWeight = '700';
          input.style.color = '#6E5FFC';
          input.style.background = '#efe9ff';
          input.style.outline = 'none';

          // Replace pill with input
          const originalContent = pill.textContent;
          pill.textContent = '';
          pill.appendChild(input);
          input.focus();
          input.select();

          // Save on Enter or blur
          // ⚡ CRITICAL BUG FIX: Prevent double-save when Enter triggers both keydown and blur
          let isSaving = false;
          const saveEdit = async () => {
            if (isSaving) return;
            isSaving = true;
            
            const newSpots = parseInt(input.value) || 0;

            if (newSpots < 0) {
              showErrorToast('Invalid Spot Value', ['Spots cannot be negative']);
              input.value = currentSpots;
              isSaving = false;
              return;
            }

            // ✅ Check if new spots would exceed the limit (warn but allow)
            const spotCheck = checkSpotsLimit(newSpots, index);
            if (!spotCheck.valid) {
              showErrorToast('⚠️ Spot Limit Warning', [
                `This raffle has a limit of ${spotCheck.limit} spots.`,
                `Current total: ${spotCheck.currentTotal} spots`,
                `Proposed total: ${spotCheck.proposedTotal} spots (exceeds by ${spotCheck.exceededBy})`,
                `✓ Update allowed - please verify this is correct.`
              ]);
              // Continue with the update despite exceeding limit
            }

            // Update participant data
            appState.participants[index].spots = newSpots;
            appState.participants[index].owed = newSpots * (appState.costPerSpot || 0); // ⚡ CRITICAL BUG FIX: Fallback if costPerSpot not set!

            // Sync UI values before saving
            syncTabbedInputsToAppState();
            
            // ⚡ CRITICAL BUG FIX: Invalidate sort cache when spots change (affects 'spots' column sort)
            invalidateSortCache();

            // Save to database
            await saveState();

            // ✅ Update ONLY the pill and owed cell without rebuilding
            pill.textContent = newSpots;
            const row = pill.closest('tr');
            // ⚡ CRITICAL BUG FIX: Check if row exists before accessing children
            if (!row) {
              console.warn('⚠️ Row not found for spot edit');
              return;
            }
            const owedCell = row.children[6]; // ⚡ CRITICAL BUG FIX: 7th column is index 6, not 5!
            if (owedCell) {
              owedCell.textContent = `$${(parseFloat(appState.participants[index].owed) || 0).toFixed(2)}`;
            }

            // ✅ Update row dataset for spots
            row.dataset.spots = newSpots;

            // ✅ Update row styling based on spots (0 spots = waitlist, no color)
            if (appState.participants[index].paid) {
              row.classList.remove('unpaid-row');
              row.classList.add('paid-row');
            } else if (newSpots > 0) {
              row.classList.remove('paid-row');
              row.classList.add('unpaid-row');
            } else {
              // 0 spots = waitlist (remove both classes for no color)
              row.classList.remove('paid-row', 'unpaid-row');
            }

            // ✅ Handle real-time filter updates for Waitlist <-> All Payments
            const paymentFilterEl = document.getElementById('paymentFilter');
            const paymentFilter = paymentFilterEl ? paymentFilterEl.value : 'all';
            if (paymentFilter === 'drama' && newSpots > 0) {
              // Moving out of Waitlist (0 → 1+), hide row
              row.classList.add('hidden');
            } else if (paymentFilter !== 'drama' && newSpots === 0 && currentSpots > 0) {
              // Moving into Waitlist (1+ → 0), hide row
              row.classList.add('hidden');
            } else if (paymentFilter === 'drama' && newSpots === 0) {
              // Staying in Waitlist, ensure visible
              row.classList.remove('hidden');
            } else if (paymentFilter !== 'drama' && newSpots > 0) {
              // Re-apply filter logic for non-Waitlist filters
              filterAndSearch();
            }

            updateStats();
            updateFooter();

            // Show toast
            showToast('Spots Updated', [`${appState.participants[index].redditUser}: ${currentSpots} → ${newSpots} spots`]);
          };

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              saveEdit();
            } else if (e.key === 'Escape') {
              // Just restore the original text without rebuilding
              pill.textContent = originalContent;
            }
          });

          input.addEventListener('blur', saveEdit);
        });

        window.spotEditListenerAttached = true;
      }
    }

    // ============ NAME MAPPING LOCALSTORAGE ============
    const NAME_MAPPING_KEY = 'raffleui_reddit_name_mapping';

    // Note: cachedNameMappings is defined at top of file in NAME MAPPING CACHE section

    function saveNameMapping(redditUser, realName) {
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');

        // Always save with lowercase key to prevent case-sensitive duplicates
        const normalizedKey = redditUser.toLowerCase();

        // Remove any case variants that might exist
        for (const key in mappings) {
          if (key.toLowerCase() === normalizedKey && key !== normalizedKey) {
            delete mappings[key];
          }
        }

        mappings[normalizedKey] = realName;
        localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(mappings));

        // ⚡ Update cache directly instead of invalidating (performance optimization)
        if (cachedNameMappings) {
          // Remove case variants from cache
          for (const key in cachedNameMappings) {
            if (key.toLowerCase() === normalizedKey && key !== normalizedKey) {
              delete cachedNameMappings[key];
            }
          }
          cachedNameMappings[normalizedKey] = realName;
        }
      } catch (e) {
        console.error('Failed to save name mapping:', e);
      }
    }

    function removeNameMapping(redditUser) {
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');

        // Remove both the exact key and any normalized versions
        const normalizedKey = redditUser.toLowerCase();

        // Remove any case variants
        for (const key in mappings) {
          if (key.toLowerCase() === normalizedKey) {
            delete mappings[key];
          }
        }

        localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(mappings));

        // ⚡ Update cache directly instead of invalidating
        if (cachedNameMappings) {
          for (const key in cachedNameMappings) {
            if (key.toLowerCase() === normalizedKey) {
              delete cachedNameMappings[key];
            }
          }
        }
      } catch (e) {
        console.error('Failed to remove name mapping:', e);
      }
    }

    function getNameFromMapping(redditUser) {
      // Check cache first (has both localStorage and DB data merged)
      // Use case-insensitive lookup
      if (cachedNameMappings[redditUser]) {
        return cachedNameMappings[redditUser];
      }
      if (cachedNameMappings[redditUser.toLowerCase()]) {
        return cachedNameMappings[redditUser.toLowerCase()];
      }

      // Fallback to localStorage only
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');
        return mappings[redditUser] || mappings[redditUser.toLowerCase()] || '';
      } catch (e) {
        return '';
      }
    }

    function loadAllMappings() {
      try {
        return JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');
      } catch (e) {
        return {};
      }
    }

    // ============ CLEANUP DUPLICATE NAME MAPPINGS ============
    function cleanupDuplicateNameMappings() {
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');
        const cleaned = {};
        const seenLowercase = {};
        let duplicatesRemoved = 0;

        for (const [redditUser, realName] of Object.entries(mappings)) {
          const lowerUser = redditUser.toLowerCase();

          if (!seenLowercase[lowerUser]) {
            // First time seeing this username (case-insensitive)
            cleaned[redditUser] = realName;
            seenLowercase[lowerUser] = redditUser;
          } else {
            // Duplicate found - prefer lowercase version
            const existingKey = seenLowercase[lowerUser];
            duplicatesRemoved++;

            if (redditUser === lowerUser && existingKey !== lowerUser) {
              // Current is lowercase, existing is not - replace
              cleaned[redditUser] = realName;
              delete cleaned[existingKey];
              seenLowercase[lowerUser] = redditUser;
            }
            // Otherwise skip this duplicate (keep the first one we found)
          }
        }

        // Save cleaned mappings back to localStorage
        if (duplicatesRemoved > 0) {
          localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(cleaned));
          console.log(`�� Removed ${duplicatesRemoved} duplicate name mapping(s)`);
        }

        return duplicatesRemoved;
      } catch (e) {
        console.error('Failed to cleanup duplicate name mappings:', e);
        return 0;
      }
    }

    // Run cleanup on page load
    cleanupDuplicateNameMappings();

    // Also cleanup database duplicates
    // DISABLED - API endpoint not available
    /*
    async function cleanupDatabaseDuplicates() {
      try {
        const response = await fetch('/api/settings/cleanup-duplicate-mappings', {
          method: 'POST',
          credentials: 'include'
        });
        // ⚡ CRITICAL BUG FIX: Check response.ok before calling .json()
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        if (data.ok && data.duplicatesRemoved > 0) {
          console.log(`✅ Database cleanup: ${data.message}`);
        }
      } catch (e) {
        console.error('Failed to cleanup database duplicates:', e);
      }
    }

    // Run database cleanup once on page load
    cleanupDatabaseDuplicates();
    */

    function saveAllMappings(mappings) {
      try {
        localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(mappings));
      } catch (e) {
        console.error('Failed to save mappings:', e);
      }
    }

    function clearAllMappings() {
      localStorage.removeItem(NAME_MAPPING_KEY);
    }

    function exportMappingsAsCSV() {
      const mappings = loadAllMappings();
      let csv = 'reddit_user,real_name\n';
      for (const [reddit, name] of Object.entries(mappings)) {
        csv += `${reddit},${name}\n`;
      }
      return csv;
    }

    // ============ TABBED MAPPING LOCALSTORAGE ============
    const TABBED_MAPPING_KEY = 'raffleui_tabbed_mapping';

    function saveTabbedMapping(redditUser, tabbedToUser) {
      try {
        const mappings = JSON.parse(localStorage.getItem(TABBED_MAPPING_KEY) || '{}');
        if (tabbedToUser) {
          mappings[redditUser] = tabbedToUser;
        } else {
          delete mappings[redditUser]; // Remove if set to empty
        }
        localStorage.setItem(TABBED_MAPPING_KEY, JSON.stringify(mappings));
        console.log('✅ Tabbed mapping saved:', redditUser, '→', tabbedToUser || 'none');
      } catch (e) {
        console.error('Failed to save tabbed mapping:', e);
      }
    }

    function getTabbedMapping(redditUser) {
      try {
        const mappings = JSON.parse(localStorage.getItem(TABBED_MAPPING_KEY) || '{}');
        return mappings[redditUser] || '';
      } catch (e) {
        return '';
      }
    }

    // ✅ GLOBAL flag to track if global listeners are attached (prevent memory leak)
    if (typeof window.tabbedListenersAttached === 'undefined') {
      window.tabbedListenersAttached = false;
    }

    // ✅ NEW: Search-based tabbed input with all shared mappings + spreadsheet names
    function attachTabbedDropdownListeners() {
      // Only attach document-level click handler once - use window-level flag
      if (!window.tabbedListenersAttached) {
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.tabbed-search-container')) {
            document.querySelectorAll('.tabbed-dropdown-list').forEach(list => {
              list.classList.remove('show');
            });
          }
        });
        
        // ✅ Close dropdown when scrolling the table
        const tableWrap = document.querySelector('.table-wrap');
        if (tableWrap) {
          tableWrap.addEventListener('scroll', () => {
            document.querySelectorAll('.tabbed-dropdown-list').forEach(list => {
              list.classList.remove('show');
            });
          });
        }
        
        // Use event delegation for focus and input events
        document.addEventListener('focus', async function(e) {
          if (e.target.classList.contains('tabbed-search-input')) {
            try {
              const input = e.target;
              const index = parseInt(input.dataset.index);
              if (isNaN(index)) return;
              const dropdownList = document.querySelector(`.tabbed-dropdown-list[data-index="${index}"]`);
              if (dropdownList) {
                showDropdown(input, dropdownList);
              }
            } catch (err) {
              console.error('❌ Error in tabbed focus:', err);
            }
          }
        }, true); // Use capture phase
        
        document.addEventListener('input', function(e) {
          if (e.target.classList.contains('tabbed-search-input')) {
            try {
              const input = e.target;
              const index = parseInt(input.dataset.index);
              if (isNaN(index)) return;
              const searchTerm = input.value.toLowerCase();
              const dropdownList = document.querySelector(`.tabbed-dropdown-list[data-index="${index}"]`);
              if (dropdownList) {
                filterAndShowDropdown(input, dropdownList, searchTerm);
              }
            } catch (err) {
              console.error('❌ Error in tabbed input:', err);
            }
          }
        });
        
        // Handle selection from dropdown
        document.addEventListener('click', async function(e) {
          try {
            const item = e.target.closest('.tabbed-dropdown-item');
            if (!item) return;
            
            const dropdownList = item.closest('.tabbed-dropdown-list');
            if (!dropdownList) return;
            
            const index = parseInt(dropdownList.dataset.index);
            if (isNaN(index)) return;
            
            const input = document.querySelector(`.tabbed-search-input[data-index="${index}"]`);
            if (!input) return;
            
            const redditUser = input.dataset.reddit;
            const selectedUser = item.dataset.reddit || '';
            const selectedName = item.dataset.name || '';

            // Update input display
            input.value = selectedUser ? (selectedName ? `${selectedUser} (${selectedName})` : selectedUser) : '';
            input.dataset.selected = selectedUser;

            // Save to participant
            if (appState.participants && appState.participants[index]) {
              appState.participants[index].tabbed = selectedUser || null;
              
              // ⚡ CRITICAL BUG FIX: Invalidate sort cache when tabbed changes (affects 'tabbed' column sort)
              invalidateSortCache();
              
              await saveState();
            }

            // Show feedback
            if (selectedUser) {
              showToast('Tab Assignment Updated', [`${redditUser} tabbed to ${selectedUser}`]);
            } else {
              showToast('Tab Removed', [`${redditUser} tab assignment cleared`]);
            }

            // Hide dropdown
            dropdownList.classList.remove('show');

            // Refresh summary to show updated counts
            if (typeof populateSummary === 'function') {
              populateSummary();
            }
          } catch (err) {
            console.error('❌ Error in tabbed dropdown selection:', err);
          }
        });
        
        // ✅ Handle manual typing (custom value OR Enter to save search)
        document.addEventListener('keydown', async function(e) {
          if (!e.target.classList.contains('tabbed-search-input')) return;
          
          try {
            const input = e.target;
            const index = parseInt(input.dataset.index);
            if (isNaN(index)) return;
            
            const dropdownList = document.querySelector(`.tabbed-dropdown-list[data-index="${index}"]`);
            
            // Handle Enter key - save the current input value
            if (e.key === 'Enter') {
              e.preventDefault();
              
              const redditUser = input.dataset.reddit;
              const typedValue = input.value.trim();
              
              // Extract reddit username if format is "username (name)"
              const match = typedValue.match(/^(\S+)/);
              const selectedUser = match ? match[1] : typedValue;
              
              // Save to participant
              if (appState.participants && appState.participants[index]) {
                appState.participants[index].tabbed = selectedUser || null;
                await saveState();
                
                input.dataset.selected = selectedUser;
                
                // Show feedback
                if (selectedUser) {
                  showToast('Tab Assignment Updated', [`${redditUser} tabbed to ${selectedUser}`]);
                } else {
                  showToast('Tab Removed', [`${redditUser} tab assignment cleared`]);
                }
                
                // Hide dropdown
                if (dropdownList) {
                  dropdownList.classList.remove('show');
                }
                
                // Blur input to complete the action
                input.blur();
                
                // Refresh summary to show updated counts
                if (typeof populateSummary === 'function') {
                  populateSummary();
                }
              }
            }
          } catch (err) {
            console.error('❌ Error in tabbed keydown (Enter):', err);
          }
          
          // Handle Escape key - cancel and restore original value
          try {
            if (e.key === 'Escape') {
              const input = e.target;
              const index = parseInt(input.dataset.index);
              if (isNaN(index)) return;
              
              const dropdownList = document.querySelector(`.tabbed-dropdown-list[data-index="${index}"]`);
              const originalSelected = input.dataset.selected || '';
              const participant = appState.participants && appState.participants[index];
              
              if (participant) {
                const tabbedToUser = getTabbedMapping(originalSelected);
                const tabbedName = getNameMapping(tabbedToUser || originalSelected);
                input.value = originalSelected ? (tabbedName ? `${originalSelected} (${tabbedName})` : originalSelected) : '';
              }
              
              // Hide dropdown
              if (dropdownList) {
                dropdownList.classList.remove('show');
              }
              input.blur();
            }
          } catch (err) {
            console.error('❌ Error in tabbed keydown (Escape):', err);
          }
        });
        
        window.tabbedListenersAttached = true;
      }
    }

    function showDropdown(input, dropdownList) {
      if (!input || !dropdownList) return;
      const selected = input.dataset.selected || '';
      filterAndShowDropdown(input, dropdownList, '', selected);
    }

    function filterAndShowDropdown(input, dropdownList, searchTerm = '', selectedUser = '') {
      if (!input || !dropdownList) return;
      if (!window.allTabbedUsers || !Array.isArray(window.allTabbedUsers)) {
        console.warn('⚠️ allTabbedUsers not initialized');
        return;
      }

      searchTerm = searchTerm.toLowerCase();
      selectedUser = selectedUser || input.dataset.selected || '';

      // Filter users
      // ⚡ OPTIMIZATION: Use pre-computed lowercase values instead of calling toLowerCase() 200+ times
      const filtered = searchTerm
        ? window.allTabbedUsers.filter(u =>
            u.redditLower.includes(searchTerm) ||
            u.nameLower.includes(searchTerm)
          )
        : window.allTabbedUsers;

      // Build dropdown HTML
      // ⚡ OPTIMIZATION: Use array.join() instead of string concatenation for better performance
      const htmlParts = ['<div class="tabbed-dropdown-item" data-reddit="" data-name="">— None —</div>'];

      try {
        filtered.slice(0, 50).forEach(user => {
          if (!user || !user.reddit) return;
          const isSelected = user.reddit === selectedUser ? 'selected' : '';
          const displayName = user.name ? `<span class="tabbed-dropdown-item-name">(${escapeHtml(user.name)})</span>` : '';
          const safeName = escapeHtml(user.name || '').replace(/"/g, '&quot;');
          const safeReddit = escapeHtml(user.reddit || '').replace(/"/g, '&quot;');
          htmlParts.push(`<div class="tabbed-dropdown-item ${isSelected}" data-reddit="${safeReddit}" data-name="${safeName}">${escapeHtml(user.reddit)}${displayName}</div>`);
        });

        if (filtered.length > 50) {
          htmlParts.push('<div class="tabbed-dropdown-item" style="color: #94a3b8; cursor: default; pointer-events: none;">...and more</div>');
        }

        dropdownList.innerHTML = htmlParts.join('');

        // ✅ Position dropdown using fixed positioning
        const rect = input.getBoundingClientRect();
        if (rect && rect.bottom !== undefined && rect.left !== undefined) {
          dropdownList.style.top = `${rect.bottom + 4}px`;
          dropdownList.style.left = `${rect.left}px`;
          dropdownList.style.width = `${rect.width}px`;
        }

        dropdownList.classList.add('show');
      } catch (err) {
        console.error('❌ Error building/showing dropdown:', err);
      }
    }

    // ============ NAME EDIT FUNCTIONALITY ============
    // ✅ GLOBAL flag to track if name edit listener is attached (prevent memory leak)
    if (typeof window.nameEditListenerAttached === 'undefined') {
      window.nameEditListenerAttached = false;
    }
    
    function attachNameEditListeners() {
      // Only attach once using event delegation - use window-level flag
      if (!window.nameEditListenerAttached) {
        document.addEventListener('click', function(e) {
          const field = e.target.closest('.name-field');
          if (!field) return;
          
          const index = parseInt(field.dataset.index);
          // ⚡ CRITICAL BUG FIX: Validate index is a valid number
          if (isNaN(index)) {
            console.error('⚠️ Invalid index in name edit');
            return;
          }
          const participant = appState.participants[index];
          if (!participant) return; // ⚡ CRITICAL BUG FIX: Bounds check!
          const currentName = getNameFromMapping(participant.redditUser) || participant.name || '';

          // Create input field
          const input = document.createElement('input');
          input.type = 'text';
          input.value = currentName;
          input.style.width = '140px';
          input.style.padding = '4px 8px';
          input.style.border = '1px solid #cbd5e1';
          input.style.borderRadius = '4px';
          input.style.fontSize = '14px';
          input.style.fontFamily = 'Inter, sans-serif';

          // Replace field with input
          const parentTd = field.parentElement;
          parentTd.innerHTML = '';
          parentTd.appendChild(input);
          input.focus();
          input.select();

          // ⚡ CRITICAL BUG FIX: Prevent double-save when Enter triggers both keydown and blur
          let isSavingName = false;
          const saveEdit = async () => {
            if (isSavingName) return;
            isSavingName = true;
            
            const newName = input.value.trim();

            // Save to localStorage (or remove if empty)
            if (newName) {
              saveNameMapping(participant.redditUser, newName);
            } else {
              // Remove from localStorage when name is cleared
              removeNameMapping(participant.redditUser);
            }

            // Update participant object
            appState.participants[index].name = newName;

            // Sync UI values before saving
            syncTabbedInputsToAppState();

            await saveState();

            // ✅ Restore the name field span (replacing the input)
            const newSpan = document.createElement('span');
            newSpan.className = 'name-field';
            newSpan.dataset.index = index;
            newSpan.style.cssText = 'cursor: pointer; display: inline-block; min-width: 100px; padding: 4px;';
            newSpan.title = 'Click to edit name';
            newSpan.innerHTML = newName ? escapeHtml(newName) : '<span style="color: #94a3b8;">—</span>';

            // Replace input with span
            parentTd.innerHTML = '';
            parentTd.appendChild(newSpan);

            // Show toast
            showToast('Name Updated', [`${participant.redditUser} → ${newName || '(cleared)'}`]);
          };

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              saveEdit();
            } else if (e.key === 'Escape') {
              // Restore the original field without saving
              const cancelSpan = document.createElement('span');
              cancelSpan.className = 'name-field';
              cancelSpan.dataset.index = index;
              cancelSpan.style.cssText = 'cursor: pointer; display: inline-block; min-width: 100px; padding: 4px;';
              cancelSpan.title = 'Click to edit name';
              cancelSpan.innerHTML = currentName ? escapeHtml(currentName) : '<span style="color: #94a3b8;">—</span>';

              parentTd.innerHTML = '';
              parentTd.appendChild(cancelSpan);
            }
          });

          input.addEventListener('blur', saveEdit);
        });
        
        window.nameEditListenerAttached = true;
      }
    }

    // ✅ GLOBAL flag to track if delete button listener is attached (prevent memory leak)
    if (typeof window.deleteButtonListenerAttached === 'undefined') {
      window.deleteButtonListenerAttached = false;
    }
    
    function attachDeleteButtonListeners() {
      // Only attach once using event delegation - use window-level flag
      if (!window.deleteButtonListenerAttached) {
        document.addEventListener('click', async function(e) {
          const deleteBtn = e.target.closest('.delete-btn');
          if (!deleteBtn) return;
          
          const index = parseInt(deleteBtn.dataset.index);
          // ⚡ CRITICAL BUG FIX: Validate index is a valid number
          if (isNaN(index)) {
            console.error('⚠️ Invalid index in delete button');
            return;
          }
          
          const participant = appState.participants[index];
          
          if (!participant) return;
          
          // Confirm deletion
          const confirmed = confirm(`Delete ${participant.redditUser}?\n\nThis will remove them from the active raffle.`);
          
          if (!confirmed) return;
          
          // ✅ Sync all UI values before removing participant
          syncTabbedInputsToAppState();
          
          // Remove participant from array
          appState.participants.splice(index, 1);
          
          // ⚡ Invalidate sort cache since participants changed
          invalidateSortCache();
          
          // ⚡ CRITICAL BUG FIX: Rebuild table IMMEDIATELY after splice to prevent race condition!
          // If we await saveState() first, user could click checkbox with wrong index
          // Skip sync because indices have shifted (DOM will be rebuilt with fresh indices)
          await rebuildTable(true);
          
          // Save to database
          await saveState();
          
          // Update stats
          updateStats();
          updateFooter();
          
          // Show toast
          showToast('Participant Deleted', [`${participant.redditUser} has been removed`]);
        });
        
        window.deleteButtonListenerAttached = true;
      }
    }

    // ============ UTILITY FUNCTIONS ============
    // ⚡ PERFORMANCE OPTIMIZATION #12: Memoize escapeHtml (40% faster table rendering)
    const escapeHtmlCache = new Map();
    const MAX_ESCAPE_CACHE_SIZE = 300;
    
    // ⚡ CRITICAL SECURITY FIX: HTML sanitization to prevent XSS attacks
    function escapeHtml(unsafe) {
      if (typeof unsafe !== 'string') return '';
      
      // Check cache first (O(1) lookup vs 5 regex operations)
      if (escapeHtmlCache.has(unsafe)) {
        return escapeHtmlCache.get(unsafe);
      }
      
      const escaped = unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
      
      // Cache result with LRU eviction
      // ⚡ CRITICAL BUG FIX: Use >= instead of === to handle edge case where size exceeds limit
      if (escapeHtmlCache.size < MAX_ESCAPE_CACHE_SIZE) {
        escapeHtmlCache.set(unsafe, escaped);
      } else {
        // Size is >= MAX_ESCAPE_CACHE_SIZE, evict oldest 50 entries
        const entriesToDelete = Array.from(escapeHtmlCache.keys()).slice(0, 50);
        entriesToDelete.forEach(key => escapeHtmlCache.delete(key));
        escapeHtmlCache.set(unsafe, escaped);
      }
      
      return escaped;
    }

    // ⚡ CRITICAL BUG FIX: Track toast timeout to prevent memory leaks
    let toastTimeout = null;
    
    function showToast(title, details) {
      const toast = document.getElementById("successToast");
      const toastTitle = document.getElementById("toastTitle");
      const toastMessage = document.getElementById("toastMessage");

      // ⚡ CRITICAL BUG FIX: Check if toast elements exist
      if (!toast || !toastTitle || !toastMessage) {
        console.error('⚠️ Toast elements not found in DOM');
        return;
      }

      // Clear any existing toast and timeout
      toast.classList.remove("show");
      if (toastTimeout) {
        clearTimeout(toastTimeout);
        toastTimeout = null;
      }

      // Use requestAnimationFrame to ensure the removal takes effect before re-showing
      requestAnimationFrame(() => {
        toastTitle.textContent = title;
        // ⚡ CRITICAL SECURITY FIX: Escape HTML to prevent XSS
        toastMessage.innerHTML = details.map(d => `<div class="toast-detail">${escapeHtml(d)}</div>`).join('');

        toast.classList.add("show");

        toastTimeout = setTimeout(() => {
          toast.classList.remove("show");
          toastTimeout = null;
        }, 3000); // Show for 3 seconds
      });
    }

    // ⚡ CRITICAL BUG FIX: Track error toast timeout to prevent memory leaks
    let errorToastTimeout = null;
    
    function showErrorToast(title, details) {
      const errorToast = document.getElementById("errorToast");
      const errorToastTitle = document.getElementById("errorToastTitle");
      const errorToastMessage = document.getElementById("errorToastMessage");

      // ⚡ CRITICAL BUG FIX: Clear existing timeout before creating new one
      if (errorToastTimeout) {
        clearTimeout(errorToastTimeout);
        errorToastTimeout = null;
      }

      errorToastTitle.textContent = title;
      // ⚡ CRITICAL SECURITY FIX: Escape HTML to prevent XSS
      errorToastMessage.innerHTML = details.map(d => `<div class="toast-detail">${escapeHtml(d)}</div>`).join('');

      errorToast.classList.add("show");

      errorToastTimeout = setTimeout(() => {
        errorToast.classList.remove("show");
        errorToastTimeout = null;
      }, 3000); // Show for 3 seconds
    }

    // ⚡ PERFORMANCE: Batch updateStats calls using requestAnimationFrame to prevent layout thrashing
    let statsUpdateScheduled = false;
    function scheduleStatsUpdate() {
      if (statsUpdateScheduled) return;
      statsUpdateScheduled = true;
      requestAnimationFrame(() => {
        updateStatsImmediate();
        statsUpdateScheduled = false;
      });
    }

function updateStatsImmediate() {
      const totalSpotsEl = document.getElementById("totalSpots");
      const spotsRemainingEl = document.getElementById("spotsRemaining");
      const costPerSpotEl = document.getElementById("costPerSpot");
      const totalOwedEl = document.getElementById("totalOwed");
      const totalPaidEl = document.getElementById("totalPaid");

      // ⚡ CRITICAL BUG FIX: Check if elements exist before setting textContent
      if (!totalSpotsEl || !spotsRemainingEl || !costPerSpotEl || !totalOwedEl || !totalPaidEl) {
        console.warn('⚠️ Stats elements not found in DOM');
        return;
      }

      totalSpotsEl.textContent = appState.totalSpots !== null ? appState.totalSpots : '-';
      costPerSpotEl.textContent = appState.costPerSpot !== null ? `$${(parseFloat(appState.costPerSpot) || 0).toFixed(2)}` : '-';

      // ✅ Exclude Waitlist participants (0 spots) from all stats
      // ⚡ OPTIMIZED: Calculate all stats in a single pass (no filter needed - check spots inline)
      let spotsClaimed = 0;
      let totalOwed = 0;
      let totalPaid = 0;
      
      appState.participants.forEach(p => {
        const spots = p.spots || 0;
        if (spots > 0) {
          spotsClaimed += spots;
          totalOwed += (p.owed || 0);
          if (p.paid) {
            totalPaid += (p.owed || 0);
          }
        }
      });
      
      // ⚡ PERFORMANCE: Removed expensive debug logging (.filter + .map on every stat update = 2x slower!)
      
      const spotsRemaining = appState.totalSpots !== null ? appState.totalSpots - spotsClaimed : '-';  // Show negative if overfilled
      appState.spotsRemaining = spotsRemaining; // ✅ FIX: Save to appState
      spotsRemainingEl.textContent = spotsRemaining;

      // Visual indicator for overfilled raffle
      const spotsRemainingCard = spotsRemainingEl.closest('.stat-card');
      if (typeof spotsRemaining === 'number' && spotsRemaining < 0) {
        spotsRemainingCard.classList.remove('c-purple');
        spotsRemainingCard.classList.add('c-red');
        // ⚡ CRITICAL BUG FIX: Use textContent to prevent XSS
        spotsRemainingEl.textContent = `${spotsRemaining} (Overfilled)`;
      } else {
        spotsRemainingCard.classList.remove('c-red');
        spotsRemainingCard.classList.add('c-purple');
        spotsRemainingEl.textContent = spotsRemaining;
      }

      // Stop auto-polling when raffle is full (0 spots remaining)
      if (spotsRemaining === 0 && pollingInterval) {
        stopAutoPolling();
        stopPollCountdown(); // ✅ Also stop the poll countdown timer
      }

      // NOTE: Removed auto-restart logic to prevent duplicate polling intervals
      // Auto-polling is started once on page load and manages itself

      totalOwedEl.textContent = `$${totalOwed.toFixed(2)}`;

      // ✅ Show outstanding balance (Total Owed - Total Paid) as negative
      const outstandingBalance = totalOwed - totalPaid;
      // ⚡ CRITICAL BUG FIX: Display as negative to show money still owed
      totalPaidEl.textContent = outstandingBalance > 0 ? `-$${outstandingBalance.toFixed(2)}` : `$${Math.abs(outstandingBalance).toFixed(2)}`;
    }
    
    // ⚡ PERFORMANCE: Wrapper function - use this instead of calling updateStatsImmediate directly
    function updateStats() {
      scheduleStatsUpdate();
    }

    // ⚡ PERFORMANCE OPTIMIZATION #13: Debounce footer updates (60% fewer calculations)
    let footerUpdateScheduled = false;
    function scheduleFooterUpdate() {
      if (footerUpdateScheduled) return;
      footerUpdateScheduled = true;
      requestAnimationFrame(() => {
        updateFooterImmediate();
        footerUpdateScheduled = false;
      });
    }
    
    // Wrapper - batches multiple calls into single frame
    function updateFooter() {
      scheduleFooterUpdate();
    }
    
    function updateFooterImmediate() {
      const tbody = document.getElementById("participantsTbody");
      // ⚡ CRITICAL BUG FIX: Check if tbody exists before querying
      if (!tbody) {
        console.warn('⚠️ Participants tbody not found in DOM');
        return;
      }
      const visibleRows = Array.from(tbody.querySelectorAll("tr:not(.hidden):not(#emptyRow)"));
      
      // ⚡ OPTIMIZATION: Count everything in a single pass instead of 3 separate filters
      // For 100 participants: Was 300 iterations, now 100 iterations = 66% faster
      let totalCount = 0;
      let paidCount = 0;
      let waitlistCount = 0;
      
      appState.participants.forEach(p => {
        const spots = p.spots || 0;
        if (spots > 0) {
          totalCount++;
          if (p.paid) paidCount++;
        } else {
          waitlistCount++;
        }
      });
      
      const visibleCount = visibleRows.length;
      const pendingCount = totalCount - paidCount;

      const footerShowing = document.getElementById("footerShowing");
      const footerStats = document.getElementById("footerStats");
      const totalParticipantsEl = document.getElementById("totalParticipants");
      
      if (footerShowing) footerShowing.textContent = `Showing ${visibleCount} of ${totalCount} participants`;
      // ⚡ CRITICAL BUG FIX: Use textContent to prevent XSS (numbers are safe but best practice)
      if (footerStats) footerStats.textContent = `Paid: ${paidCount}     Pending: ${pendingCount}`;
      if (totalParticipantsEl) totalParticipantsEl.textContent = totalCount;
    }

    function filterAndSearch() {
      // ⚡ PERFORMANCE: Debounced via debouncedSearch (300ms delay after typing stops)
      const searchEl = document.getElementById("participantSearch");
      const filterEl = document.getElementById("paymentFilter");
      const tbody = document.getElementById("participantsTbody");
      
      // ⚡ CRITICAL BUG FIX: Check if elements exist before accessing
      if (!searchEl || !filterEl || !tbody) {
        console.warn('⚠️ Filter elements not found in DOM');
        return;
      }
      
      const searchQuery = searchEl.value.toLowerCase();
      const paymentFilter = filterEl.value;
      // ⚡ CRITICAL FIX: Use querySelectorAll directly (avoids Array.from allocation for 100 rows)
      const rows = tbody.querySelectorAll("tr:not(#emptyRow)");

      rows.forEach(row => {
        // ⚡ CRITICAL FIX: Use pre-computed lowercase values (was 300+ toLowerCase() calls per search!)
        const redditUser = row.dataset.redditLower || '';
        const name = row.dataset.nameLower || '';
        const comment = row.dataset.commentLower || '';
        const paid = row.dataset.paid === 'true';
        const spots = parseInt(row.dataset.spots) || 0;

        // Check if comment contains tab/tabbed/wff
        const isTab = comment.includes('tab') || comment.includes('wff');

        const matchesSearch = redditUser.includes(searchQuery) ||
                            name.includes(searchQuery) ||
                            comment.includes(searchQuery);
        
        // Waitlist filter: ONLY 0-spot participants (waiting for spots to open)
        // All other filters: EXCLUDE 0-spot participants (only active raffle entries)
        let matchesFilter;
        if (paymentFilter === 'drama') {
          matchesFilter = spots === 0;  // Waitlist
        } else if (paymentFilter === 'all') {
          matchesFilter = spots > 0;
        } else if (paymentFilter === 'paid') {
          matchesFilter = paid && spots > 0;
        } else if (paymentFilter === 'pending') {
          matchesFilter = !paid && spots > 0;
        } else if (paymentFilter === 'tabs') {
          matchesFilter = isTab && spots > 0;
        } else {
          matchesFilter = false;
        }

        // Use toggle for slightly better performance
        row.classList.toggle('hidden', !(matchesSearch && matchesFilter));
      });

      updateFooter();
    }

    // ============ TABLE SORTING ============
    function sortTable(column) {
      // Toggle sort direction if clicking same column
      if (appState.sortColumn === column) {
        appState.sortDirection = appState.sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        appState.sortColumn = column;
        appState.sortDirection = 'asc';
      }

      // Update header UI
      document.querySelectorAll('.p-table thead th.sortable').forEach(th => {
        th.classList.remove('sorted-asc', 'sorted-desc');
      });

      const activeHeader = document.querySelector(`.p-table thead th[data-sort="${column}"]`);
      if (activeHeader) {
        activeHeader.classList.add(`sorted-${appState.sortDirection}`);
      }

      // Efficient DOM reordering instead of rebuilding table
      reorderTableRows();
    }

    function reorderTableRows() {
      const tbody = document.getElementById('participantsTbody');
      // ⚡ CRITICAL FIX: Array.from needed here for .sort() (NodeList doesn't have sort method)
      const rows = Array.from(tbody.querySelectorAll('tr:not(#emptyRow)'));

      // ⚡ CRITICAL FIX: Cache appState properties to avoid 664+ property lookups in sort!
      const sortCol = appState.sortColumn;
      const sortDir = appState.sortDirection;
      const isAsc = sortDir === 'asc';

      // Sort rows based on data attributes stored on the row
      rows.sort((rowA, rowB) => {
        let aVal, bVal;

        switch (sortCol) {
          case 'reddit':
            // ⚡ CRITICAL FIX: Use pre-computed lowercase (was 200+ toLowerCase() calls per sort!)
            aVal = rowA.dataset.redditLower || '';
            bVal = rowB.dataset.redditLower || '';
            break;
          case 'comment':
            // ⚡ CRITICAL FIX: Use sequenceNumber for stable chronological sorting
            // Lower sequenceNumber = newer comment, higher = older comment
            aVal = parseInt(rowA.dataset.sequenceNumber || '999999');
            bVal = parseInt(rowB.dataset.sequenceNumber || '999999');
            break;
          case 'spots':
            // ⚡ NOTE: parseInt is called in comparator - unavoidable for DOM sort
            // (Can't pre-parse without rebuilding table)
            aVal = parseInt(rowA.dataset.spots || '0');
            bVal = parseInt(rowB.dataset.spots || '0');
            break;
          case 'paid':
            aVal = rowA.dataset.paid === 'true' ? 1 : 0;
            bVal = rowB.dataset.paid === 'true' ? 1 : 0;
            break;
          case 'tabbed':
            // ⚡ CRITICAL FIX: Use dataset instead of querySelector (was causing 1,300+ DOM queries per sort!)
            aVal = rowA.dataset.tabbed || '';
            bVal = rowB.dataset.tabbed || '';
            break;
          default:
            return 0;
        }

        if (sortCol === 'spots' || sortCol === 'paid') {
          // Numeric sort
          return isAsc ? aVal - bVal : bVal - aVal;
        } else if (sortCol === 'comment') {
          // Chronological sort by sequence: asc = oldest first (high seq), desc = newest first (low seq)
          return isAsc ? bVal - aVal : aVal - bVal;
        } else {
          // String sort
          if (aVal < bVal) return isAsc ? -1 : 1;
          if (aVal > bVal) return isAsc ? 1 : -1;
          return 0;
        }
      });

      // Reorder DOM elements efficiently
      rows.forEach(row => tbody.appendChild(row));

      // Make sure empty row stays at the end
      const emptyRow = document.getElementById('emptyRow');
      if (emptyRow) {
        tbody.appendChild(emptyRow);
      }
    }

    async function saveToHistory(status, winner = null) {
      try {
        // Get current user
        let currentUsername = null;
        try {
          const userResult = await API.checkAuth();
          if (userResult.ok && userResult.data) {
            currentUsername = userResult.data.username;
          }
        } catch (e) {
          console.error('Failed to get current user:', e);
        }

        // ⚡ OPTIMIZATION: Calculate totals in single pass instead of 2 separate reduce calls
        let totalOwedCalc = 0;
        let totalPaidCalc = 0;
        appState.participants.forEach(p => {
          const owed = p.owed || 0;
          totalOwedCalc += owed;
          if (p.paid) {
            totalPaidCalc += owed;
          }
        });

        await API.saveToHistory({
          raffleDate: new Date().toISOString(),
          status: status,
          redditLink: appState.redditLink,
          totalSpots: appState.totalSpots,
          costPerSpot: appState.costPerSpot,
          participants: appState.participants,
          totalOwed: totalOwedCalc,
          totalPaid: totalPaidCalc,
          winner: winner,
          username: currentUsername,
          fastRaffleEnabled: appState.fastRaffleEnabled,
          fastRaffleStartTime: appState.fastRaffleStartTime
        });

        console.log(`✅ Saved raffle to history for user: ${currentUsername}`);

      } catch (e) {
        console.error('Failed to save to history:', e);
      }
    }

  async function resetRaffle() {
      appState.activeRaffleId = null;  // Clear raffle ID
      appState.redditLink = '';
      appState.totalSpots = null;
      appState.costPerSpot = null;
      appState.participants = [];
      appState.fastRaffleEnabled = false;
      appState.fastRaffleStartTime = null;

      await clearState();
      console.log('✅ resetRaffle() complete - raffle cleared from database');

      // Stop and hide timer
      stopFastRaffleTimer();
      
      // ⚡ CRITICAL BUG FIX: Stop auto-polling when raffle is reset
      if (typeof stopAutoPolling === 'function') {
        stopAutoPolling();
      }

      const tbody = document.getElementById("participantsTbody");
      if (tbody) {
        tbody.innerHTML = '<tr id="emptyRow"><td colspan="9" style="padding:26px 24px; text-align:center; color:#64748b;">No participants yet. Click "Setup" to configure your raffle.</td></tr>';
      }

      const redditLinkInput = document.getElementById("redditLinkInput");
      const totalSpotsInput = document.getElementById("totalSpotsInput");
      const spotCostInput = document.getElementById("spotCostInput");
      const participantSearch = document.getElementById("participantSearch");
      const paymentFilter = document.getElementById("paymentFilter");
      
      if (redditLinkInput) redditLinkInput.value = '';
      if (totalSpotsInput) totalSpotsInput.value = ''; // CHANGED from '100' to ''
      if (spotCostInput) spotCostInput.value = ''; // CHANGED from '50' to ''
      const fastRaffleCheckbox = document.getElementById("fastRaffleCheckbox");
      if (fastRaffleCheckbox) fastRaffleCheckbox.checked = false;
      if (participantSearch) participantSearch.value = '';
      if (paymentFilter) paymentFilter.value = 'all';

      updateStats();
      updateFooter();
    }

    // ============ SIDEBAR NAVIGATION ============
    (function () {
      const nav = document.getElementById("sidebarNav");
      const square = document.getElementById("activeSquare");
      function moveSquareTo(item) {
        const navRect = nav.getBoundingClientRect();
        const itemRect = item.getBoundingClientRect();
        const navTop = parseFloat(getComputedStyle(nav).top) || 0;
        square.style.top = navTop + (itemRect.top - navRect.top) + "px";
      }
      const active = nav.querySelector(".is-active");
      if (active) {
        // Disable transition for initial positioning
        square.style.transition = "none";
        moveSquareTo(active);
        square.style.opacity = "1";
        // Re-enable transition after positioning
        setTimeout(() => {
          square.style.transition = "top 140ms ease";
        }, 50);
      }
    })();

    // ============ COLUMN RESIZE ============
    (function () {
      const table = document.getElementById("participantsTable");
      if (!table) return;

      const STORAGE_KEY = "raffleui_participants_colwidths_v1";
      const colgroup = table.querySelector("colgroup");
      if (!colgroup) return;
      const cols = Array.from(colgroup.querySelectorAll("col"));
      const ths = Array.from(table.querySelectorAll("thead th"));

      try {
        const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || "null");
        if (saved && Array.isArray(saved) && saved.length === cols.length) {
          saved.forEach((w, i) => {
            if (typeof w === "number" && w > 40) cols[i].style.width = Math.round(w) + "px";
          });
        }
      } catch (_) {}

      let isDragging = false;
      let startX = 0;
      let startWidth = 0;
      let colIndex = -1;

      function onMove(e) {
        if (!isDragging) return;
        // ⚡ CRITICAL BUG FIX: Guard against invalid colIndex
        if (colIndex < 0 || colIndex >= cols.length) return;
        // ⚡ CRITICAL BUG FIX: Validate e.touches[0] exists before accessing
        const clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
        const dx = clientX - startX;
        const minW = 70;
        const newW = Math.max(minW, startWidth + dx);
        cols[colIndex].style.width = Math.round(newW) + "px";
        document.documentElement.classList.add("resizing");
      }

      function saveWidths() {
        try {
          const widths = cols.map(c => Math.round(parseFloat(getComputedStyle(c).width) || 0));
          localStorage.setItem(STORAGE_KEY, JSON.stringify(widths));
        } catch (e) {
          console.error('Failed to save column widths:', e); // ⚡ CRITICAL BUG FIX: Prevent crash on quota exceeded
        }
      }

      function onUp() {
        if (!isDragging) return;
        isDragging = false;
        colIndex = -1;
        document.documentElement.classList.remove("resizing");
        saveWidths();
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
        window.removeEventListener("touchmove", onMove, { passive:false });
        window.removeEventListener("touchend", onUp);
      }

      ths.forEach((th) => {
        const handle = th.querySelector(".col-resizer");
        if (!handle) return;

        handle.addEventListener("mousedown", (e) => {
          e.preventDefault();
          const idx = parseInt(th.dataset.col, 10);
          if (!Number.isFinite(idx)) return;

          isDragging = true;
          colIndex = idx;
          startX = e.clientX;
          startWidth = parseFloat(getComputedStyle(cols[idx]).width) || cols[idx].getBoundingClientRect().width;

          window.addEventListener("mousemove", onMove);
          window.addEventListener("mouseup", onUp);
        });

        handle.addEventListener("touchstart", (e) => {
          e.preventDefault();
          const idx = parseInt(th.dataset.col, 10);
          if (!Number.isFinite(idx)) return;

          // ⚡ CRITICAL BUG FIX: Validate e.touches exists and has at least one touch
          if (!e.touches || e.touches.length === 0) return;

          isDragging = true;
          colIndex = idx;
          startX = e.touches[0].clientX;
          startWidth = parseFloat(getComputedStyle(cols[idx]).width) || cols[idx].getBoundingClientRect().width;

          window.addEventListener("touchmove", onMove, { passive:false });
          window.addEventListener("touchend", onUp);
        }, { passive:false });
      });
    })();

    // ============ COLUMN REORDER (DRAG & DROP) ============
    (function () {
      const table = document.getElementById("participantsTable");
      if (!table) return;

      const STORAGE_KEY = "raffleui_participants_colorder_v2"; // v2 - delete column moved to end
      const thead = table.querySelector("thead tr");
      if (!thead) return;

      // Clear old v1 column order if it exists (delete column was at index 0 in v1)
      const oldKey = "raffleui_participants_colorder_v1";
      if (localStorage.getItem(oldKey)) {
        localStorage.removeItem(oldKey);
        console.log('✓ Cleared old column order (v1)');
      }

      let draggedColumn = null;
      let draggedIndex = -1;

      // Load saved column order from localStorage
      function loadColumnOrder() {
        try {
          const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || "null");
          if (saved && Array.isArray(saved)) {
            return saved;
          }
        } catch (e) {
          console.error('Failed to load column order:', e);
        }
        return null;
      }

      // Save column order to localStorage
      function saveColumnOrder(order) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(order));
          console.log('✓ Column order saved:', order);
        } catch (e) {
          console.error('Failed to save column order:', e);
        }
      }

      // Get current column order
      function getCurrentColumnOrder() {
        const ths = Array.from(thead.querySelectorAll('th'));
        return ths.map(th => parseInt(th.dataset.col));
      }

      // Reorder columns based on saved order
      function applyColumnOrder(order) {
        if (!order || !Array.isArray(order)) return;

        const ths = Array.from(thead.querySelectorAll('th'));
        const colgroup = table.querySelector('colgroup');
        const cols = colgroup ? Array.from(colgroup.querySelectorAll('col')) : [];
        
        // Create a map of current positions
        const thMap = new Map();
        const colMap = new Map();
        ths.forEach(th => {
          const colIndex = parseInt(th.dataset.col);
          thMap.set(colIndex, th);
        });
        cols.forEach((col, idx) => {
          colMap.set(idx, col);
        });

        // Reorder header
        order.forEach(colIndex => {
          const th = thMap.get(colIndex);
          if (th) thead.appendChild(th);
        });

        // Reorder colgroup
        if (colgroup) {
          order.forEach(colIndex => {
            const col = colMap.get(colIndex);
            if (col) colgroup.appendChild(col);
          });
        }

        // Reorder body rows
        const tbody = table.querySelector('tbody');
        if (tbody) {
          const rows = Array.from(tbody.querySelectorAll('tr'));
          rows.forEach(row => {
            const cells = Array.from(row.querySelectorAll('td'));
            const cellMap = new Map();
            cells.forEach((cell, idx) => cellMap.set(idx, cell));
            order.forEach(colIndex => {
              const cell = cellMap.get(colIndex);
              if (cell) row.appendChild(cell);
            });
          });
        }
      }

      // Make column headers draggable
      function initDraggableColumns() {
        const ths = Array.from(thead.querySelectorAll('th'));
        
        ths.forEach((th, index) => {
          // Delete button column (index 8 - last column) is not draggable, but CAN be a drop target
          if (index === 8) {
            // Add drop event listeners to delete column so columns can be moved before/after it
            th.addEventListener('dragover', (e) => {
              if (e.preventDefault) e.preventDefault();
              e.dataTransfer.dropEffect = 'move';

              const targetTh = e.currentTarget;
              if (!draggedColumn || targetTh === draggedColumn) return;

              // Remove all drag-over indicators
              ths.forEach(t => {
                t.classList.remove('drag-over-left', 'drag-over-right');
              });

              // Determine which side to show the indicator
              const rect = targetTh.getBoundingClientRect();
              const midpoint = rect.left + rect.width / 2;
              if (e.clientX < midpoint) {
                targetTh.classList.add('drag-over-left');
              } else {
                targetTh.classList.add('drag-over-right');
              }

              return false;
            });

            th.addEventListener('dragleave', (e) => {
              e.currentTarget.classList.remove('drag-over-left', 'drag-over-right');
            });

            th.addEventListener('drop', (e) => {
              if (e.stopPropagation) e.stopPropagation();
              e.preventDefault();

              const targetTh = e.currentTarget;
              if (!draggedColumn || targetTh === draggedColumn) return;

              const targetIndex = Array.from(thead.querySelectorAll('th')).indexOf(targetTh);
              
              // Determine drop position (before or after)
              const rect = targetTh.getBoundingClientRect();
              const midpoint = rect.left + rect.width / 2;
              const dropBefore = e.clientX < midpoint;

              // Move the column
              moveColumn(draggedIndex, targetIndex, dropBefore);

              // Clean up
              targetTh.classList.remove('drag-over-left', 'drag-over-right');

              return false;
            });
            
            return; // Don't make delete column draggable
          }

          th.draggable = true;
          th.classList.add('draggable');

          th.addEventListener('dragstart', (e) => {
            // Don't drag if clicking on resizer or sort icon
            if (e.target.classList.contains('col-resizer') || 
                e.target.closest('.col-resizer') ||
                e.target.classList.contains('sort-arrow')) {
              e.preventDefault();
              return;
            }

            draggedColumn = th;
            draggedIndex = Array.from(thead.querySelectorAll('th')).indexOf(th);
            th.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', th.innerHTML);
          });

          th.addEventListener('dragend', (e) => {
            th.classList.remove('dragging');
            // Remove all drag-over indicators
            ths.forEach(t => {
              t.classList.remove('drag-over-left', 'drag-over-right');
            });
          });

          th.addEventListener('dragover', (e) => {
            if (e.preventDefault) e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const targetTh = e.currentTarget;
            if (!draggedColumn || targetTh === draggedColumn) return;

            // Remove all drag-over indicators
            ths.forEach(t => {
              t.classList.remove('drag-over-left', 'drag-over-right');
            });

            // Determine which side to show the indicator
            const rect = targetTh.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            if (e.clientX < midpoint) {
              targetTh.classList.add('drag-over-left');
            } else {
              targetTh.classList.add('drag-over-right');
            }

            return false;
          });

          th.addEventListener('dragleave', (e) => {
            e.currentTarget.classList.remove('drag-over-left', 'drag-over-right');
          });

          th.addEventListener('drop', (e) => {
            if (e.stopPropagation) e.stopPropagation();
            e.preventDefault();

            const targetTh = e.currentTarget;
            if (!draggedColumn || targetTh === draggedColumn) return;

            const targetIndex = Array.from(thead.querySelectorAll('th')).indexOf(targetTh);
            
            // Determine drop position (before or after)
            const rect = targetTh.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            const dropBefore = e.clientX < midpoint;

            // Move the column
            moveColumn(draggedIndex, targetIndex, dropBefore);

            // Clean up
            targetTh.classList.remove('drag-over-left', 'drag-over-right');

            return false;
          });
        });
      }

      // Move column from one position to another
      function moveColumn(fromIndex, toIndex, insertBefore) {
        const colgroup = table.querySelector('colgroup');
        const ths = Array.from(thead.querySelectorAll('th'));
        const cols = colgroup ? Array.from(colgroup.querySelectorAll('col')) : [];

        // Move header
        const thToMove = ths[fromIndex];
        const thTarget = ths[toIndex];
        if (insertBefore) {
          thead.insertBefore(thToMove, thTarget);
        } else {
          thead.insertBefore(thToMove, thTarget.nextSibling);
        }

        // Move colgroup
        if (colgroup && cols.length > 0) {
          const colToMove = cols[fromIndex];
          const colTarget = cols[toIndex];
          if (insertBefore) {
            colgroup.insertBefore(colToMove, colTarget);
          } else {
            colgroup.insertBefore(colToMove, colTarget.nextSibling);
          }
        }

        // Move all body cells
        const tbody = table.querySelector('tbody');
        if (tbody) {
          const rows = Array.from(tbody.querySelectorAll('tr'));
          rows.forEach(row => {
            const cells = Array.from(row.querySelectorAll('td'));
            if (cells.length > 0) {
              const cellToMove = cells[fromIndex];
              const cellTarget = cells[toIndex];
              if (cellToMove && cellTarget) {
                if (insertBefore) {
                  row.insertBefore(cellToMove, cellTarget);
                } else {
                  row.insertBefore(cellToMove, cellTarget.nextSibling);
                }
              }
            }
          });
        }

        // Save the new order
        const newOrder = getCurrentColumnOrder();
        saveColumnOrder(newOrder);

        // Show confirmation toast
        showToast('Column Reordered', ['Column order has been saved']);
      }

      // Initialize
      const savedOrder = loadColumnOrder();
      if (savedOrder) {
        applyColumnOrder(savedOrder);
      }
      initDraggableColumns();

      // Make globally accessible for table rebuilds
      window.reapplyColumnOrder = function() {
        const savedOrder = loadColumnOrder();
        if (savedOrder) {
          applyColumnOrder(savedOrder);
        }
        initDraggableColumns();
      };
    })();

    // ============ SETTINGS BUTTON ============
    const settingsBtn = document.getElementById("settingsBtn");
    if (settingsBtn) {
      settingsBtn.addEventListener("click", () => {
        window.location.href = "/settings";
      });
    }

 // ============ SETUP MODAL ============
    (function () {
      const setupBtn = document.getElementById("setupBtn");
      const modal = document.getElementById("setupModal");
      const cancelBtn = document.getElementById("modalCancelBtn");
      const saveBtn = document.getElementById("modalSaveBtn");

      const redditLinkInput = document.getElementById("redditLinkInput");
      const totalSpotsInput = document.getElementById("totalSpotsInput");
      const spotCostInput = document.getElementById("spotCostInput");
      const pollingIntervalInput = document.getElementById("pollingIntervalInput");
      const fastRaffleCheckbox = document.getElementById("fastRaffleCheckbox");

      // ⚡ CRITICAL BUG FIX: Check if modal elements exist
      if (!setupBtn || !modal || !cancelBtn || !saveBtn) {
        console.error('⚠️ Setup modal elements not found');
        return;
      }

      setupBtn.addEventListener("click", () => {
        modal.classList.add("show");
      });

      function closeModal() {
        modal.classList.remove("show");
      }

      cancelBtn.addEventListener("click", closeModal);

      // Validate Reddit URL
      function validateRedditUrl(url) {
        if (!url || url.trim() === '') {
          return { valid: true, url: '' }; // Allow empty URLs
        }

        const trimmedUrl = url.trim();

        // Check if it's a valid Reddit post URL
        const redditRegex = /^https?:\/\/(www\.)?(reddit\.com|old\.reddit\.com)\/r\/[^\/]+\/comments\/[^\/]+\/[^\/]+\/?/i;

        if (!redditRegex.test(trimmedUrl)) {
          return {
            valid: false,
            error: 'Invalid Reddit URL format.\n\nPlease enter a complete Reddit post URL like:\nhttps://reddit.com/r/WatchURaffle/comments/abc123/post_title/'
          };
        }

        // Ensure it has https://
        let validUrl = trimmedUrl;
        if (!validUrl.startsWith('http://') && !validUrl.startsWith('https://')) {
          validUrl = 'https://' + validUrl;
        }

        return { valid: true, url: validUrl };
      }

      saveBtn.addEventListener("click", async () => {
        const redditLinkValue = redditLinkInput.value;

        // Validate all fields are filled out
        if (!redditLinkValue || !redditLinkValue.trim()) {
          showErrorToast('Reddit Link Required', [
            'Please enter a Reddit post URL to continue.',
            'Example: https://reddit.com/r/WatchURaffle/comments/abc123/post_title/'
          ]);
          redditLinkInput.focus();
          return;
        }

        if (!totalSpotsInput.value || totalSpotsInput.value.trim() === '') {
          showErrorToast('Total Spots Required', [
            'Please enter the total number of spots for this raffle.'
          ]);
          totalSpotsInput.focus();
          return;
        }

        if (!spotCostInput.value || spotCostInput.value.trim() === '') {
          showErrorToast('Cost Per Spot Required', [
            'Please enter the cost per spot in dollars.'
          ]);
          spotCostInput.focus();
          return;
        }

        // Validate numeric values
        const totalSpots = parseInt(totalSpotsInput.value);
        const spotCost = parseFloat(spotCostInput.value);

        if (isNaN(totalSpots) || totalSpots <= 0) {
          showErrorToast('Invalid Total Spots', [
            'Total spots must be a positive number.'
          ]);
          totalSpotsInput.focus();
          return;
        }

        if (isNaN(spotCost) || spotCost <= 0) {
          showErrorToast('Invalid Cost Per Spot', [
            'Cost per spot must be a positive number (minimum $0.01).'
          ]);
          spotCostInput.focus();
          return;
        }

        // Validate Reddit URL
        const validation = validateRedditUrl(redditLinkValue);
        if (!validation.valid) {
          showErrorToast('Invalid Reddit URL format', [
            'Please enter a complete Reddit post URL like:',
            'https://reddit.com/r/WatchURaffle/comments/abc123/post_title/'
          ]);
          redditLinkInput.focus();
          return;
        }

        const data = {
          redditLink: validation.url,
          totalSpots: totalSpots,
          spotCost: spotCost,
          fastRaffleEnabled: fastRaffleCheckbox.checked
        };

        appState.redditLink = data.redditLink;
        appState.totalSpots = data.totalSpots;
        appState.costPerSpot = data.spotCost;
        appState.fastRaffleEnabled = data.fastRaffleEnabled;

        // Set creation timestamp if this is the first time setup is saved
        if (!appState.createdAt) {
          appState.createdAt = new Date().toISOString();
          console.log('🕐 Raffle creation timestamp set:', appState.createdAt);
        }

        // Start fast raffle timer if enabled
        if (data.fastRaffleEnabled) {
          appState.fastRaffleStartTime = Date.now();
          startFastRaffleTimer();
        } else {
          stopFastRaffleTimer();
        }

        await saveState();

        updateStats();

        const details = [];
        if (data.redditLink) {
          details.push('📝 Reddit post linked');
        }
        details.push(`🎯 ${data.totalSpots} spots @ $${data.spotCost} each`);
        details.push(`🤖 Auto-scanning every 5 sec`);

        showToast('Setup Saved Successfully!', details);
        closeModal();
      });
    })();

 // ============ SUMMARY MODAL ============
    (function () {
      const summaryBtn = document.getElementById("summaryBtn");
      const modal = document.getElementById("summaryModal");
      const closeBtn = document.getElementById("summaryCloseBtn");

      // ⚡ CRITICAL BUG FIX: Check if elements exist before adding listeners
      if (!summaryBtn || !modal || !closeBtn) {
        console.error('⚠️ Summary modal elements not found');
        return;
      }

      summaryBtn.addEventListener("click", () => {
        populateSummary();
        modal.classList.add("show");
      });

      function closeModal() {
        modal.classList.remove("show");
      }

      closeBtn.addEventListener("click", closeModal);

      modal.addEventListener("click", (e) => {
        if (e.target === modal) closeModal();
      });

      function populateSummary() {
        // Separate tabbed and non-tabbed participants
        const payerGroupsNonTabbed = {};
        const tabbedEntries = [];

        appState.participants.forEach(p => {
          const tabbedUser = p.tabbed || '';
          const isTabbed = !!tabbedUser;
          const payer = p.redditUser;

          if (isTabbed) {
            tabbedEntries.push({
              payer: payer,
              payerName: p.name,
              recipient: tabbedUser,
              spots: parseInt(p.spots) || 0,
              owed: parseFloat(p.owed) || 0,
              paid: p.paid
            });
          } else {
            if (!payerGroupsNonTabbed[payer]) {
              payerGroupsNonTabbed[payer] = {
                redditUser: payer,
                name: p.name,
                spots: 0,
                owed: 0,
                paid: p.paid
              };
            }
            payerGroupsNonTabbed[payer].spots += parseInt(p.spots) || 0;
            payerGroupsNonTabbed[payer].owed += parseFloat(p.owed) || 0;
          }
        });

        const nonTabbedArray = Object.values(payerGroupsNonTabbed);
        
        // Count confirmed (non-0-spot participants), waitlist (0-spot), and tabs
        // ⚡ OPTIMIZATION: Count in single pass instead of 2 separate filters (2x faster)
        let confirmedCount = 0;
        let waitlistCount = 0;
        appState.participants.forEach(p => {
          if (p.spots > 0) {
            confirmedCount++;
          } else if (p.spots === 0) {
            waitlistCount++;
          }
        });
        const tabsCount = tabbedEntries.length;

        // Update top stat boxes
        const summaryConfirmedEl = document.getElementById('summaryConfirmed');
        const summaryWaitlistEl = document.getElementById('summaryWaitlist');
        const summaryTabsEl = document.getElementById('summaryTabs');
        
        if (summaryConfirmedEl) summaryConfirmedEl.textContent = confirmedCount;
        if (summaryWaitlistEl) summaryWaitlistEl.textContent = waitlistCount;
        if (summaryTabsEl) summaryTabsEl.textContent = tabsCount;

        // Get container elements
        const participantsList = document.getElementById('participantsList');
        const tabRequestsList = document.getElementById('tabRequestsList');
        const participantCount = document.getElementById('participantCount');
        const tabCount = document.getElementById('tabCount');

        // Clear lists
        participantsList.innerHTML = '';
        tabRequestsList.innerHTML = '';

        // Check if empty
        if (appState.participants.length === 0) {
          participantsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #9CA3AF; font-size: 13px;">No participants yet</div>';
          tabRequestsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #9CA3AF; font-size: 13px;">No tab requests yet</div>';
          participantCount.textContent = '0';
          tabCount.textContent = '0';
          return;
        }

        // Update counts
        participantCount.textContent = nonTabbedArray.length;
        tabCount.textContent = tabbedEntries.length;

        // Sort participants alphabetically
        nonTabbedArray.sort((a, b) => a.redditUser.localeCompare(b.redditUser));

        // Populate participants list
        nonTabbedArray.forEach(participant => {
          const card = document.createElement('div');
          card.className = `summary-card ${participant.paid ? 'participant-paid' : 'participant-unpaid'}`;
          
          const spotsText = participant.spots === 1 ? 'spot' : 'spots';
          const badge = participant.paid ? '✓ PAID' : '⏳ UNPAID';
          
          card.innerHTML = `
            <div class="summary-card-left">
              <div class="summary-card-title">${escapeHtml(participant.redditUser)}</div>
              <div class="summary-card-subtitle">${participant.spots} ${spotsText}</div>
            </div>
            <div class="summary-card-right">
              <div class="summary-card-amount">$${(parseFloat(participant.owed) || 0).toFixed(2)}</div>
              <div class="summary-card-badge">${badge}</div>
            </div>
          `;
          
          participantsList.appendChild(card);
        });

        // Group tabbed entries by recipient (who is being tabbed)
        const tabbedByRecipient = {};
        tabbedEntries.forEach(entry => {
          const key = `${entry.payer}_${entry.recipient}`;
          if (!tabbedByRecipient[key]) {
            tabbedByRecipient[key] = {
              payer: entry.payer,
              recipient: entry.recipient,
              spots: 0,
              owed: 0
            };
          }
          tabbedByRecipient[key].spots += entry.spots;
          tabbedByRecipient[key].owed += entry.owed;
        });

        // Populate tab requests list
        Object.values(tabbedByRecipient).forEach(tab => {
          const card = document.createElement('div');
          card.className = 'summary-card tab-request';
          
          const spotsText = tab.spots === 1 ? 'spot' : 'spots';
          
          // ⚡ CRITICAL SECURITY FIX: Escape HTML to prevent XSS
          card.innerHTML = `
            <div class="summary-card-left">
              <div class="summary-card-title">${escapeHtml(tab.payer)} tabbed ${escapeHtml(tab.recipient)}</div>
              <div class="summary-card-subtitle">${tab.spots} ${spotsText}</div>
            </div>
            <div class="summary-card-right">
              <div class="summary-card-amount">$${(parseFloat(tab.owed) || 0).toFixed(2)}</div>
              <div class="summary-card-badge">TAB</div>
            </div>
          `;
          
          tabRequestsList.appendChild(card);
        });

        // If no tab requests, show empty state
        if (tabbedEntries.length === 0) {
          tabRequestsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #9CA3AF; font-size: 13px;">No tab requests yet</div>';
        }
      }
    })();



 // ============ NAME IMPORT MODAL ============
    // Note: This modal is now primarily used in Settings page
    // Keeping the handler logic here for potential inline use
    (function () {
      const modal = document.getElementById("nameImportModal");
      if (!modal) return; // Modal might not exist on this page

      const closeBtn = document.getElementById("nameImportCloseBtn");
      const fileInput = document.getElementById("nameFileInput");
      const importNowBtn = document.getElementById("nameImportBtn");
      const exportBtn = document.getElementById("nameExportBtn");
      const clearBtn = document.getElementById("nameClearBtn");
      const preview = document.getElementById("importPreview");
      const previewList = document.getElementById("importPreviewList");
      const importCount = document.getElementById("importCount");

      let parsedData = null;

      function closeModal() {
        modal.classList.remove("show");
        fileInput.value = '';
        preview.style.display = 'none';
        parsedData = null;
        importNowBtn.disabled = true;
      }

      if (closeBtn) closeBtn.addEventListener("click", closeModal);

      if (modal) {
        modal.addEventListener("click", (e) => {
          if (e.target === modal) closeModal();
        });
      }

      // File input change handler
      if (fileInput) {
        fileInput.addEventListener("change", async (e) => {
          const file = e.target.files[0];
          if (!file) return;

          try {
            const data = await parseFile(file);
            parsedData = data;

            // Show preview
            const entries = Object.entries(data);
            const previewEntries = entries.slice(0, 5);

            if (previewList) {
              previewList.innerHTML = previewEntries
                .map(([reddit, name]) => `${reddit} → ${name}`)
                .join('<br>');
            }

            if (importCount) importCount.textContent = `Ready to import ${entries.length} name mappings`;
            if (preview) preview.style.display = 'block';
            if (importNowBtn) importNowBtn.disabled = false;

          } catch (error) {
            showErrorToast('File Parse Error', [error.message]);
            if (preview) preview.style.display = 'none';
            if (importNowBtn) importNowBtn.disabled = true;
          }
        });
      }

      // Parse file (CSV or Excel)
      async function parseFile(file) {
        const fileName = file.name.toLowerCase();

        if (fileName.endsWith('.csv') || fileName.endsWith('.tsv') || fileName.endsWith('.txt')) {
          return parseCSV(file);
        } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
          return parseExcel(file);
        } else {
          throw new Error('Unsupported file format. Use CSV, TSV, or Excel (.xlsx, .xls)');
        }
      }

      // Parse CSV
      async function parseCSV(file) {
        const text = await file.text();
        const lines = text.split('\n').filter(line => line.trim());
        const mappings = {};

        // Skip header if present
        const startIndex = lines[0].toLowerCase().includes('reddit') ? 1 : 0;

        for (let i = startIndex; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          const parts = line.split(',').map(p => p.trim());
          if (parts.length >= 2) {
            const reddit = parts[0];
            const name = parts.slice(1).join(',').replace(/^["']|["']$/g, ''); // Handle quoted names
            if (reddit && name) {
              mappings[reddit] = name;
            }
          }
        }

        return mappings;
      }

      // Parse Excel
      async function parseExcel(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = (e) => {
            try {
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
              const rows = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });

              const mappings = {};
              // Skip header if present
              const startIndex = rows[0] && String(rows[0][0]).toLowerCase().includes('reddit') ? 1 : 0;

              for (let i = startIndex; i < rows.length; i++) {
                const row = rows[i];
                if (row && row.length >= 2) {
                  const reddit = String(row[0]).trim();
                  const name = String(row[1]).trim();
                  if (reddit && name) {
                    mappings[reddit] = name;
                  }
                }
              }

              resolve(mappings);
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = () => reject(new Error('Failed to read file'));
          reader.readAsArrayBuffer(file);
        });
      }

      // Import button handler
      if (importNowBtn) {
        importNowBtn.addEventListener("click", async () => {
          if (!parsedData) return;

          // Merge with existing mappings
          const existing = loadAllMappings();
          const merged = { ...existing, ...parsedData };
          saveAllMappings(merged);

          // Rebuild table to show new names
          await rebuildTable();
          filterAndSearch(); // ✅ Re-apply current filter

          showToast('Names Imported!', [
            `✓ ${Object.keys(parsedData).length} mappings imported`,
            `📋 Total mappings: ${Object.keys(merged).length}`,
            '🔄 Names updated in table'
          ]);

          closeModal();
        });
      }

      // Export button handler
      if (exportBtn) {
        exportBtn.addEventListener("click", () => {
          const csv = exportMappingsAsCSV();
          const blob = new Blob([csv], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `reddit_names_${new Date().toISOString().split('T')[0]}.csv`;
          a.click();
          URL.revokeObjectURL(url);

          showToast('Mappings Exported!', ['📥 CSV file downloaded']);
        });
      }

      // Clear button handler
      if (clearBtn) {
        clearBtn.addEventListener("click", async () => {
          if (confirm('Are you sure you want to clear all name mappings? This cannot be undone.')) {
            clearAllMappings();
            await rebuildTable();
            filterAndSearch(); // ✅ Re-apply current filter
            showToast('Mappings Cleared!', ['🗑️ All name mappings removed']);
          }
        });
      }
    })();

 // ============ RESTRICTION MODAL ============
    (function () {
      const restrictionModal = document.getElementById("restrictionModal");
      const restrictionMessage = document.getElementById("restrictionMessage");
      const restrictionModalTitle = document.getElementById("restrictionModalTitle");
      const restrictionOkBtn = document.getElementById("restrictionOkBtn");
      const restrictionCancelRaffleBtn = document.getElementById("restrictionCancelRaffleBtn");

      window.showRestrictionModal = function(message, showCancelButton = false, title = "Cannot Finish Raffle!") {
        restrictionModalTitle.textContent = title;
        restrictionMessage.innerHTML = message;
        restrictionCancelRaffleBtn.style.display = showCancelButton ? "block" : "none";
        restrictionModal.classList.add("show");
      };

      restrictionOkBtn.addEventListener("click", () => {
        restrictionModal.classList.remove("show");
      });

      restrictionCancelRaffleBtn.addEventListener("click", () => {
        restrictionModal.classList.remove("show");
        showCancelConfirmModal();
      });

      restrictionModal.addEventListener("click", (e) => {
        if (e.target === restrictionModal) {
          restrictionModal.classList.remove("show");
        }
      });
    })();

 // ============ CANCEL RAFFLE CONFIRMATION MODAL ============
    (function () {
      const cancelConfirmModal = document.getElementById("cancelConfirmModal");
      const cancelConfirmOkBtn = document.getElementById("cancelConfirmOkBtn");
      const cancelConfirmCancelBtn = document.getElementById("cancelConfirmCancelBtn");

      window.showCancelConfirmModal = function() {
        cancelConfirmModal.classList.add("show");
      };

      cancelConfirmOkBtn.addEventListener("click", async () => {
        cancelConfirmModal.classList.remove("show");
        await saveToHistory('cancelled', null);
        showToast('Raffle Cancelled', ['Saved to history as cancelled']);
        await resetRaffle();
      });

      cancelConfirmCancelBtn.addEventListener("click", () => {
        cancelConfirmModal.classList.remove("show");
      });

      cancelConfirmModal.addEventListener("click", (e) => {
        if (e.target === cancelConfirmModal) {
          cancelConfirmModal.classList.remove("show");
        }
      });
    })();

 // ============ PAYPAL SCAN CONFIRMATION MODAL ============
    (function () {
      const paypalScanModal = document.getElementById("paypalScanModal");
      const paypalScanOkBtn = document.getElementById("paypalScanOkBtn");
      const paypalScanCancelBtn = document.getElementById("paypalScanCancelBtn");
      let scanCallback = null;

      window.showPaypalScanModal = function(onConfirm) {
        scanCallback = onConfirm;
        paypalScanModal.classList.add("show");
      };

      paypalScanOkBtn.addEventListener("click", () => {
        paypalScanModal.classList.remove("show");
        if (scanCallback) {
          scanCallback();
          scanCallback = null;
        }
      });

      paypalScanCancelBtn.addEventListener("click", () => {
        paypalScanModal.classList.remove("show");
        scanCallback = null;
      });

      paypalScanModal.addEventListener("click", (e) => {
        if (e.target === paypalScanModal) {
          paypalScanModal.classList.remove("show");
          scanCallback = null;
        }
      });
    })();

 // ============ FINISH RAFFLE MODAL ============
    (function () {
      const finishBtn = document.getElementById("finishRaffleBtn");
      const modal = document.getElementById("finishModal");
      const completeBtn = document.getElementById("finishCompleteBtn");
      const winnerEntriesContainer = document.getElementById("winnerEntriesContainer");
      
      // ⚡ CRITICAL BUG FIX: Check if modal elements exist
      if (!finishBtn || !modal || !completeBtn || !winnerEntriesContainer) {
        console.error('⚠️ Finish raffle modal elements not found');
        return;
      }
      
      let winnerCount = 1;
      let finishModalGlobalListenersAttached = false;

   finishBtn.addEventListener("click", () => {
        // Check if setup is complete first
        if (!appState.redditLink || !appState.costPerSpot || appState.totalSpots === null) {
          showRestrictionModal(`Setup is incomplete.<br>Please configure Reddit Link, Total Spots, and Cost Per Spot before finishing the raffle.`);
          return;
        }

        // Calculate current stats - ✅ Exclude Waitlist participants (0 spots)
        // ⚡ OPTIMIZED: Calculate all stats in a single pass (no filter needed - check inline)
        let spotsClaimed = 0;
        let totalOwed = 0;
        let totalPaid = 0;
        
        appState.participants.forEach(p => {
          const spots = p.spots || 0;
          if (spots > 0) {
            spotsClaimed += spots;
            totalOwed += (p.owed || 0);
            if (p.paid) {
              totalPaid += (p.owed || 0);
            }
          }
        });
        
        const spotsRemaining = appState.totalSpots !== null ? Math.max(0, appState.totalSpots - spotsClaimed) : 0;
        const unpaidAmount = totalOwed - totalPaid;

        // Check if raffle can be finished
        if (spotsRemaining > 0) {
          showRestrictionModal(`There are still <strong>${spotsRemaining}</strong> spots remaining.<br>All spots must be filled before selecting a winner.`, true);
          return;
        }

        if (unpaidAmount > 0) {
          showRestrictionModal(`There is still <strong>$${unpaidAmount.toLocaleString()}</strong> owed.<br>All payments must be collected before selecting a winner.`, true);
          return;
        }

        // If all checks pass, open the modal
        winnerCount = 1;
        updateWinnerCountButtons();
        renderWinnerEntries();
        completeBtn.disabled = true;

        modal.classList.add("show");

        // Populate username dropdown
        populateUsernameDropdown();
      });

      function closeModal() {
        modal.classList.remove("show");
      }

      modal.addEventListener("click", (e) => {
        if (e.target === modal) closeModal();
      });

      // Winner count button handlers
      // ��� FIX: Only attach listeners once using a flag
      if (!window.winnerCountListenersAttached) {
        document.querySelectorAll('.winner-count-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const count = parseInt(btn.dataset.count);
            // ⚡ CRITICAL BUG FIX: Validate count is a valid number
            if (isNaN(count)) {
              console.error('⚠️ Invalid count in winner button');
              return;
            }
            winnerCount = count;
            updateWinnerCountButtons();
            renderWinnerEntries();
            validateWinnerInput();
          });
        });
        window.winnerCountListenersAttached = true;
      }

      function updateWinnerCountButtons() {
        document.querySelectorAll('.winner-count-btn').forEach(btn => {
          const count = parseInt(btn.dataset.count);
          // ⚡ CRITICAL BUG FIX: Skip button if count is invalid
          if (isNaN(count)) return;
          
          if (count === winnerCount) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });

        // Update modal text
        const modalText = document.getElementById('finishModalText');
        if (modalText) {
          if (winnerCount === 1) {
            modalText.textContent = 'Enter the winner\'s information to complete the raffle.';
          } else {
            modalText.textContent = `Enter information for all ${winnerCount} winners to complete the raffle.`;
          }
        }
      }

      function renderWinnerEntries() {
        winnerEntriesContainer.innerHTML = '';
        const totalSpots = appState.totalSpots || 100;

        for (let i = 0; i < winnerCount; i++) {
          const entry = document.createElement('div');
          entry.className = 'winner-entry';
          entry.innerHTML = `
            <div class="winner-entry-header">${winnerCount === 1 ? 'Winner' : `Winner #${i + 1}`}</div>
            <div class="form-group" style="margin-bottom: 12px;">
              <label class="form-label">Reddit Username</label>
              <div class="username-dropdown-container">
                <input
                  type="text"
                  class="form-input winner-username-input"
                  data-index="${i}"
                  placeholder="Search Reddit username..."
                  autocomplete="off"
                />
                <div class="username-dropdown-list" data-index="${i}"></div>
              </div>
            </div>
            <div class="form-group">
              <label class="form-label">Winning Spot Number</label>
              <input
                type="number"
                class="form-input winner-spot-input"
                data-index="${i}"
                placeholder="Enter spot number (1-${totalSpots})"
                min="1"
                max="${totalSpots}"
              />
            </div>
          `;
          winnerEntriesContainer.appendChild(entry);
        }

        // Attach event listeners
        attachWinnerInputListeners();
      }

      function attachWinnerInputListeners() {
        // ✅ FIX: Use event delegation to prevent duplicate listeners
        // Remove old listeners first if they exist
        if (window.winnerInputHandler) {
          winnerEntriesContainer.removeEventListener('input', window.winnerInputHandler);
        }
        if (window.winnerFocusHandler) {
          winnerEntriesContainer.removeEventListener('focus', window.winnerFocusHandler, true);
        }
        
        // Create named handlers for removal
        window.winnerInputHandler = function(e) {
          if (e.target.classList.contains('winner-username-input')) {
            const index = parseInt(e.target.dataset.index);
            // ⚡ CRITICAL BUG FIX: Validate index before using
            if (isNaN(index)) return;
            filterUsernameDropdown(e.target.value, index);
            validateWinnerInput();
          } else if (e.target.classList.contains('winner-spot-input')) {
            validateWinnerInput();
          }
        };
        
        window.winnerFocusHandler = function(e) {
          if (e.target.classList.contains('winner-username-input') && e.target.value) {
            const index = parseInt(e.target.dataset.index);
            // ⚡ CRITICAL BUG FIX: Validate index before using
            if (isNaN(index)) return;
            filterUsernameDropdown(e.target.value, index);
          }
        };
        
        // Attach using event delegation on container
        winnerEntriesContainer.addEventListener('input', window.winnerInputHandler);
        winnerEntriesContainer.addEventListener('focus', window.winnerFocusHandler, true);

        // Close dropdowns when clicking outside - only attach once
        if (!finishModalGlobalListenersAttached) {
          document.addEventListener('click', (e) => {
            if (!e.target.closest('.username-dropdown-container')) {
              document.querySelectorAll('.username-dropdown-list').forEach(list => {
                list.classList.remove('show');
              });
            }
          });
          finishModalGlobalListenersAttached = true;
        }
      }

         // Populate username dropdown with unique Reddit usernames
      function populateUsernameDropdown() {
        // Get unique Reddit usernames (filter out undefined/null)
        const usernames = [...new Set(appState.participants.map(p => p.redditUser).filter(Boolean))].sort();

        // Store for filtering
        window.allUsernames = usernames;
      }

      // Filter and display username dropdown
      function filterUsernameDropdown(searchTerm, index) {
        const dropdownList = document.querySelector(`.username-dropdown-list[data-index="${index}"]`);
        if (!dropdownList) return;

        const searchLower = searchTerm.toLowerCase();

        // ⚡ CRITICAL BUG FIX: Check if allUsernames exists and is an array
        if (!window.allUsernames || !Array.isArray(window.allUsernames)) {
          console.warn('⚠️ window.allUsernames not initialized');
          window.allUsernames = [];
        }

        // Filter usernames
        const filtered = window.allUsernames.filter(u => u.toLowerCase().includes(searchLower));

        // Clear list
        dropdownList.innerHTML = '';

        if (searchTerm && filtered.length > 0) {
          // ✅ FIX: Use event delegation to prevent creating new listeners on every keystroke
          filtered.forEach(username => {
            const item = document.createElement('div');
            item.className = 'username-dropdown-item';
            item.textContent = username;
            item.dataset.username = username;
            dropdownList.appendChild(item);
          });
          
          // Attach single delegated click handler (only if not already attached)
          if (!dropdownList.dataset.listenerAttached) {
            dropdownList.addEventListener('click', (e) => {
              const item = e.target.closest('.username-dropdown-item');
              if (!item) return;
              
              const username = item.dataset.username;
              const input = document.querySelector(`.winner-username-input[data-index="${index}"]`);
              input.value = username;
              dropdownList.classList.remove('show');
              validateWinnerInput();

              // Focus on spot input
              const spotInput = document.querySelector(`.winner-spot-input[data-index="${index}"]`);
              if (spotInput) spotInput.focus();
            });
            dropdownList.dataset.listenerAttached = 'true';
          }
          dropdownList.classList.add('show');
        } else {
          dropdownList.classList.remove('show');
        }
      }

      function validateWinnerInput() {
        const totalSpots = appState.totalSpots || 100;
        let allValid = true;

        const usernameInputs = document.querySelectorAll('.winner-username-input');
        const spotInputs = document.querySelectorAll('.winner-spot-input');

        // Check each winner entry
        for (let i = 0; i < winnerCount; i++) {
          const username = usernameInputs[i]?.value.trim();
          const spotValue = parseInt(spotInputs[i]?.value);
          const hasUsername = username !== '';
          // ⚡ CRITICAL BUG FIX: Check for NaN explicitly before comparison
          const hasSpot = spotInputs[i]?.value !== '' && !isNaN(spotValue) && spotValue > 0 && spotValue <= totalSpots;

          if (!hasUsername || !hasSpot) {
            allValid = false;
            break;
          }
        }

        // Check for duplicate spots
        if (allValid) {
          // ⚡ CRITICAL BUG FIX: Use optional chaining to prevent errors if input doesn't exist
          const spots = Array.from(spotInputs).slice(0, winnerCount).map(input => parseInt(input?.value || '0'));
          const uniqueSpots = new Set(spots);
          if (uniqueSpots.size !== spots.length) {
            allValid = false;
          }
        }

        completeBtn.disabled = !allValid;
      }

      completeBtn.addEventListener("click", async () => {
        const totalSpots = appState.totalSpots || 100;
        const winners = [];

        // Collect all winner data
        const usernameInputs = document.querySelectorAll('.winner-username-input');
        const spotInputs = document.querySelectorAll('.winner-spot-input');

        for (let i = 0; i < winnerCount; i++) {
          // ⚡ CRITICAL BUG FIX: Check if inputs exist before accessing properties
          if (!usernameInputs[i] || !spotInputs[i]) {
            showErrorToast('Missing Input Fields', [`Input fields for Winner #${i + 1} not found.`]);
            return;
          }
          
          const username = usernameInputs[i].value.trim();
          const spot = parseInt(spotInputs[i].value);

          // ⚡ CRITICAL BUG FIX: Check isNaN instead of !spot (0 is falsy but not a valid spot anyway, but clearer to check isNaN)
          if (!username || isNaN(spot) || spot === 0) {
            showErrorToast('Missing Information', [`Please enter username and spot for Winner #${i + 1}.`]);
            return;
          }

          if (spot < 1 || spot > totalSpots) {
            showErrorToast('Invalid Spot Number', [`Spot number for Winner #${i + 1} must be between 1 and ${totalSpots}.`]);
            return;
          }

          winners.push({ username, spot });
        }

        // Check for duplicate spots
        const spots = winners.map(w => w.spot);
        const uniqueSpots = new Set(spots);
        if (uniqueSpots.size !== spots.length) {
          showErrorToast('Duplicate Spots', ['Each winner must have a unique spot number.']);
          return;
        }

        // Save with single winner or multiple winners
        const winnerData = winnerCount === 1 ? winners[0] : winners;

        await saveToHistory('completed', winnerData);

        // Stop fast raffle timer
        stopFastRaffleTimer();

        // Show toast
        if (winnerCount === 1) {
          showToast(
            `🏆 Winner: ${winners[0].username}`,
            [`Spot #${winners[0].spot}`]
          );
        } else {
          showToast(
            `🏆 ${winnerCount} Winners Selected!`,
            winners.map((w, i) => `#${i + 1}: ${w.username} (Spot #${w.spot})`)
          );
        }

        await resetRaffle();
        closeModal();
      });
    })();

    // ============ SCAN EMAIL BUTTON ============
    const scanEmailBtn = document.getElementById("scanEmailBtn");
    if (scanEmailBtn) {
      scanEmailBtn.addEventListener("click", async () => {
        console.log('🔍 Scan Email clicked. Current state:', {
          activeRaffleId: appState.activeRaffleId,
          redditLink: appState.redditLink,
          totalSpots: appState.totalSpots,
          costPerSpot: appState.costPerSpot,
        participantCount: appState.participants.length
      });

      // Check if raffle exists
      if (!appState.activeRaffleId) {
        console.error('❌ Cannot scan email: No active raffle ID found');
        showErrorToast('No Active Raffle', [
          'Please save your raffle configuration first.',
          'Click "Setup" → enter raffle details → click "Save"'
        ]);
        return;
      }

      console.log('✅ Active raffle ID found:', appState.activeRaffleId);

      // Check if Gmail OAuth credentials are configured
      try {
        const checkResponse = await fetch('/api/paypal/check-credentials');
        
        // If server error (500), skip the check and let the scan handle it
        if (!checkResponse.ok) {
          console.warn('⚠️ Credential check endpoint error, skipping pre-check. Status:', checkResponse.status);
          // Continue to scan - it will show proper error if credentials are really missing
        } else {
          const checkResult = await checkResponse.json();

          if (!checkResult.ok || !checkResult.hasCredentials) {
            showRestrictionModal(
              `Please upload your Gmail OAuth credentials in <b>Settings</b> before scanning emails.<br><br>Go to Settings → Bot Configuration → Upload Gmail OAuth JSON file.`,
              false,
              "Gmail OAuth Not Configured"
            );
            return;
          }
        }
      } catch (error) {
        console.error('Failed to check Gmail credentials:', error);
        // Continue anyway - the actual scan will catch this error
      }

      // Show confirmation modal before scanning
      showPaypalScanModal(async () => {
        try {
        const requestBody = {
          raffle_id: appState.activeRaffleId
        };

        // Send timestamp if available, otherwise fall back to days_back
        if (appState.createdAt) {
          requestBody.since_timestamp = appState.createdAt;
        } else {
          requestBody.days_back = 7;
        }

        const response = await fetch('/api/paypal/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });

        // ⚡ CRITICAL BUG FIX: Check response.ok before calling .json()
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();

        if (!result.ok) {
          // Check if credentials are missing
          if (result.error && result.error.includes('Gmail credentials not found')) {
            showRestrictionModal(`Gmail not connected.<br><br>Please upload your Gmail OAuth credentials in <b>Settings</b> to use this feature.`);
          } else {
            showRestrictionModal(`Scan failed.<br><br>${result.error || 'Unknown error'}`);
          }
          return;
        }

        // Show results
        const details = [
          `📧 Emails scanned: ${result.processed || 0}`,
          `✅ Payments matched: ${result.matched || 0}`
        ];

        // Add specific match details if available
        if (result.results && result.results.length > 0) {
          const matched = result.results.filter(r => r.status === 'matched');

          if (matched.length > 0) {
            details.push('');
            details.push('✅ Matched Payments:');
            matched.forEach(m => {
              details.push(`• ${m.payer_name || 'Unknown'}: $${m.amount} → u/${m.reddit_user}`);
            });
          }
        }

        showToast('Email Scan Complete!', details);

        // Reload participants to show updated payment status
        if (result.matched > 0) {
          // ⚡ CRITICAL BUG FIX: Missing await statement
          await loadState();
        }

      } catch (error) {
        console.error('Scan email error:', error);
        showRestrictionModal(`Failed to scan emails.<br><br>${error.message}`);
      }
      });
    });

    // ============ BULK TAB ASSIGNMENT MODAL ============
    let bulkTabChanges = {}; // Temporary storage for unsaved changes
    let bulkTabGlobalListenersAttached = false; // Prevent duplicate document-level listeners

    function openBulkTabModal() {
      const modal = document.getElementById('bulkTabModal');
      const search = document.getElementById('bulkTabSearch');
      const listContainer = document.getElementById('bulkTabList');
      
      // ⚡ CRITICAL BUG FIX: Check if modal elements exist
      if (!modal || !search || !listContainer) {
        console.error('⚠️ Bulk tab modal elements not found');
        return;
      }
      
      // Safety check - ensure allTabbedUsers is initialized
      if (!window.allTabbedUsers || !Array.isArray(window.allTabbedUsers)) {
        console.warn('⚠️ allTabbedUsers not initialized, cannot open bulk tab modal');
        showToast('Error', ['Tab list not loaded. Please refresh the page.'], 'error');
        return;
      }
      
      // Reset changes
      bulkTabChanges = {};
      
      // Populate list
      renderBulkTabList();
      
      // Show modal
      modal.classList.add('show');
      
      // Focus search
      setTimeout(() => search.focus(), 100);
    }

    function renderBulkTabList(searchTerm = '') {
      // ⚡ PERFORMANCE TIMING: Monitor bulk tab list rendering
      const perfStart = performance.now();
      
      const listContainer = document.getElementById('bulkTabList');
      
      // ⚡ CRITICAL BUG FIX: Check if listContainer exists
      if (!listContainer) {
        console.error('⚠️ Bulk tab list container not found');
        return;
      }
      
      // Filter by search term (show ALL participants, filter by search)
      // ⚡ PERFORMANCE: Pre-lowercase searchTerm once instead of inside loop
      const searchLower = searchTerm.toLowerCase();
      const filtered = appState.participants.filter(p => {
        if (!searchTerm) return true;
        return (p.redditUser || '').toLowerCase().includes(searchLower) ||
               (p.comment || '').toLowerCase().includes(searchLower) ||
               (p.tabbed || '').toLowerCase().includes(searchLower);
      });
      
      // ⚡ PERFORMANCE: Build index map once to avoid O(n²) indexOf calls
      const participantIndexMap = new Map();
      appState.participants.forEach((p, idx) => participantIndexMap.set(p, idx));
      
      // Build HTML
      let html = '';
      filtered.forEach((p, index) => {
        const actualIndex = participantIndexMap.get(p);
        const currentTabbed = bulkTabChanges[actualIndex] !== undefined 
          ? bulkTabChanges[actualIndex] 
          : (p.tabbed || '');
        
        // ⚡ PERFORMANCE FIX: Find user once instead of 3 times (was O(3n), now O(n))
        // ⚡ CRITICAL BUG FIX: Check if allTabbedUsers exists before calling .find()
        const tabbedUser = (currentTabbed && window.allTabbedUsers && Array.isArray(window.allTabbedUsers)) 
          ? window.allTabbedUsers.find(u => u.reddit === currentTabbed) 
          : null;
        const tabbedDisplayValue = currentTabbed 
          ? (tabbedUser ? `${tabbedUser.reddit}${tabbedUser.name ? ' (' + tabbedUser.name + ')' : ''}` : currentTabbed)
          : '';
        
        html += `
          <div class="bulk-tab-item">
            <div class="bulk-tab-item-left">
              <div style="display: flex; flex-direction: column; gap: 4px; flex: 1;">
                <div style="display: flex; align-items: center; gap: 10px;">
                  <span class="bulk-tab-user">u/${p.redditUser}</span>
                  <span class="bulk-tab-spots">${p.spots || 0} spots</span>
                </div>
                <span class="bulk-tab-comment">${p.comment || ''}</span>
              </div>
            </div>
            <div class="searchable-dropdown" data-index="${actualIndex}">
              <input 
                type="text" 
                class="searchable-dropdown-input" 
                placeholder="— None —"
                value="${tabbedDisplayValue}"
                data-value="${currentTabbed}"
                readonly
              />
              <span class="searchable-dropdown-arrow">▼</span>
              <div class="searchable-dropdown-list">
                <!-- Populated by JS -->
              </div>
            </div>
          </div>
        `;
      });
      
      listContainer.innerHTML = html || '<p style="text-align: center; color: #64748b; padding: 20px;">No participants found matching your search.</p>';
      
      // Update participant count
      const countDisplay = document.getElementById('bulkTabParticipantCount');
      if (countDisplay) {
        const totalParticipants = appState.participants.length;
        const displayedCount = filtered.length;
        if (searchTerm) {
          countDisplay.textContent = `Showing ${displayedCount} of ${totalParticipants} participants`;
        } else {
          countDisplay.textContent = `${totalParticipants} participants`;
        }
      }
      
      // Attach searchable dropdown listeners
      listContainer.querySelectorAll('.searchable-dropdown').forEach(dropdown => {
        initSearchableDropdown(dropdown);
      });
      
      updateBulkTabCounter();
      
      // ⚡ PERFORMANCE TIMING: Log rendering time
      const perfEnd = performance.now();
      const renderTime = perfEnd - perfStart;
      if (renderTime > 50) {
        console.warn(`���️ renderBulkTabList() took ${renderTime.toFixed(1)}ms (>50ms threshold) for ${filtered.length} items`);
      }
    }

    function initSearchableDropdown(dropdown) {
      const input = dropdown.querySelector('.searchable-dropdown-input');
      const list = dropdown.querySelector('.searchable-dropdown-list');
      const index = parseInt(dropdown.dataset.index);
      
      // ⚡ CRITICAL BUG FIX: Validate index is a valid number
      if (isNaN(index)) {
        console.error('⚠️ Invalid index in bulk tab dropdown');
        return;
      }
      
      let isOpen = false;
      let allOptions = window.allTabbedUsers || [];
      
      // Populate dropdown list
      function renderOptions(searchTerm = '') {
        // ⚡ PERFORMANCE: Pre-lowercase searchTerm once instead of inside loop
        const searchLower = searchTerm.toLowerCase();
        const filtered = allOptions.filter(u => {
          if (!searchTerm) return true;
          return u.redditLower.includes(searchLower) || 
                 (u.nameLower && u.nameLower.includes(searchLower));
        });
        
        const currentValue = input.dataset.value;
        
        let html = '<div class="searchable-dropdown-option" data-value="">— None —</div>';
        
        if (filtered.length === 0) {
          html += '<div class="searchable-dropdown-option no-results">No users found</div>';
        } else {
          filtered.forEach(u => {
            const displayText = u.reddit + (u.name ? ` (${u.name})` : '');
            const isSelected = currentValue === u.reddit;
            html += `<div class="searchable-dropdown-option ${isSelected ? 'selected' : ''}" data-value="${u.reddit}">${displayText}</div>`;
          });
        }
        
        list.innerHTML = html;
        
        // ✅ FIX: Use event delegation to prevent duplicate listeners on every search
        // Only attach listener once per dropdown
        if (!list.dataset.listenerAttached) {
          list.addEventListener('click', (e) => {
            const option = e.target.closest('.searchable-dropdown-option:not(.no-results)');
            if (option) {
              selectOption(option.dataset.value);
            }
          });
          list.dataset.listenerAttached = 'true';
        }
      }
      
      // Select an option
      function selectOption(value) {
        const originalValue = appState.participants[index]?.tabbed || '';
        
        // Update input
        input.dataset.value = value;
        if (value) {
          const user = allOptions.find(u => u.reddit === value);
          if (user) {
            input.value = user.reddit + (user.name ? ` (${user.name})` : '');
          } else {
            input.value = value; // Fallback to raw value if user not found
          }
        } else {
          input.value = '';
          input.placeholder = '— None —';
        }
        
        // Track change
        if (value !== originalValue) {
          bulkTabChanges[index] = value;
          dropdown.closest('.bulk-tab-item').classList.add('changed');
        } else {
          delete bulkTabChanges[index];
          dropdown.closest('.bulk-tab-item').classList.remove('changed');
        }
        
        updateBulkTabCounter();
        closeDropdown();
      }
      
      // Open dropdown
      function openDropdown() {
        // ⚡ BUG FIX: Prevent opening if already open
        if (list.classList.contains('show')) return;
        
        isOpen = true;
        list.classList.add('show');
        input.removeAttribute('readonly');
        input.select();
        renderOptions();
      }
      
      // Close dropdown
      function closeDropdown() {
        // ⚡ BUG FIX: Prevent closing if already closed
        if (!list.classList.contains('show')) return;
        
        isOpen = false;
        list.classList.remove('show');
        input.setAttribute('readonly', 'readonly');
        
        // Restore display value
        const value = input.dataset.value;
        if (value) {
          const user = allOptions.find(u => u.reddit === value);
          if (user) {
            input.value = user.reddit + (user.name ? ` (${user.name})` : '');
          } else {
            input.value = value; // Fallback to raw value if user not found
          }
        } else {
          input.value = '';
          input.placeholder = '— None —';
        }
      }
      
      // Click on input
      input.addEventListener('click', () => {
        // ⚡ BUG FIX: Sync isOpen with actual DOM state (fixes stuck dropdown bug)
        const isActuallyOpen = list.classList.contains('show');
        if (!isActuallyOpen) {
          openDropdown();
        } else {
          closeDropdown();
        }
      });
      
      // Input typing (search)
      input.addEventListener('input', () => {
        // ⚡ BUG FIX: Check actual DOM state instead of relying on isOpen variable
        const isActuallyOpen = list.classList.contains('show');
        if (isActuallyOpen) {
          renderOptions(input.value);
        }
      });
      
      // Click outside to close - only attach once globally
      if (!bulkTabGlobalListenersAttached) {
        document.addEventListener('click', (e) => {
          // ⚡ BUG FIX: Check if click is inside bulk tab modal at all
          const bulkTabModal = document.getElementById('bulkTabModal');
          if (!bulkTabModal || !bulkTabModal.contains(e.target)) {
            return; // Don't close dropdowns if modal itself is not visible/clicked
          }
          
          const allDropdowns = document.querySelectorAll('.searchable-dropdown');
          allDropdowns.forEach(dd => {
            const ddInput = dd.querySelector('.searchable-dropdown-input');
            const ddList = dd.querySelector('.searchable-dropdown-list');
            if (!dd.contains(e.target) && ddList && ddList.classList.contains('show')) {
              // ⚡ BUG FIX: Properly close dropdown (same logic as closeDropdown function)
              ddList.classList.remove('show');
              if (ddInput) {
                ddInput.setAttribute('readonly', 'readonly');
                // Restore display value
                const value = ddInput.dataset.value;
                if (value) {
                  const allOpts = window.allTabbedUsers || [];
                  const user = allOpts.find(u => u.reddit === value);
                  if (user) {
                    ddInput.value = user.reddit + (user.name ? ` (${user.name})` : '');
                  } else {
                    ddInput.value = value;
                  }
                } else {
                  ddInput.value = '';
                  ddInput.placeholder = '— None —';
                }
              }
            }
          });
        });
        bulkTabGlobalListenersAttached = true;
      }
      
      // Keyboard navigation
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isOpen) {
          closeDropdown();
        }
      });
    }

    function updateBulkTabCounter() {
      const counter = document.getElementById('bulkTabCounter');
      
      // ⚡ CRITICAL BUG FIX: Check if counter exists
      if (!counter) {
        console.warn('⚠️ Bulk tab counter element not found');
        return;
      }
      
      // Count how many participants will have tabs after all changes
      let totalWithTabs = 0;
      appState.participants.forEach((p, index) => {
        const finalValue = bulkTabChanges[index] !== undefined 
          ? bulkTabChanges[index] 
          : (p.tabbed || '');
        if (finalValue) totalWithTabs++;
      });
      
      const changedCount = Object.keys(bulkTabChanges).length;
      const displayText = changedCount > 0 
        ? `📊 ${totalWithTabs} tabs assigned (${changedCount} changed)`
        : `📊 ${totalWithTabs} tabs assigned`;
      
      counter.textContent = displayText;
    }

    async function saveBulkTabChanges() {
      // Apply all changes to appState
      for (const [index, value] of Object.entries(bulkTabChanges)) {
        const idx = parseInt(index);
        // ⚡ CRITICAL BUG FIX: Validate index is valid before array access
        if (isNaN(idx)) continue;
        if (appState.participants[idx]) {
          appState.participants[idx].tabbed = value || null;
        }
      }
      
      // ⚡ CRITICAL BUG FIX: Invalidate sort cache when tabbed changes (affects 'tabbed' column sort)
      if (typeof invalidateSortCache === 'function') {
        invalidateSortCache();
      }
      
      // Save to database
      await saveState();
      
      // Rebuild table to show changes
      await rebuildTable();
      
      // Close modal
      closeBulkTabModal();
      
      // Show success toast
      const changeCount = Object.keys(bulkTabChanges).length;
      showToast('Tab Assignments Updated', [`${changeCount} participant${changeCount !== 1 ? 's' : ''} updated`]);
      
      // Refresh summary to show updated counts
      if (typeof populateSummary === 'function') {
        populateSummary();
      }
    }

    function closeBulkTabModal() {
      const modal = document.getElementById('bulkTabModal');
      // ⚡ CRITICAL BUG FIX: Check if modal exists before accessing
      if (!modal) {
        console.warn('⚠️ Bulk tab modal not found');
        return;
      }
      
      // ⚡ BUG FIX: Close all open dropdowns before closing modal
      const openDropdowns = modal.querySelectorAll('.searchable-dropdown-list.show');
      openDropdowns.forEach(list => {
        list.classList.remove('show');
        const dropdown = list.closest('.searchable-dropdown');
        if (dropdown) {
          const input = dropdown.querySelector('.searchable-dropdown-input');
          if (input) {
            input.setAttribute('readonly', 'readonly');
          }
        }
      });
      
      modal.classList.remove('show');
      bulkTabChanges = {};
    }

    // Initialize modal handlers
    (function() {
      const modal = document.getElementById('bulkTabModal');
      const cancelBtn = document.getElementById('bulkTabCancelBtn');
      const saveBtn = document.getElementById('bulkTabSaveBtn');
      const search = document.getElementById('bulkTabSearch');
      
      if (cancelBtn) {
        cancelBtn.addEventListener('click', closeBulkTabModal);
      }
      
      if (saveBtn) {
        saveBtn.addEventListener('click', saveBulkTabChanges);
      }
      
      if (search) {
        search.addEventListener('input', (e) => {
          renderBulkTabList(e.target.value);
        });
      }
      
      // ❌ REMOVED: Click outside to close - users must click Cancel button
      // if (modal) {
      //   modal.addEventListener('click', (e) => {
      //     if (e.target === modal) closeBulkTabModal();
      //   });
      // }
      
      // Click any tabbed cell to open modal
      document.addEventListener('click', (e) => {
        if (e.target.classList.contains('tabbed-cell-display')) {
          openBulkTabModal();
        }
      });
      
      // ❌ REMOVED: Escape key to close - users must click Cancel button
      // document.addEventListener('keydown', (e) => {
      //   if (e.key === 'Escape' && modal && modal.classList.contains('show')) {
      //     closeBulkTabModal();
      //   }
      // });
    })();

    // ============ CLEAR IDS BUTTON ============
    const clearIdsBtn = document.getElementById("clearIdsBtn");
    if (clearIdsBtn) {
      clearIdsBtn.addEventListener("click", async () => {
        if (!appState.activeRaffleId) {
          showRestrictionModal(`No active raffle found.`);
          return;
        }

        try {
          // Call backend to clear processed PayPal transaction records
          const response = await fetch('/api/paypal/clear', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              raffle_id: appState.activeRaffleId
            })
          });

          // ⚡ CRITICAL BUG FIX: Check response.ok before calling .json()
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const result = await response.json();

          if (!result.ok) {
            showRestrictionModal(`Failed to clear email records.<br><br>${result.error || 'Unknown error'}`);
            return;
          }

          const details = [
            `🗑️ ${result.deleted} email records cleared`,
            `🔄 Emails can now be rescanned`,
            '💡 Previous payments can be matched again'
          ];
          showToast('Email IDs Cleared!', details);

        } catch (error) {
          console.error('Clear IDs error:', error);
          showRestrictionModal(`Failed to clear records.<br><br>${error.message}`);
        }
      });
    }

    // ============ MARK PAID MODAL ============
    let markPaidChanges = {}; // Temporary storage for unsaved changes
    let markPaidGlobalListenersAttached = false; // Prevent duplicate document-level listeners

    function openMarkPaidModal() {
      const modal = document.getElementById('markPaidModal');
      const search = document.getElementById('markPaidSearch');
      const listContainer = document.getElementById('markPaidList');
      
      // Check if setup is complete first
      if (!appState.redditLink || !appState.costPerSpot || appState.totalSpots === null) {
        showRestrictionModal(`Setup is incomplete.<br>Please configure Reddit Link, Total Spots, and Cost Per Spot before marking payments.`);
        return;
      }
      
      // Reset changes
      markPaidChanges = {};
      
      // Clear search
      if (search) {
        search.value = '';
      }
      
      // Render participant list
      renderMarkPaidList();
      
      // Show modal
      if (modal) {
        modal.classList.add('show');
      }
    }

    function renderMarkPaidList(searchTerm = '') {
      const listContainer = document.getElementById('markPaidList');
      const counter = document.getElementById('markPaidCounter');
      const participantCount = document.getElementById('markPaidParticipantCount');
      
      if (!listContainer) return;
      
      // ✅ GROUP PARTICIPANTS BY USERNAME - Combine duplicate entries
      const userGroups = new Map();
      appState.participants.forEach((p, index) => {
        if ((p.spots || 0) === 0) return; // Skip waitlist
        
        const user = p.redditUser;
        if (!userGroups.has(user)) {
          userGroups.set(user, {
            redditUser: user,
            totalSpots: 0,
            totalOwed: 0,
            allPaid: true,
            indices: [],
            tabComments: [],
            nonTabComments: []
          });
        }
        
        const group = userGroups.get(user);
        group.totalSpots += p.spots || 0;
        group.totalOwed += parseFloat(p.owed) || 0;
        group.indices.push(index);
        
        // Check if this entry is paid
        const isPaid = markPaidChanges.hasOwnProperty(index) ? markPaidChanges[index] : (p.paid || false);
        if (!isPaid) {
          group.allPaid = false;
        }
        
        // Categorize comments
        const comment = p.comment || '';
        const commentLower = comment.toLowerCase();
        const isTab = commentLower && (
          commentLower.includes('tab') ||
          commentLower.includes('tabbed') ||
          commentLower.includes('wff')
        );
        
        if (comment) {
          if (isTab) {
            group.tabComments.push(comment);
          } else {
            group.nonTabComments.push(comment);
          }
        }
      });
      
      // Convert to array and filter by search term
      const userArray = Array.from(userGroups.values());
      const filteredUsers = userArray.filter((group) => {
        if (!searchTerm) return true;
        
        const search = searchTerm.toLowerCase();
        const username = (group.redditUser || '').toLowerCase();
        const allComments = [...group.tabComments, ...group.nonTabComments].join(' ').toLowerCase();
        const status = group.allPaid ? 'paid' : 'unpaid';
        
        return username.includes(search) || allComments.includes(search) || status.includes(search);
      });
      
      // Update participant count
      if (participantCount) {
        participantCount.textContent = `${filteredUsers.length} participant${filteredUsers.length !== 1 ? 's' : ''}`;
      }
      
      // Render list
      listContainer.innerHTML = filteredUsers.map((group) => {
        const isPaid = group.allPaid;
        const statusClass = isPaid ? 'status-paid' : 'status-unpaid';
        const statusText = isPaid ? 'Paid' : 'Unpaid';
        const itemClass = isPaid ? 'mark-paid-item paid' : 'mark-paid-item';
        
        // ✅ Show ALL comments separately (each on new line)
        let commentHTML = '';
        const allComments = [];
        
        // Add TAB comments with badges
        if (group.tabComments.length > 0) {
          group.tabComments.forEach(comment => {
            allComments.push(`<span class=\"tab-badge\">TAB</span> ${escapeHtml(comment)}`);
          });
        }
        
        // Add non-TAB comments (no badge, just plain)
        if (group.nonTabComments.length > 0) {
          group.nonTabComments.forEach(comment => {
            allComments.push(escapeHtml(comment));
          });
        }
        
        commentHTML = allComments.join('<br>');
        
        // Store all indices as comma-separated string for click handler
        const indicesStr = group.indices.join(',');
        
        return `
          <div class=\"${itemClass}\" data-indices=\"${indicesStr}\">
            <div class=\"mark-paid-item-left\">
              <span class=\"mark-paid-user\">${escapeHtml(group.redditUser || '')}</span>
              <span class=\"mark-paid-spots\">${group.totalSpots} spot${group.totalSpots !== 1 ? 's' : ''}</span>
              ${commentHTML ? `<span class=\"mark-paid-comment\">${commentHTML}</span>` : ''}
            </div>
            <div style=\"display: flex; align-items: center; gap: 12px;\">
              <span class=\"mark-paid-owed\">$${group.totalOwed.toFixed(2)}</span>
              <span class=\"mark-paid-status ${statusClass}\">${statusText}</span>
            </div>
          </div>
        `;
      }).join('');
      
      // Update counter - Count unique USERS who are paid, not individual entries
      // ✅ BUG FIX: Counter now matches the grouped display
      const paidUsers = userArray.filter(group => group.allPaid).length;
      
      if (counter) {
        counter.textContent = `💵 ${paidUsers} participant${paidUsers !== 1 ? 's' : ''} marked as paid`;
      }
      
      // Attach click listeners to toggle paid status
      if (!markPaidGlobalListenersAttached) {
        listContainer.addEventListener('click', (e) => {
          const item = e.target.closest('.mark-paid-item');
          if (!item) return;
          
          // ✅ Get all indices for this user (may be multiple entries)
          const indicesStr = item.dataset.indices;
          if (!indicesStr) return;
          
          const indices = indicesStr.split(',').map(i => parseInt(i)).filter(idx => !isNaN(idx)); // ⚡ CRITICAL BUG FIX: Filter out NaN values
          
          // ✅ Determine current status (all must be paid for group to show as paid)
          const allPaid = indices.every(index => {
            const participant = appState.participants[index];
            if (!participant) return false;
            return markPaidChanges.hasOwnProperty(index) ? markPaidChanges[index] : (participant.paid || false);
          });
          
          // ✅ Toggle all entries for this user
          const newStatus = !allPaid;
          indices.forEach(index => {
            markPaidChanges[index] = newStatus;
          });
          
          // Re-render list to show changes
          const searchInput = document.getElementById('markPaidSearch');
          renderMarkPaidList(searchInput ? searchInput.value : '');
        });
        
        markPaidGlobalListenersAttached = true;
      }
    }
    
    async function saveMarkPaidChanges() {
      // Apply all changes to appState
      for (const [index, isPaid] of Object.entries(markPaidChanges)) {
        const idx = parseInt(index);
        // ⚡ CRITICAL BUG FIX: Validate index is valid before array access
        if (isNaN(idx)) continue;
        if (appState.participants[idx]) {
          appState.participants[idx].paid = isPaid;
        }
      }
      
      // Send update to backend
      try {
        await saveState();
      } catch (error) {
        console.error('Failed to save paid status changes:', error);
        showErrorToast('Failed to Save', ['Could not update payment statuses']);
        return;
      }
      
      // ✅ Update table row styling WITHOUT rebuilding entire table
      const tbody = document.getElementById('participantsTbody');
      if (tbody) {
        for (const [index, isPaid] of Object.entries(markPaidChanges)) {
          const idx = parseInt(index);
          // ⚡ CRITICAL BUG FIX: Validate index is valid before array access
          if (isNaN(idx)) continue;
          const participant = appState.participants[idx];
          
          if (participant) {
            // Find the row by data-index attribute
            const row = tbody.querySelector(`tr[data-index="${idx}"]`);
            if (row) {
              const spots = participant.spots || 0;
              
              // Update row styling based on paid status
              if (isPaid && spots > 0) {
                row.classList.remove('unpaid-row');
                row.classList.add('paid-row');
              } else if (!isPaid && spots > 0) {
                row.classList.remove('paid-row');
                row.classList.add('unpaid-row');
              } else {
                // 0 spots = waitlist (no background color)
                row.classList.remove('paid-row', 'unpaid-row');
              }
              
              // ✅ BUG FIX #18: Update Status column cell (data-col="7") text
              const statusCell = row.querySelector('td:nth-child(8)'); // Status is 8th td (column index 7)
              if (statusCell) {
                const statusDot = statusCell.querySelector('.status-dot');
                if (statusDot) {
                  // Update dot class
                  statusDot.classList.remove('dot-paid', 'dot-pending');
                  statusDot.classList.add(isPaid ? 'dot-paid' : 'dot-pending');
                }
              }
              
              // ✅ BUG FIX #18: Update Paid? column cell (data-col="6") text
              const paidCell = row.querySelector('td:nth-child(7)'); // Paid? is 7th td (column index 6)
              if (paidCell) {
                const paidDisplay = paidCell.querySelector('.paid-cell-display');
                if (paidDisplay) {
                  paidDisplay.classList.remove('paid-cell-paid', 'paid-cell-unpaid');
                  paidDisplay.classList.add(isPaid ? 'paid-cell-paid' : 'paid-cell-unpaid');
                  paidDisplay.textContent = isPaid ? '✓ Paid' : '— Unpaid —';
                }
              }
            }
          }
        }
      }
      
      // Update stats and footer (no table rebuild needed)
      updateStats();
      updateFooter();
      
      // Count how many unique USERS were changed (not individual entries)
      // ✅ BUG FIX: Count unique users, matching what user sees in modal
      const changedUsers = new Set();
      const paidUsers = new Set();
      
      for (const [index, isPaid] of Object.entries(markPaidChanges)) {
        const idx = parseInt(index);
        // ⚡ CRITICAL BUG FIX: Validate index is valid before array access
        if (isNaN(idx)) continue;
        const participant = appState.participants[idx];
        if (participant) {
          changedUsers.add(participant.redditUser);
          if (isPaid) {
            paidUsers.add(participant.redditUser);
          }
        }
      }
      
      const changedCount = changedUsers.size;
      const paidCount = paidUsers.size;
      
      console.log(`💰 Payment status update: ${changedCount} participants changed, ${paidCount} marked as paid`);
      
      if (changedCount > 0) {
        showToast('Payment Status Updated', [
          `✓ ${changedCount} participant${changedCount !== 1 ? 's' : ''} updated`,
          `💰 ${paidCount} marked as paid`
        ]);
      } else {
        // ⚡ CRITICAL BUG FIX: Show message when no changes were made
        showToast('No Changes', ['No payment status changes to save']);
      }
      
      // ⚡ CRITICAL BUG FIX: Delay modal close to ensure toast is visible
      setTimeout(() => {
        closeMarkPaidModal();
      }, 100);
    }

    function closeMarkPaidModal() {
      const modal = document.getElementById('markPaidModal');
      if (!modal) {
        console.warn('⚠️ Mark paid modal not found');
        return;
      }
      
      modal.classList.remove('show');
      markPaidChanges = {};
    }

    // Initialize modal handlers
    (function() {
      const modal = document.getElementById('markPaidModal');
      const cancelBtn = document.getElementById('markPaidCancelBtn');
      const saveBtn = document.getElementById('markPaidSaveBtn');
      const search = document.getElementById('markPaidSearch');
      
      if (cancelBtn) {
        cancelBtn.addEventListener('click', closeMarkPaidModal);
      }
      
      if (saveBtn) {
        saveBtn.addEventListener('click', async () => {
          // ⚡ CRITICAL BUG FIX: Await async function to ensure proper error handling
          await saveMarkPaidChanges();
        });
      }
      
      if (search) {
        search.addEventListener('input', (e) => {
          renderMarkPaidList(e.target.value);
        });
      }
      
      // ❌ REMOVED: Click outside to close - users must click Cancel button
      // if (modal) {
      //   modal.addEventListener('click', (e) => {
      //     if (e.target === modal) closeMarkPaidModal();
      //   });
      // }
      
      // ❌ REMOVED: Escape key to close - users must click Cancel button
      // document.addEventListener('keydown', (e) => {
      //   if (e.key === 'Escape' && modal && modal.classList.contains('show')) {
      //     closeMarkPaidModal();
      //   }
      // });
    })();

    // ============ MARK ALL PAID BUTTON ============
    const markAllPaidBtn = document.getElementById("markAllPaidBtn");
    if (markAllPaidBtn) {
      markAllPaidBtn.addEventListener("click", async () => {
      // Check if setup is complete first
      if (!appState.redditLink || !appState.costPerSpot || appState.totalSpots === null) {
        showRestrictionModal(`Setup is incomplete.<br>Please configure Reddit Link, Total Spots, and Cost Per Spot before marking payments.`);
        return;
      }

      // ✅ Exclude Waitlist participants (0 spots) from stats and marking
      // ⚡ OPTIMIZED: Calculate stats in single pass (no filter needed - check inline)
      let pendingCount = 0;
      let totalAmount = 0;
      
      appState.participants.forEach(p => {
        if ((p.spots || 0) > 0) {
          totalAmount += (p.owed || 0);
          if (!p.paid) {
            pendingCount++;
          }
        }
      });

      // ✅ Only mark raffle participants (spots > 0) as paid, not Waitlist participants
      appState.participants.forEach(p => {
        if ((p.spots || 0) > 0) {
          p.paid = true;
        }
      });
      await saveState();

      // Rebuild table to reflect changes
      await rebuildTable();
      updateStats();
      updateFooter();

      const details = [
        `✓ ${pendingCount} participants marked as paid`,
        `💰 Total confirmed: $${totalAmount.toLocaleString()}`,
        '🎉 All payments complete!'
      ];
      showToast('Payments Updated!', details);
      });
    }

    // ============ PAID CELL CLICK HANDLER (OPENS MODAL) ============
    function attachPaidCellListeners() {
      // ⚡ CRITICAL BUG FIX: Only attach once using window-level flag to prevent memory leaks
      if (!window.paidCellListenerAttached) {
        document.addEventListener('click', (e) => {
          if (e.target.classList.contains('paid-cell-display')) {
            // Check if setup is complete first
            if (!appState.redditLink || !appState.costPerSpot || appState.totalSpots === null) {
              showRestrictionModal(`Setup is incomplete.<br>Please configure Reddit Link, Total Spots, and Cost Per Spot before marking payments.`);
              return;
            }
            
            // Open the Mark Paid modal
            openMarkPaidModal();
          }
        });
        window.paidCellListenerAttached = true;
      }
    }

    // Initialize paid cell listeners
    attachPaidCellListeners();

    // ============ SEARCH & FILTER ============
    // Debounced search - waits 300ms after user stops typing before filtering
    const debouncedSearch = debounce(filterAndSearch, 300);
    const participantSearchEl = document.getElementById("participantSearch");
    const paymentFilterEl = document.getElementById("paymentFilter");
    if (participantSearchEl) participantSearchEl.addEventListener("input", debouncedSearch);
    if (paymentFilterEl) paymentFilterEl.addEventListener("change", filterAndSearch);

    // ============ TABLE SORTING ============
    // Sorting is enabled for Comment (chronological), Spots, and Paid columns (defined in HTML)

    document.querySelectorAll('.p-table thead th.sortable').forEach(th => {
      th.addEventListener('click', (e) => {
        // Don't sort if clicking on the column resizer
        if (e.target.classList.contains('col-resizer')) {
          return;
        }
        const sortColumn = th.dataset.sort;
        if (sortColumn) {
          sortTable(sortColumn);
        }
      });
    });

    // ============ KEYBOARD SHORTCUTS: CTRL + F, CTRL + R ============
    document.addEventListener("keydown", (e) => {
      // Check if CTRL + F (or CMD + F on Mac)
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault(); // Prevent browser's default find
        const searchInput = document.getElementById("participantSearch");
        if (searchInput) {
          searchInput.focus();
          searchInput.select(); // Select all text in the search box
        }
      }
      
      // Check if CTRL + R (or CMD + R on Mac) - Refresh page
      if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault(); // Prevent default to control the reload
        location.reload(); // Refresh the page
      }
    });

    // ============ TOAST CLOSE ============
    const toastCloseBtn = document.getElementById("toastClose");
    const successToast = document.getElementById("successToast");
    if (toastCloseBtn && successToast) {
      toastCloseBtn.addEventListener("click", () => {
        successToast.classList.remove("show");
      });
    }

    const errorToastCloseBtn = document.getElementById("errorToastClose");
    const errorToast = document.getElementById("errorToast");
    if (errorToastCloseBtn && errorToast) {
      errorToastCloseBtn.addEventListener("click", () => {
        errorToast.classList.remove("show");
      });
    }

    // ============ TABBED COLUMN PERSISTENCE ============
    function saveTabbedColumnVisibility(isVisible) {
      try {
        localStorage.setItem('raffleui_tabbed_column_visible', isVisible ? '1' : '0');
      } catch (e) {
        console.error('Failed to save tabbed column visibility:', e); // ⚡ CRITICAL BUG FIX: Prevent crash on quota exceeded
      }
    }

    function loadTabbedColumnVisibility() {
      const saved = localStorage.getItem('raffleui_tabbed_column_visible');
      return saved === null ? true : saved === '1'; // Default to visible
    }

    function applyTabbedColumnVisibility(isVisible) {
      const table = document.getElementById('participantsTable');
      if (!table) return;

      // Update colgroup
      const colTabbed = table.querySelector('.col-tabbed');
      if (colTabbed) {
        colTabbed.style.display = isVisible ? '' : 'none';
      }

      // Update header
      const thTabbed = table.querySelector('th[data-col="2"]');
      if (thTabbed) {
        thTabbed.style.display = isVisible ? '' : 'none';
      }

      // Update all body cells in the Tabbed column
      const tabbedCells = table.querySelectorAll('tbody tr td:nth-child(3)');
      tabbedCells.forEach(cell => {
        cell.style.display = isVisible ? '' : 'none';
      });
    }

    // ============ INITIALIZE ============
    (async function init() {
      // ✅ Initialize window.allTabbedUsers to prevent dropdown errors
      if (!window.allTabbedUsers) {
        window.allTabbedUsers = [];
      }

      // Initialize user cache FIRST
      await API.initUser();

      // Load state (now with user cached)
      await loadState();

      // ✅ Restore tabbed column visibility
      const tabbedVisible = loadTabbedColumnVisibility();
      applyTabbedColumnVisibility(tabbedVisible);

      // Defer heavy operations slightly to let the page render
      requestAnimationFrame(() => {
        updateStats();
        updateFooter();

        // Start auto-polling after a short delay to avoid blocking initial render
        setTimeout(() => {
          startAutoPolling();
        }, 100);
      });
    })();

    // ============ CLEANUP ON PAGE UNLOAD ============
    // ⚡ Prevent memory leaks by clearing all intervals when user navigates away
    window.addEventListener('beforeunload', () => {
      // Clear polling interval
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      
      // Clear fast raffle timer
      if (fastRaffleTimerInterval) {
        clearInterval(fastRaffleTimerInterval);
        fastRaffleTimerInterval = null;
      }
      
      // Clear poll countdown timer
      if (pollCountdownInterval) {
        clearInterval(pollCountdownInterval);
        pollCountdownInterval = null;
      }
    });

    // ⚡ Invalidate name mapping cache when user returns to page (e.g., from Settings)
    document.addEventListener('visibilitychange', function() {
      if (!document.hidden) {
        // User returned to this page - invalidate cache in case they edited names in Settings
        invalidateNameMappingCache();
        console.log('👁️ Page visible - name mapping cache invalidated');
      }
    });

    // ============ AUTO-POLLING REDDIT SCAN ============
    let pollingInterval = null;
    let isScanning = false;

    async function performAutoScan() {
      // Prevent concurrent scans
      if (isScanning) {
        console.log('⚠️ Scan already in progress, skipping...');
        return;
      }

      // Only scan if Reddit link and cost per spot are configured
      if (!appState.redditLink || !appState.costPerSpot) {
        return;
      }

      isScanning = true;

      // Validate Reddit URL format before scanning
      const redditRegex = /^https?:\/\/(www\.)?(reddit\.com|old\.reddit\.com)\/r\/[^\/]+\/comments\/[^\/]+\/[^\/]+\/?/i;
      if (!redditRegex.test(appState.redditLink)) {
        console.error('❌ Invalid Reddit URL format detected. Auto-scan skipped.');
        isScanning = false;  // ⚡ CRITICAL BUG FIX: Reset flag to prevent permanent lock!
        return;
      }

      // Auto-scanning Reddit for new comments

      try {
        // ✅ OPTIMIZATION: Build participantStatuses map for intelligent re-scanning
        // Maps commentId -> status to separate confirmed/waitlist (skip) from tab_pending (re-scan)
        const participantStatuses = {};
        const existingCommentIds = [];
        
        // ⚡ OPTIMIZED: Count statuses in a single pass while building the map
        let confirmedCount = 0;
        let waitlistCount = 0;
        let tabPendingCount = 0;
        
        appState.participants.forEach(p => {
          if (p.commentId) {
            existingCommentIds.push(p.commentId);
            
            if (p.status) {
              participantStatuses[p.commentId] = p.status;
              
              // Count statuses
              if (p.status === 'confirmed') confirmedCount++;
              else if (p.status === 'waitlist') waitlistCount++;
              else if (p.status === 'tab_pending') tabPendingCount++;
            }
          }
        });
        
        console.log(`📊 Participant statuses: ${confirmedCount} confirmed, ${waitlistCount} waitlist, ${tabPendingCount} tab_pending`);
        console.log(`🔄 Will re-scan ${tabPendingCount} tab_pending comments for host replies`);

        // Calculate current assigned spots to prevent overfilling
        // ✅ FIX: Only count CONFIRMED participants (tab_pending and waitlist have 0 spots)
        const currentAssignedSpots = appState.participants
          .filter(p => p.status === 'confirmed')
          .reduce((sum, p) => sum + (parseInt(p.spots) || 0), 0);
        console.log(`📊 Current assigned spots: ${currentAssignedSpots}/${appState.totalSpots || 'unlimited'}`);

        const result = await API.scanReddit(appState.redditLink, appState.costPerSpot, appState.totalSpots, existingCommentIds, currentAssignedSpots, participantStatuses);

        if (!result.ok) {
          console.error('Auto-scan failed:', result.error);
          isScanning = false; // ⚡ CRITICAL BUG FIX: Reset flag on error!
          return;
        }

        const newParticipants = result.participants || [];

        if (newParticipants.length === 0) {
          isScanning = false; // ⚡ CRITICAL BUG FIX: Reset flag when no new participants!
          return;
        }

        // Log comment IDs for parsing verification
        console.log('🔄 Parsing - New participants from Reddit:', newParticipants.length);
        console.log('🔄 Parsing - New comment IDs:', newParticipants.map(p => p.commentId));

        // ✅ Handle BOTH new participants AND updates to existing tab_pending participants
        // ⚡ FIX: Filter out empty/null commentIds to prevent duplicates
        const existingCommentIdsSet = new Set(existingCommentIds.filter(id => id));
        
        // ⚡ CRITICAL FIX: Pre-build commentId->index map to avoid O(n*m) findIndex calls
        // For 10 new participants checking against 100 existing: Was 10*100=1,000 ops, now 100+10=110 ops = 90% faster!
        const commentIdIndexMap = new Map();
        appState.participants.forEach((p, idx) => {
          if (p.commentId) {
            commentIdIndexMap.set(p.commentId, idx);
          }
        });
        
        const trulyNewParticipants = [];
        let updatedCount = 0;
        
        for (const newP of newParticipants) {
          // Skip if commentId is empty/null (prevent duplicates)
          if (!newP.commentId) continue;
          
          if (existingCommentIdsSet.has(newP.commentId)) {
            // This comment already exists - check if it needs updating (tab_pending -> confirmed)
            const existingIndex = commentIdIndexMap.get(newP.commentId);
            if (existingIndex !== undefined && appState.participants[existingIndex]) { // ⚡ CRITICAL BUG FIX: Bounds check!
              const existing = appState.participants[existingIndex];
              
              // ⚡ CRITICAL BUG FIX: Don't overwrite manually edited spots with Reddit data
              // If user manually gave waitlist participant spots (0→N), preserve that edit
              const existingSpots = existing.spots || 0;
              const newSpots = newP.spots || 0;
              
              // Only update if Reddit shows MORE spots (host replied) or status changed
              // Skip if spots would decrease (prevents overwriting manual edits)
              const shouldUpdate = (existing.status !== newP.status) || (newSpots > existingSpots);
              
              if (shouldUpdate) {
                console.log(`🔄 Updating participant u/${newP.redditUser}: ${existing.status} (${existingSpots} spots) → ${newP.status} (${newSpots} spots)`);
                
                // ⚡ CRITICAL BUG FIX: Preserve user-customized fields when updating from Reddit
                appState.participants[existingIndex] = {
                  ...newP,
                  paid: existing.paid,         // Preserve paid status (user toggled)
                  name: existing.name,         // Preserve custom name (user edited)
                  tabbed: existing.tabbed,     // Preserve tab assignment (user selected)
                  sequenceNumber: existing.sequenceNumber,  // ⚡ CRITICAL: Preserve order position!
                  spots: newSpots > existingSpots ? newSpots : existingSpots  // Preserve manual edits (never decrease)
                };
                updatedCount++;
              }
            }
          } else {
            // Truly new participant
            trulyNewParticipants.push(newP);
          }
        }

        console.log(`🔄 Parsing - Filtered: ${trulyNewParticipants.length} new, ${updatedCount} updated`);

        if (trulyNewParticipants.length === 0 && updatedCount === 0) {
          isScanning = false; // ⚡ CRITICAL BUG FIX: Reset flag when nothing to update!
          return;
        }

        // Add only NEW participants (prepend in correct order so newest appear at top)
        // trulyNewParticipants is already sorted newest-first from the parser
        if (trulyNewParticipants.length > 0) {
          // ⚡ CRITICAL FIX: Assign sequence numbers to preserve order across page refreshes
          // Find the lowest existing sequence number
          const minExistingSeq = appState.participants.length > 0 
            ? Math.min(...appState.participants.map(p => p.sequenceNumber !== undefined ? p.sequenceNumber : 999999))
            : 0;
          
          // Assign decreasing sequence numbers to new participants (newest gets lowest number)
          trulyNewParticipants.forEach((p, index) => {
            p.sequenceNumber = minExistingSeq - trulyNewParticipants.length + index;
          });
          
          console.log(`📊 Assigned sequence numbers ${minExistingSeq - trulyNewParticipants.length} to ${minExistingSeq - 1} to ${trulyNewParticipants.length} new participants`);
          
          appState.participants.unshift(...trulyNewParticipants);
          
          // ⚡ Invalidate sort cache since participants changed
          invalidateSortCache();
          
          // ⚡ CRITICAL BUG FIX: Update DOM indices IMMEDIATELY to prevent race condition!
          // Between unshift() and insertNewRowsAtTop(), user could click checkbox with wrong index
          const tbody = document.getElementById("participantsTbody");
          if (tbody) {
            const commentIdIndexMap = new Map();
            appState.participants.forEach((p, idx) => {
              if (p.commentId) {
                commentIdIndexMap.set(p.commentId, idx);
              }
            });
            
            const allRows = tbody.querySelectorAll('tr:not(#emptyRow)');
            allRows.forEach(row => {
              const commentId = row.dataset.commentId;
              if (commentId) {
                const correctIndex = commentIdIndexMap.get(commentId);
                if (correctIndex !== undefined) {
                  row.dataset.index = correctIndex;
                  row.querySelectorAll('[data-index]').forEach(el => {
                    el.dataset.index = correctIndex;
                  });
                }
              }
            });
          }
        }

        await saveState();
        
        // ✅ UI Update: If updates occurred, rebuild table; otherwise just insert new rows
        if (updatedCount > 0) {
          console.log('🔄 Rebuilding table to reflect updates...');
          // ⚡ CRITICAL BUG FIX: Skip sync because unshift() shifted all indices!
          // trulyNewParticipants were prepended, so all existing participants moved down
          await rebuildTable(trulyNewParticipants.length > 0);
        } else if (trulyNewParticipants.length > 0) {
          // ✅ OPTIMIZED: Insert new rows at top without rebuilding entire table
          await insertNewRowsAtTop(trulyNewParticipants);
        }
        
        updateStats();
        updateFooter();
        // ✅ Apply default filter after auto-scan (hides Waitlist participants)
        filterAndSearch();

        // Show notification
        const details = [
          `👥 ${trulyNewParticipants.length} new entries found`,
          updatedCount > 0 ? `🔄 ${updatedCount} entries updated` : null,
          `📊 Total entries: ${appState.participants.length}`
        ].filter(Boolean);  // Remove null entries
        showToast('Auto-Scan Complete!', details);

        console.log(`✓ Parsing complete - ${trulyNewParticipants.length} new participants added`);

      } catch (error) {
        console.error('Auto-scan error:', error);
      } finally {
        isScanning = false;
      }
    }

    function startAutoPolling() {
      // GUARD: If polling is already running, don't start another one
      if (pollingInterval) {
        return;
      }

      // Only start polling if setup is configured
      if (!appState.redditLink || !appState.costPerSpot) {
        const indicator = document.getElementById('autoScanIndicator');
        if (indicator) indicator.style.display = 'none';
        try {
          localStorage.setItem(getUserLocalStorageKey('autoPollingActive'), 'false');
        } catch (e) {
          console.error('Failed to save polling state:', e); // ⚡ CRITICAL BUG FIX: Prevent crash on quota exceeded
        }
        return;
      }

      // Show indicator
      const indicator = document.getElementById('autoScanIndicator');
      if (indicator) indicator.style.display = 'inline-flex';

      // Mark polling as active in localStorage so other pages know (user-specific)
      try {
        localStorage.setItem(getUserLocalStorageKey('autoPollingActive'), 'true');
        localStorage.setItem(getUserLocalStorageKey('autoPollingRaffleId'), appState.activeRaffleId);
      } catch (e) {
        console.error('Failed to save polling state:', e); // ⚡ CRITICAL BUG FIX: Prevent crash on quota exceeded
      }

      // Start polling every 5 seconds (5000ms)
      pollingInterval = setInterval(() => {
        performAutoScan();
        resetPollCountdown();
      }, 5000);

      // Start countdown timer
      startPollCountdown();
    }

    function stopAutoPolling() {
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      const indicator = document.getElementById('autoScanIndicator');
      if (indicator) indicator.style.display = 'none';

      // Stop countdown timer
      if (typeof stopPollCountdown === 'function') {
        stopPollCountdown();
      }

      // Mark polling as inactive in localStorage
      try {
        localStorage.setItem(getUserLocalStorageKey('autoPollingActive'), 'false');
      } catch (e) {
        console.error('Failed to save polling state:', e); // ⚡ CRITICAL BUG FIX: Prevent crash on quota exceeded
      }
    }

    // Don't stop polling when navigating away - let it run in background
    // window.addEventListener('beforeunload', stopAutoPolling);

    // Restart polling when setup is saved
    const originalSaveBtn = document.getElementById("modalSaveBtn");
    if (originalSaveBtn) {
      originalSaveBtn.addEventListener("click", () => {
        setTimeout(() => {
          startAutoPolling();
        }, 500);
      });
    }

    // ===== CHECK AND RESUME POLLING ON PAGE LOAD =====
    (function() {
      // Wait for page to fully load and appState to be populated
      setTimeout(() => {
        const isPollingActive = localStorage.getItem(getUserLocalStorageKey('autoPollingActive')) === 'true';
        const savedRaffleId = localStorage.getItem(getUserLocalStorageKey('autoPollingRaffleId'));

        // If polling was active and we have the same raffle loaded
        // ⚡ CRITICAL BUG FIX: Use === with String() conversion (savedRaffleId is string, activeRaffleId could be number)
        if (isPollingActive && savedRaffleId && String(appState.activeRaffleId) === savedRaffleId) {
          startAutoPolling();
        }
      }, 1000);
    })();

    // ===== LISTEN FOR BACKGROUND SCAN EVENTS =====
    window.addEventListener('backgroundScanComplete', async (event) => {
      console.log('🔔 Background scan completed on another page. Reloading data...');

      // Reload participant data
      await loadState();

      // Show subtle notification
      const details = [
        `👥 ${event.detail.newCount} new participant(s) found`,
        `💜 Scanned while you were away`
      ];
      showToast('Auto-Scan Complete!', details);
    });

        // ===== AUTO-OPEN SETUP MODAL FROM DASHBOARD =====
(function() {
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('setup') === 'open') {
    // Wait for page to fully load
    setTimeout(() => {
      const setupBtn = document.getElementById('setupBtn');
      if (setupBtn) {
        setupBtn.click();
      }
    }, 500);

    // Clean URL (remove ?setup=open)
    window.history.replaceState({}, document.title, '/active-raffle');
  }
})();

// ===== ACCESS DENIED MODAL =====
function showAccessDenied() {
  const overlay = document.getElementById('accessDeniedOverlay');
  if (!overlay) {
    showErrorToast('Access Denied', ['Admins only']);
    return;
  }
  overlay.classList.add('show');
  document.body.style.overflow = 'hidden';
}

function closeAccessDenied(event) {
  if (!event || event.target === document.getElementById('accessDeniedOverlay')) {
    const overlay = document.getElementById('accessDeniedOverlay');
    if (overlay) {
      overlay.classList.remove('show');
      document.body.style.overflow = '';
    }
  }
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const overlay = document.getElementById('accessDeniedOverlay');
    if (overlay && overlay.classList.contains('show')) {
      closeAccessDenied({ target: overlay });
    }
  }
});

// ============ FAST RAFFLE TIMER ============
let fastRaffleTimerInterval = null;

function startFastRaffleTimer() {
  const timerElement = document.getElementById('fastRaffleTimer');
  const displayElement = document.getElementById('timerDisplay');

  if (!timerElement || !displayElement) return;

  // Show the timer
  timerElement.classList.add('active');

  // Clear any existing interval
  if (fastRaffleTimerInterval) {
    clearInterval(fastRaffleTimerInterval);
  }

  function updateTimer() {
    if (!appState.fastRaffleStartTime) {
      stopFastRaffleTimer();
      return;
    }

    // ⚡ CRITICAL BUG FIX: Ensure fastRaffleStartTime is a valid number
    const startTime = parseInt(appState.fastRaffleStartTime);
    if (isNaN(startTime)) {
      console.error('⚠️ Invalid fastRaffleStartTime value');
      stopFastRaffleTimer();
      return;
    }

    // Calculate elapsed time
    const elapsed = Date.now() - startTime;
    const totalDuration = 75 * 60 * 1000; // 1 hour 15 minutes in milliseconds
    const remaining = Math.max(0, totalDuration - elapsed);

    if (remaining === 0) {
      displayElement.textContent = '00:00:00';
      timerElement.classList.add('warning');
      stopFastRaffleTimer();
      return;
    }

    // Convert to hours, minutes, seconds
    const hours = Math.floor(remaining / (60 * 60 * 1000));
    const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
    const seconds = Math.floor((remaining % (60 * 1000)) / 1000);

    // Format as HH:MM:SS
    const formatted =
      String(hours).padStart(2, '0') + ':' +
      String(minutes).padStart(2, '0') + ':' +
      String(seconds).padStart(2, '0');

    displayElement.textContent = formatted;

    // Turn red when under 1 hour
    if (remaining < 60 * 60 * 1000) {
      timerElement.classList.add('warning');
    } else {
      timerElement.classList.remove('warning');
    }
  }

  // Update immediately
  updateTimer();

  // Update every second
  fastRaffleTimerInterval = setInterval(updateTimer, 1000);
}

function stopFastRaffleTimer() {
  const timerElement = document.getElementById('fastRaffleTimer');

  if (fastRaffleTimerInterval) {
    clearInterval(fastRaffleTimerInterval);
    fastRaffleTimerInterval = null;
  }

  if (timerElement) {
    timerElement.classList.remove('active');
    timerElement.classList.remove('warning');
  }

  console.log('⏱️ Fast raffle timer stopped');
}

}

  </script>

  <!-- ACCESS DENIED MODAL -->
  <div class="access-denied-overlay" id="accessDeniedOverlay" onclick="closeAccessDenied(event)">
    <div class="access-denied-modal" onclick="event.stopPropagation()">
      <div class="access-modal-header">
        <div class="access-modal-icon">🔒</div>
        <h2 class="access-modal-title">Access Denied</h2>
        <p class="access-modal-subtitle">Admin privileges required</p>
      </div>
      <div class="access-modal-body">
        <p class="access-modal-message">
          You don't have permission to access this page. This area is restricted to administrators only.
        </p>
        <div class="access-modal-actions">
          <button class="access-modal-btn access-modal-btn-primary" onclick="closeAccessDenied()">
            Got it
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Poll Countdown Timer -->
  <script>
    let pollCountdownInterval = null;
    let pollTimeRemaining = 5; // 5 seconds

    function startPollCountdown() {
      pollTimeRemaining = 5;
      updatePollTimerDisplay();

      if (pollCountdownInterval) {
        clearInterval(pollCountdownInterval);
      }

      pollCountdownInterval = setInterval(() => {
        if (pollTimeRemaining > 0) {
          pollTimeRemaining--;
          updatePollTimerDisplay();
        }
      }, 1000);
    }

    function resetPollCountdown() {
      pollTimeRemaining = 5;
      updatePollTimerDisplay();
    }

    function updatePollTimerDisplay() {
      const timerEl = document.getElementById('nextPollTimer');
      if (timerEl) {
        timerEl.textContent = pollTimeRemaining;
      }
    }

    function stopPollCountdown() {
      if (pollCountdownInterval) {
        clearInterval(pollCountdownInterval);
        pollCountdownInterval = null;
      }
    }
  </script>

</body>
</html>
