<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Active Raffle</title>
<script src="/static/api.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>

  <!-- Dark Mode System -->
  <link rel="stylesheet" href="/static/dark-mode.css" />
  <script src="/static/dark-mode.js"></script>

  <style>
    /* ============================== MASTER LAYOUT VARIABLES ============================== */
    :root{
      --app-width: 100vw;
      --app-height: 100vh;
      --sidebar-width: 252px;
      --content-left: 276px;
      --content-width: calc(100vw - 276px - 20px);
    }

    body{
      background-color:#FAF8F6;
      display:flex;
      justify-content:flex-start;  /* Align left instead of center */
      align-items:flex-start;      /* Align top instead of center */
      height:100vh;
      margin:0;
      font-family:'Inter',sans-serif;
      overflow: hidden;
    }

    .top-sidebar{
      position:absolute; top:0; left:-30px;
      width: calc(var(--sidebar-width) + 30px);
      height:200px;
      clip-path: inset(0 0 0 30px);
      background-image:url('/static/assets/Background/Top-Sidebar.png');
      background-size:cover; background-repeat:no-repeat;
      z-index:5;
    }

    .tako{
      position:absolute;
      top:60px; left:calc(var(--sidebar-width) / 2);
      transform:translate(-50%,-50%);
      width:148px; height:148px;
      background-image:url('/static/assets/Icons/TAKO%201.png');
      background-size:contain;
      background-repeat:no-repeat;
      background-position:center;
      z-index:25;
      pointer-events:none;
    }

    .sidebar{
      position:absolute;
      left:-30px; bottom:0px;
      width: calc(var(--sidebar-width) + 30px);
      clip-path: inset(0 0 0 30px);
      height:900px;
      background-image:url('/static/assets/Background/Sidebar.png');
      background-size:cover;
      background-repeat:no-repeat;
      z-index:10;
    }
      border-bottom-left-radius:30px;
      z-index:10;
    }

    .rectangle{
      position:absolute;
      top:135px; left:0;
      width:165px; height:48px;
      background-image:url('/static/assets/Background/Rectangle.png');
      background-size:cover;
      background-repeat:no-repeat;
      z-index:20;
      pointer-events:none;
    }

    .square{
      position:absolute;
      top:140px; left:30px;
      width:244px; height:52px;
      background-image:url('/static/assets/Background/Square.png');
      background-size:cover;
      background-repeat:no-repeat;
      background-position:center;
      z-index:30;
      pointer-events:none;
      transition:top 140ms ease;
      opacity:0;
    }

    .sidebar-nav{
      position:absolute;
      top:140px; left:55px;
      width:244px;
      font-size:16px;
      line-height:58px;
      z-index:40;
    }

    .sidebar-nav a{
      display:block;
      position:relative;
      padding-left:26px;
      color:#ffffff;
      text-decoration:none;
      font-weight:400;
      user-select:none;
      cursor:pointer;
    }

    .sidebar-nav a.is-active{
      color:#6E5FFC;
      font-weight:600;
    }

    .nav-icon{
      position:absolute;
      left:-5px; top:17px;
      width:20px; height:20px;
      filter:brightness(0) invert(1);
      pointer-events:none;
      z-index:41;
    }

    .sidebar-nav a.is-active .nav-icon{
      filter:brightness(0) saturate(100%) invert(46%) sepia(82%) saturate(2780%) hue-rotate(222deg);
    }

    /* USER SECTION */
    .user-section {
      position: absolute;
      bottom: 20px;
      left: 30px;
      width: 192px;
      z-index: 45;
    }

    /* APP VERSION */
    .app-version {
      position: absolute;
      bottom: 78px;
      left: 30px;
      width: 192px;
      text-align: right;
      font-size: 11px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.4);
      z-index: 45;
      letter-spacing: 0.5px;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .user-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 700;
      color: #fff;
      flex-shrink: 0;
    }

    .user-details {
      flex: 1;
      min-width: 0;
    }

    .user-name {
      font-size: 16px;
      font-weight: 600;
      color: #fff;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .user-role {
      font-size: 13px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.7);
      margin: 2px 0 0 0;
    }

    .logout-btn {
      width: 100%;
      height: 42px;
      border: none;
      border-radius: 10px;
      background: rgba(236, 72, 153, 0.85);
      color: #fff;
      font-size: 15px;
      font-weight: 600;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .logout-btn:hover {
      background: rgba(236, 72, 153, 1);
      transform: translateY(-1px);
    }

    .logout-btn:active {
      transform: translateY(0);
    }

    /* SEARCH BAR */


    /* TOP RIGHT ICONS */
    #themeToggle { position: absolute; top: 20px; right: 130px; width: 44px; height: 24px; cursor: pointer; }
    #settingsBtn { position: absolute; top: 20px; right: 70px; width: 24px; height: 24px; cursor: pointer; }

    /* FAST RAFFLE TIMER */
    .fast-raffle-timer {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #7C3AED 0%, #EC4899 100%);
      color: white;
      padding: 12px 32px;
      border-radius: 12px;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 1px;
      box-shadow: 0 8px 24px rgba(124, 58, 237, 0.35);
      z-index: 100;
      display: none;
      font-variant-numeric: tabular-nums;
    }

    .fast-raffle-timer.active {
      display: block;
    }

    .fast-raffle-timer.warning {
      background: linear-gradient(135deg, #F59E0B 0%, #EF4444 100%);
      box-shadow: 0 8px 24px rgba(239, 68, 68, 0.35);
      animation: pulse-warning 2s ease-in-out infinite;
    }

    @keyframes pulse-warning {
      0%, 100% {
        transform: translateX(-50%) scale(1);
        box-shadow: 0 8px 24px rgba(239, 68, 68, 0.35);
      }
      50% {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 12px 32px rgba(239, 68, 68, 0.5);
      }
    }

    /* STATS */
    .stats-row{
      position:absolute;
      top:60px;
      left:var(--content-left);
      width:var(--content-width);
      display:grid;
      grid-template-columns:repeat(5, 1fr);
      gap:18px;
      z-index:55;
    }

    .stat-card{
      border-radius:16px;
      padding:14px 18px;
      color:#fff;
      box-shadow:0 10px 18px rgba(0,0,0,0.12);
      min-height:78px;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }

    .stat-label{
      font-size:12px;
      letter-spacing:1px;
      font-weight:700;
      text-transform:uppercase;
      opacity:0.9;
      margin-bottom:6px;
    }

    .stat-value{
      font-size:30px;
      font-weight:700;
      line-height:1;
    }

    .c-pink{   background:#ff4fb2; }
    .c-purple{ background:#a855f7; }
    .c-green{  background:#00c26f; }
    .c-orange{ background:#f59e0b; }
    .c-blue{   background:#3b82f6; }

    /* PARTICIPANTS CARD */
    .participants-card{
      position:absolute;
      top:180px;
      left:276px;
      width:calc(100vw - 276px - 20px);
      height:calc(100vh - 180px - 20px);
      background:#ffffff;
      border-radius:0;
      box-shadow:none;
      overflow:hidden;
      z-index:52;
      display:flex;
      flex-direction:column;
    }

    .participants-header{
      padding:20px 28px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:18px;
      border-bottom:3px solid #8b5cf6;
      background:#ffffff;
    }

    .participants-title{
      margin:0;
      font-size:20px;
      font-weight:700;
      color:#1f2937;
    }

    .participants-sub{
      margin-top:6px;
      font-size:13px;
      color:#64748b;
      font-weight:500;
    }

    .table-wrap{
      flex:1;
      overflow-y: auto;
      overflow-x: hidden;
      background:#ffffff;
    }

    .table-wrap::-webkit-scrollbar-track:horizontal {
      display: none;
    }

    .table-wrap::-webkit-scrollbar:horizontal {
      display: none;
      height: 0;
    }

    table.p-table{
      width:100%;
      border-collapse:collapse;
      font-size:13px;
      table-layout:fixed;
    }

    .p-table col.col-reddit  { width:260px; }
    .p-table col.col-name    { width:170px; }
    .p-table col.col-tabbed  { width:180px; }
    .p-table col.col-comment { width:auto;  }
    .p-table col.col-spots   { width:90px;  }
    .p-table col.col-owed    { width:90px;  }
    .p-table col.col-paid    { width:80px;  }
    .p-table col.col-status  { width:120px; }

    .p-table thead th{
      text-align:left;
      padding:10px 28px;
      font-size:10px;
      letter-spacing:1.2px;
      text-transform:uppercase;
      color:#6b7280;
      font-weight:700;
      background:#fafafa;
      position:sticky;
      top:0;
      z-index:1;
      border-bottom:2px solid #e5e7eb;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    /* Sortable header styles */
    .p-table thead th.sortable {
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .p-table thead th.sortable:hover {
      background: #f3f4f6;
    }

    .p-table thead th.sortable .th-inner {
      display: flex;
      align-items: center;
      gap: 6px;
      position: relative;
    }

    .p-table thead th.sortable .sort-indicator {
      display: inline-flex;
      flex-direction: column;
      margin-left: auto;
      opacity: 0.3;
      transition: opacity 0.2s;
    }

    .p-table thead th.sortable:hover .sort-indicator {
      opacity: 0.6;
    }

    .p-table thead th.sortable.sorted-asc .sort-indicator,
    .p-table thead th.sortable.sorted-desc .sort-indicator {
      opacity: 1;
    }

    .p-table thead th .sort-arrow {
      font-size: 8px;
      line-height: 6px;
      color: #6b7280;
    }

    .p-table thead th.sorted-asc .sort-arrow-up {
      color: #8b5cf6;
    }

    .p-table thead th.sorted-desc .sort-arrow-down {
      color: #8b5cf6;
    }

    body.dark-mode .p-table thead th.sortable:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    body.dark-mode .p-table thead th .sort-arrow {
      color: #9ca3af;
    }

    body.dark-mode .p-table thead th.sorted-asc .sort-arrow-up,
    body.dark-mode .p-table thead th.sorted-desc .sort-arrow-down {
      color: #a78bfa;
    }

    /* Center align numeric columns */
    .p-table thead th[data-col="4"],
    .p-table thead th[data-col="5"],
    .p-table thead th[data-col="6"],
    .p-table thead th[data-col="7"] {
      text-align: center;
    }

    .p-table tbody td{
      padding:12px 28px;
      border-bottom:1px solid #f3f4f6;
      vertical-align:middle;
      color:#1f2937;
    }

    /* ============================== UNPAID ROW STYLING ============================== */
    .p-table tbody tr.unpaid-row {
      background: #E9D5FF;
      border-left: none;
      transition: all 0.15s;
    }

    .p-table tbody tr.unpaid-row:hover {
      background: #D8B4FE;
    }

    /* ============================== PAID ROW STYLING ============================== */
    .p-table tbody tr.paid-row {
      background: #BBF7D0;
      border-left: none;
      transition: all 0.15s;
    }

    .p-table tbody tr.paid-row:hover {
      background: #86EFAC;
    }

    /* Dark mode row colors */
    body.dark-mode .p-table tbody tr.unpaid-row {
      background: rgba(168, 85, 247, 0.25);
    }

    body.dark-mode .p-table tbody tr.unpaid-row:hover {
      background: rgba(168, 85, 247, 0.35);
    }

    body.dark-mode .p-table tbody tr.paid-row {
      background: rgba(34, 197, 94, 0.25);
    }

    body.dark-mode .p-table tbody tr.paid-row:hover {
      background: rgba(34, 197, 94, 0.35);
    }

    .user-cell{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:0;
    }

    .avatar{
      width:34px;
      height:34px;
      border-radius:50%;
      display:grid;
      place-items:center;
      color:#fff;
      font-weight:700;
      background:linear-gradient(135deg,#a855f7,#ff4fb2);
      flex-shrink:0;
    }

    .reddit-link{
      color:#6E5FFC;
      text-decoration:none;
      font-weight:600;
    }

    .comment-muted{
      color:#334155;
      font-style:italic;
    }

    .spots-pill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:34px;
      height:26px;
      padding:0 10px;
      border-radius:999px;
      background:#efe9ff;
      color:#6E5FFC;
      font-weight:700;
      font-size:12px;
    }

    .status-chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;

    .tab-badge {
      display: inline-block;
      margin-left: 8px;
      padding: 2px 8px;
      background: #fbbf24;
      color: #78350f;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
    }

    .editable-field:hover {
      background: rgba(139, 92, 246, 0.1);
    }
      font-weight:700;
      font-size:12px;
      white-space:nowrap;
    }

    .status-paid{ background:#dcfce7; color:#166534; }
    .status-pending{ background:#fef3c7; color:#92400e; }

    /* Paid Checkbox Styling */
    .paid-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: #16a34a;
      transform: scale(1.2);
    }

    .paid-checkbox:hover {
      opacity: 0.8;
    }

    /* ‚úÖ Tabbed Search Input Styling */
    .tabbed-search-container {
      position: relative;
      width: 100%;
      max-width: 170px;
    }

    .tabbed-search-input {
      width: 100%;
      padding: 6px 10px;
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      background: #ffffff;
      color: #334155;
      font-size: 13px;
      font-family: 'Inter', sans-serif;
      transition: all 0.2s ease;
      outline: none;
    }

    .tabbed-search-input:hover {
      border-color: #8b5cf6;
      background: #faf5ff;
    }

    .tabbed-search-input:focus {
      border-color: #8b5cf6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .tabbed-search-input::placeholder {
      color: #94a3b8;
    }

    /* Dropdown list - FIXED positioning to avoid clipping */
    .tabbed-dropdown-list {
      position: fixed;
      max-height: 200px;
      overflow-y: auto;
      background: #ffffff;
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 9999;
      display: none;
    }

    .tabbed-dropdown-list.show {
      display: block;
    }

    .tabbed-dropdown-item {
      padding: 8px 12px;
      font-size: 13px;
      color: #334155;
      cursor: pointer;
      transition: background 0.15s;
    }

    .tabbed-dropdown-item:hover {
      background: #faf5ff;
      color: #8b5cf6;
    }

    .tabbed-dropdown-item.selected {
      background: #ede9fe;
      color: #8b5cf6;
      font-weight: 600;
    }

    .tabbed-dropdown-item-name {
      color: #94a3b8;
      font-size: 11px;
      margin-left: 4px;
    }

    .tabbed-dropdown option:hover {
      background: #f3f4f6;
    }

    .paid-checkbox:hover {
      transform: scale(1.3);
    }

    .dot{
      width:18px;
      height:18px;
      border-radius:50%;
      display:grid;
      place-items:center;
      font-size:12px;
      line-height:1;
      background:rgba(255,255,255,0.55);
    }

    /* Compact status dots */
    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .dot-paid {
      background: #22c55e;
    }

    .dot-pending {
      background: #f59e0b;
    }

    .participants-foot{
      padding:14px 28px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      border-top:2px solid #e5e7eb;
      background:#fafafa;
      color:#6b7280;
      font-size:12px;
    }

    /* Resize handles */
    .th-inner{ position:relative; padding-right:14px; }
    .col-resizer{
      position:absolute;
      top:0;
      right:-8px;
      width:16px;
      height:100%;
      cursor:col-resize;
      user-select:none;
      touch-action:none;
    }
    .col-resizer::after{
      content:"";
      position:absolute;
      top:20%;
      left:50%;
      transform:translateX(-50%);
      width:2px;
      height:60%;
      background:rgba(15,23,42,0.12);
      border-radius:2px;
      opacity:0;
      transition:opacity 120ms ease;
    }
    th:hover .col-resizer::after{ opacity:1; }
    .resizing *{ cursor:col-resize !important; user-select:none !important; }

    /* Buttons */
    .btn {
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      transition: all 150ms ease;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .btn-blue   { background: #3B82F6; }
    .btn-green  { background: #10B981; }
    .btn-purple { background: linear-gradient(90deg, #7C3AED, #EC4899); }
    .btn-orange { background: #F97316; }
    .btn-gray   { background: #6B7280; }
    .btn-red    { background: #EF4444; }

    .search-box input {
      height: 40px;
      padding: 0 14px;
      border-radius: 12px;
      border: 1px solid #E6E8F0;
      font-size: 14px;
    }

    .filter-select {
      height: 40px;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid #E6E8F0;
      font-size: 14px;
      background: #fff;
      cursor: pointer;
    }

/* MODAL STYLES */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: none; /* CHANGED from flex to none */
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .modal-overlay.show {
      display: flex; /* ADDED: Show when .show class is added */
    }

    .modal-content {
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 32px 24px;
      width: 600px;
      max-width: 90vw;
      transform: scale(0.9);
      transition: transform 200ms ease;
    }

    .modal-overlay.show .modal-content {
      transform: scale(1);
    }

    .modal-title {
      font-size: 24px;
      font-weight: 700;
      margin: 0 0 24px 0;
      color: #111827;
    }

    .modal-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-label {
      font-size: 14px;
      font-weight: 500;
      color: #374151;
      margin-bottom: 8px;
    }

    .form-input {
      width: 100%;
      padding: 10px 11px;
      border: 1px solid #D1D5DB;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }

    .form-input:focus {
      border-color: #8B5CF6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 32px;
    }

    .form-hint {
      font-size: 12px;
      color: #6B7280;
      margin-top: 4px;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      margin-top: 32px;
    }

    .modal-btn {
      flex: 1;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 150ms ease;
    }

    .modal-btn-cancel {
      background: #ffffff;
      color: #374151;
      border: 1px solid #D1D5DB;
    }

    .modal-btn-cancel:hover {
      background: #F9FAFB;
    }

    .modal-btn-save {
      background: linear-gradient(90deg, #3B82F6, #2563EB);
      color: #ffffff;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .modal-btn-save:hover {
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    }

    /* FINISH RAFFLE MODAL */
    .finish-modal-content {
      width: 540px;
    }

    .finish-modal-icon {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, #FF4FB2, #A855F7);
      border-radius: 50%;
      display: grid;
      place-items: center;
      margin: 0 auto 20px;
      font-size: 40px;
    }

    .finish-modal-text {
      font-size: 15px;
      color: #6B7280;
      margin-bottom: 28px;
      line-height: 1.6;
      text-align: center;
    }

    .winner-section {
      background: #F9FAFB;
      border: 1px solid #E5E7EB;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 28px;
    }

    .winner-section-title {
      font-size: 15px;
      font-weight: 700;
      color: #111827;
      margin: 0 0 16px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .winner-count-selector {
      margin-bottom: 20px;
    }

    .winner-count-buttons {
      display: flex;
      gap: 8px;
    }

    .winner-count-btn {
      flex: 1;
      padding: 10px 16px;
      border: 2px solid #E5E7EB;
      border-radius: 8px;
      background: white;
      color: #6B7280;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 150ms ease;
    }

    .winner-count-btn:hover {
      border-color: #A855F7;
      color: #A855F7;
    }

    .winner-count-btn.active {
      border-color: #A855F7;
      background: #A855F7;
      color: white;
      box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
    }

    .winner-entry {
      margin-bottom: 20px;
      padding: 16px;
      background: white;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      animation: slideIn 200ms ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .winner-entry-header {
      font-size: 13px;
      font-weight: 600;
      color: #6B7280;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

          .username-dropdown-container {
      position: relative;
    }

    .username-dropdown-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: white;
      border: 1px solid #D1D5DB;
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      display: none;
    }

    .username-dropdown-list.show {
      display: block;
    }

    .username-dropdown-item {
      padding: 10px 14px;
      cursor: pointer;
      transition: background 150ms ease;
    }

    .username-dropdown-item:hover {
      background: #F3F4F6;
    }

    .username-dropdown-item.selected {
      background: #EFE9FF;
      color: #6E5FFC;
      font-weight: 600;
    }

    .winner-form-row {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
    }

    .form-select {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid #D1D5DB;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      background: white;
      cursor: pointer;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }

    .form-select:focus {
      border-color: #10B981;
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
    }

    .finish-modal-actions {
      display: flex;
      gap: 12px;
    }

    .finish-btn {
      flex: 1;
      padding: 14px 24px;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 150ms ease;
    }

    .finish-btn-complete {
      background: linear-gradient(90deg, #10B981, #059669);
      color: white;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .finish-btn-complete:hover {
      box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
      transform: translateY(-1px);
    }

    .finish-btn-complete:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .finish-btn-cancel-raffle {
      background: linear-gradient(90deg, #EF4444, #DC2626);
      color: white;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }

    .finish-btn-cancel-raffle:hover {
      box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
      transform: translateY(-1px);
    }

    .or-divider {
      text-align: center;
      color: #9CA3AF;
      font-size: 13px;
      font-weight: 600;
      margin: 16px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* RESTRICTION MODAL */
    .restriction-modal-content {
      width: 420px;
      background: #2B2B3D;
      border-radius: 16px;
      padding: 40px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .restriction-modal-icon {
      width: 64px;
      height: 64px;
      background: rgba(251, 191, 36, 0.15);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 20px;
      font-size: 32px;
    }

    .restriction-modal-title {
      font-size: 22px;
      font-weight: 600;
      color: #E5E7EB;
      margin: 0 0 16px 0;
      text-align: center;
    }

    .restriction-modal-message {
      font-size: 15px;
      color: #9CA3AF;
      line-height: 1.6;
      margin-bottom: 32px;
      text-align: center;
    }

    .restriction-modal-message strong {
      color: #FFFFFF;
      font-weight: 600;
    }

    .restriction-ok-btn {
      width: 100%;
      height: 48px;
      background: #4F89C7;
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .restriction-ok-btn:hover {
      background: #5A96D4;
      transform: translateY(-1px);
    }

    .restriction-ok-btn:active {
      transform: translateY(0);
    }

    .restriction-cancel-btn {
      width: 100%;
      height: 48px;
      background: #DC4444;
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .restriction-cancel-btn:hover {
      background: #E65555;
      transform: translateY(-1px);
    }

    .restriction-cancel-btn:active {
      transform: translateY(0);
    }

    .restriction-modal-actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* PAYPAL SCAN CONFIRMATION MODAL */
    .paypal-scan-modal-content {
      width: 440px;
      background: #2B2B3D;
      border-radius: 16px;
      padding: 32px;
      text-align: left;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .paypal-scan-modal-title {
      font-size: 18px;
      font-weight: 600;
      color: #E5E7EB;
      margin: 0 0 20px 0;
      text-align: left;
      line-height: 1.4;
    }

    .paypal-scan-modal-message {
      font-size: 14px;
      color: #9CA3AF;
      line-height: 1.8;
      margin-bottom: 28px;
      text-align: left;
    }

    .paypal-scan-modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .paypal-scan-ok-btn {
      height: 44px;
      padding: 0 28px;
      background: #7C3AED;
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .paypal-scan-ok-btn:hover {
      background: #8B5CF6;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
    }

    .paypal-scan-ok-btn:active {
      transform: translateY(0);
    }

    .paypal-scan-cancel-btn {
      height: 44px;
      padding: 0 24px;
      background: transparent;
      color: #9CA3AF;
      border: 1px solid #4B5563;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .paypal-scan-cancel-btn:hover {
      background: #374151;
      color: #E5E7EB;
      border-color: #6B7280;
    }

    .paypal-scan-cancel-btn:active {
      transform: scale(0.98);
    }

    /* CANCEL RAFFLE CONFIRMATION MODAL */
    .cancel-confirm-modal-content {
      width: 420px;
      background: #2B2B3D;
      border-radius: 12px;
      padding: 32px;
      text-align: left;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .cancel-confirm-title {
      font-size: 15px;
      color: #E5E7EB;
      line-height: 1.5;
      margin-bottom: 24px;
    }

    .cancel-confirm-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .cancel-confirm-ok-btn {
      padding: 10px 28px;
      background: #4F89C7;
      color: #FFFFFF;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .cancel-confirm-ok-btn:hover {
      background: #5A96D4;
      transform: translateY(-1px);
    }

    .cancel-confirm-cancel-btn {
      padding: 10px 24px;
      background: transparent;
      color: #9CA3AF;
      border: 1px solid #4B5563;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .cancel-confirm-cancel-btn:hover {
      background: rgba(75, 85, 99, 0.3);
      border-color: #6B7280;
      color: #D1D5DB;
    }

    /* AUTO-SCAN INDICATOR */
    .auto-scan-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }

    .auto-scan-pulse {
      width: 8px;
      height: 8px;
      background: white;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.5;
        transform: scale(1.2);
      }
    }

    /* SUMMARY MODAL */
    .summary-modal-content {
      width: 700px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }

    .summary-total-banner {
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
      padding: 20px 28px;
      border-radius: 12px;
      margin-bottom: 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .summary-total-label {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.9;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .summary-total-value {
      font-size: 36px;
      font-weight: 700;
    }

    .summary-list {
      max-height: 450px;
      overflow-y: auto;
      margin-bottom: 24px;
    }

    .summary-participant {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid #E5E7EB;
      transition: background 150ms ease;
    }

    .summary-participant:hover {
      background: #F9FAFB;
    }

    .summary-participant:last-child {
      border-bottom: none;
    }

    .summary-user-info {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }

    .summary-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      color: #fff;
      font-weight: 700;
      font-size: 14px;
      background: linear-gradient(135deg, #A855F7, #FF4FB2);
      flex-shrink: 0;
    }

    .summary-username {
      font-size: 15px;
      font-weight: 600;
      color: #111827;
    }

    .summary-stats {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .summary-stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .summary-stat-label {
      font-size: 11px;
      font-weight: 600;
      color: #6B7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .summary-stat-value {
      font-size: 16px;
      font-weight: 700;
      color: #111827;
    }

    .summary-owed-value {
      color: #10B981;
    }

    /* TOAST NOTIFICATION */
    .toast {
      position: absolute;
      top: 30px;
      right: 30px;
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
      padding: 20px 28px;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(16, 185, 129, 0.5);
      font-size: 15px;
      font-weight: 600;
      z-index: 10000;
      min-width: 380px;
      max-width: 480px;
      opacity: 0;
      transform: translateX(400px);
      transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1),
                  transform 400ms cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }

    .toast-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .toast-icon {
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.25);
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-size: 18px;
      flex-shrink: 0;
    }

    .toast-title {
      font-size: 16px;
      font-weight: 700;
      margin: 0;
    }

    .toast-body {
      margin-left: 44px;
      font-size: 13px;
      font-weight: 500;
      line-height: 1.6;
      opacity: 0.95;
    }

    .toast-detail {
      margin-top: 4px;
      color: rgba(255, 255, 255, 0.9);
    }

    .toast-close {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 24px;
      height: 24px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 16px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: background 150ms ease;
    }

    .toast-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* ERROR TOAST */
    .error-toast {
      position: absolute;
      top: 110px;
      right: 40px;
      background: linear-gradient(135deg, #EF4444, #DC2626);
      color: white;
      padding: 20px 28px;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(239, 68, 68, 0.5);
      font-size: 15px;
      font-weight: 600;
      z-index: 10000;
      min-width: 380px;
      max-width: 480px;
      opacity: 0;
      transform: translateX(400px);
      transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1),
                  transform 400ms cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }

    .error-toast.show {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }

    /* Hidden rows */
    .hidden { display: none !important; }

    /* ==============================
       ACCESS DENIED MODAL
       ============================== */
    .access-denied-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      z-index: 999999;
      animation: fadeIn 0.2s ease;
    }

    .access-denied-overlay.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .access-denied-modal {
      background: white;
      border-radius: 24px;
      padding: 0;
      width: 440px;
      max-width: 90vw;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      animation: slideUp 0.3s ease;
      overflow: hidden;
    }

    .access-modal-header {
      background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
      padding: 32px;
      text-align: center;
      position: relative;
    }

    .access-modal-icon {
      width: 72px;
      height: 72px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px;
      font-size: 36px;
      animation: shake 0.5s ease;
    }

    @keyframes shake {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-10deg); }
      75% { transform: rotate(10deg); }
    }

    .access-modal-title {
      font-size: 26px;
      font-weight: 800;
      color: white;
      margin: 0 0 8px 0;
      letter-spacing: -0.5px;
    }

    .access-modal-subtitle {
      font-size: 14px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
      margin: 0;
    }

    .access-modal-body {
      padding: 32px;
      text-align: center;
    }

    .access-modal-message {
      font-size: 16px;
      font-weight: 500;
      color: #374151;
      line-height: 1.6;
      margin: 0 0 24px 0;
    }

    .access-modal-actions {
      display: flex;
      gap: 12px;
    }

    .access-modal-btn {
      flex: 1;
      padding: 14px 24px;
      border: none;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 700;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s;
    }

    .access-modal-btn-primary {
      background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
      color: white;
    }

    .access-modal-btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(139, 92, 246, 0.4);
    }

    .access-modal-btn-primary:active {
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <div class="white-square">
    <div class="top-sidebar"></div>
    <div class="tako"></div>
    <div class="sidebar"></div>
    <div class="rectangle"></div>
    <div class="square" id="activeSquare"></div>

    <div id="themeToggle" title="Theme Toggle">
      <img src="/static/assets/Icons/OFF.png" alt="Theme toggle">
    </div>
    <div id="settingsBtn" title="Settings">
      <img src="/static/assets/Icons/Notifications%20Copy.png" alt="Settings">
    </div>

    <!-- FAST RAFFLE TIMER -->
    <div id="fastRaffleTimer" class="fast-raffle-timer">
      <span id="timerDisplay">01:15:00</span>
    </div>

    <!-- STATS -->
    <section class="stats-row" aria-label="Active raffle overview">
      <div class="stat-card c-pink">
        <div class="stat-label">Total Spots</div>
        <div class="stat-value" id="totalSpots">-</div>
      </div>
      <div class="stat-card c-purple">
        <div class="stat-label">Spots Remaining</div>
        <div class="stat-value" id="spotsRemaining">-</div>
      </div>
      <div class="stat-card c-green">
        <div class="stat-label">Cost Per Spot</div>
        <div class="stat-value" id="costPerSpot">-</div>
      </div>
      <div class="stat-card c-orange">
        <div class="stat-label">Total Owed</div>
        <div class="stat-value" id="totalOwed">$0</div>
      </div>
      <div class="stat-card c-blue">
        <div class="stat-label">Outstanding Balance</div>
        <div class="stat-value" id="totalPaid">$0</div>
      </div>
    </section>

    <!-- TABLE -->
    <section class="participants-card">
      <div class="participants-header">
        <div>
          <h3 class="participants-title">Participants</h3>
          <div class="participants-sub"><span id="totalParticipants">0</span> total participants ‚Ä¢ Next poll in <span id="nextPollTimer">10</span>s</div>
        </div>
<div style="display:flex; gap:10px;">
  <button id="setupBtn" class="btn btn-blue">Setup</button>
  <button id="summaryBtn" class="btn btn-purple">Summary</button>
  <button id="scanEmailBtn" class="btn btn-orange">üìß Scan Gmail</button>
  <button id="clearIdsBtn" class="btn btn-gray">üóëÔ∏è Clear IDs</button>
  <button id="markPaidBtn" class="btn btn-green">Mark All Paid</button>
  <button id="finishRaffleBtn" class="btn btn-red">Finish Raffle</button>
</div>

        <div style="display:flex; gap:12px; align-items:center;">
          <div class="search-box">
            <input id="participantSearch" type="text" placeholder="Search participants..." />
          </div>

          <select id="paymentFilter" class="filter-select">
            <option value="all">All Payments</option>
            <option value="paid">Paid</option>
            <option value="pending">Pending</option>
            <option value="tabs">Tabs Only</option>
            <option value="drama">Waitlist</option>
          </select>
        </div>
      </div>

      <div class="table-wrap">
        <table class="p-table" id="participantsTable">
          <colgroup>
            <col class="col-reddit">
            <col class="col-name">
            <col class="col-tabbed">
            <col class="col-comment">
            <col class="col-spots">
            <col class="col-owed">
            <col class="col-paid">
            <col class="col-status">
          </colgroup>

          <thead>
            <tr>
              <th data-col="0">
                <div class="th-inner">
                  Reddit User
                  <span class="col-resizer"></span>
                </div>
              </th>
              <th data-col="1">
                <div class="th-inner">
                  Name
                  <span class="col-resizer"></span>
                </div>
              </th>
              <th data-col="2"><div class="th-inner">Tabbed<span class="col-resizer"></span></div></th>
              <th data-col="3">
                <div class="th-inner">
                  Comment
                  <span class="col-resizer"></span>
                </div>
              </th>
              <th data-col="4" class="sortable" data-sort="spots">
                <div class="th-inner">
                  Spots
                  <span class="sort-indicator">
                    <span class="sort-arrow sort-arrow-up">‚ñ≤</span>
                    <span class="sort-arrow sort-arrow-down">‚ñº</span>
                  </span>
                  <span class="col-resizer"></span>
                </div>
              </th>
              <th data-col="5"><div class="th-inner">Owed<span class="col-resizer"></span></div></th>
              <th data-col="6" class="sortable" data-sort="paid">
                <div class="th-inner">
                  Paid
                  <span class="sort-indicator">
                    <span class="sort-arrow sort-arrow-up">‚ñ≤</span>
                    <span class="sort-arrow sort-arrow-down">‚ñº</span>
                  </span>
                  <span class="col-resizer"></span>
                </div>
              </th>
              <th data-col="7"><div class="th-inner">Status<span class="col-resizer"></span></div></th>
            </tr>
          </thead>
          <tbody id="participantsTbody">
            <tr id="emptyRow">
              <td colspan="8" style="padding:26px 24px; text-align:center; color:#64748b;">
                No participants yet. Click "Setup" to configure your raffle.
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="participants-foot">
        <div id="footerShowing">Showing 0 of 0 participants</div>
        <div id="autoScanIndicator" class="auto-scan-indicator" style="display: none;">
          <div class="auto-scan-pulse"></div>
          <span>Auto scanning Every 10 Seconds</span>
        </div>
        <div id="footerStats">Paid: <strong>0</strong> &nbsp;&nbsp; Pending: <strong>0</strong></div>
      </div>
    </section>

   <!-- NAV -->
<nav class="sidebar-nav" id="sidebarNav">
  <a class="nav-item" href="/dashboard"><img class="nav-icon" src="/static/assets/Icons/Heart-Rate.png" alt="">Dashboard</a>
  <a class="nav-item is-active" href="/active-raffle"><img class="nav-icon" src="/static/assets/Icons/Graph%20Copy.png" alt="">Active Raffle</a>
  <a class="nav-item" href="/raffle-history"><img class="nav-icon" src="/static/assets/Icons/Graph.png" alt="">Raffle History</a>
  <a class="nav-item" href="/activity-log"><img class="nav-icon" src="/static/assets/Icons/activity.png" alt="">Activity Log</a>
  <a class="nav-item" href="/profile"><img class="nav-icon" src="/static/assets/Icons/icons8-user-30%201.png" alt="">Profile</a>
  <a class="nav-item" href="/discord"><img class="nav-icon" src="/static/assets/Icons/discord_white_logo%201.png" alt="">Discord</a>
  <a class="nav-item" href="/help"><img class="nav-icon" src="/static/assets/Icons/help.png" alt="">Help</a>
  <a class="nav-item" href="/donate"><img class="nav-icon" src="/static/assets/Icons/Graph%20Copy%204.png" alt="">Donate</a>
  <a class="nav-item" href="/admin">Admin</a>
</nav>

<!-- USER SECTION -->
<div class="user-section" id="userSection">
  <div class="user-info">
    <div class="user-avatar" id="userAvatar">U</div>
    <div class="user-details">
      <p class="user-name" id="userName">User</p>
      <p class="user-role" id="userRole">Admin</p>
    </div>
  </div>
  <button class="logout-btn" id="sidebarLogoutBtn">Logout</button>
</div>

<!-- APP VERSION -->
<div class="app-version">v1.0.0</div>

<script>
  // ============ USER SECTION & LOGOUT ============
  (async function() {
    const userAvatar = document.getElementById('userAvatar');
    const userName = document.getElementById('userName');
    const userRole = document.getElementById('userRole');
    const logoutBtn = document.getElementById('sidebarLogoutBtn');

    // Fetch current user info
    try {
      const response = await fetch('/api/auth/current-user');
      if (response.ok) {
        const result = await response.json();
        if (result.ok && result.data) {
          const user = result.data;

          // Update username
          if (user.username) {
            userName.textContent = user.username;
            // Update avatar with first letter
            userAvatar.textContent = user.username.charAt(0).toUpperCase();
          }

          // Update role
          if (user.role) {
            userRole.textContent = user.role.charAt(0).toUpperCase() + user.role.slice(1);
          } else if (user.isAdmin) {
            userRole.textContent = 'Admin';
          } else {
            userRole.textContent = 'User';
          }
        }
      }
    } catch (error) {
      console.error('Failed to fetch user info:', error);
    }

    // Logout button handler
    logoutBtn?.addEventListener('click', async () => {
      try {
        const response = await fetch('/api/auth/logout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        const result = await response.json();

        if (result.ok) {
          window.location.href = '/login';
        } else {
          alert('‚ùå Logout failed: ' + (result.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Logout error:', error);
        alert('‚ùå Logout failed: ' + error.message);
      }
    });
  })();

  // Sidebar Admin Control - Intercept admin links for non-admin users
  (function() {
    const sidebarNav = document.getElementById('sidebarNav');
    if (!sidebarNav) return;

    // Find admin links
    const allLinks = sidebarNav.querySelectorAll('.nav-item');
    allLinks.forEach(link => {
      const href = link.getAttribute('href');

      // Prevent reload when clicking active raffle link on active raffle page
      if (href === '/active-raffle') {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          // Do nothing - already on this page
        });
      }

      if (href === '/admin' || href === '/user-management' || href === './admin.html' || href === './user_management.html') {
        // Add click handler that runs BEFORE navigation - block by default, only allow if admin
        link.addEventListener('click', async function(e) {
          e.preventDefault();
          e.stopPropagation();

          // Check if user is admin
          if (window.adminCheckComplete === true) {
            // Admin confirmed - allow navigation
            window.location.href = href;
          } else {
            // Non-admin or check not complete - show modal and stay here
            showAccessDenied();
          }
        }, true);
      }
    });

    // Check if user is admin (async)
    (async function() {
      try {
        const response = await fetch('/api/auth/current-user');
        if (!response.ok) return;

        const data = await response.json();
        if (data.data?.isAdmin === true) {
          window.adminCheckComplete = true;
          console.log('‚úÖ Admin access granted');
        } else {
          console.log('üîí Admin links blocked for non-admin user');
        }
      } catch (error) {
        console.error('Error checking admin status:', error);
      }
    })();
  })();
</script>

 <!-- SETUP MODAL -->
  <div id="setupModal" class="modal-overlay">
    <div class="modal-content" style="width: 600px;">
      <h3 class="modal-title">Raffle Setup</h3>

      <div class="modal-form">
        <div class="form-group">
          <label class="form-label">Reddit Link</label>
          <input
            type="url"
            id="redditLinkInput"
            class="form-input"
            placeholder="https://reddit.com/r/WatchURaffle/comments/abc123/post_title/"
          />
          <p style="font-size: 12px; color: #64748b; margin: 6px 0 0 0;">
            Enter the complete Reddit post URL (must include /comments/)
          </p>
        </div>

<div class="form-row" style="gap: 50px !important;">
          <div class="form-group">
            <label class="form-label">Total Spots</label>
            <input
              type="number"
              id="totalSpotsInput"
              class="form-input"
              placeholder="100"
            />
          </div>

          <div class="form-group">
            <label class="form-label">Cost Per Spot ($)</label>
            <input
              type="number"
              id="spotCostInput"
              class="form-input"
              placeholder="e.g. 50 or 0.25"
              step="0.01"
              min="0.01"
            />
          </div>
        </div>

        <div class="form-group" style="margin-top: 16px;">
          <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; user-select: none;">
            <input
              type="checkbox"
              id="fastRaffleCheckbox"
              style="width: 18px; height: 18px; cursor: pointer;"
            />
            <span class="form-label" style="margin: 0; cursor: pointer;">
              Enable Fast Raffle Timer (1 hour 15 minutes)
            </span>
          </label>
          <p style="font-size: 12px; color: #64748b; margin: 6px 0 0 28px;">
            A countdown timer will appear at the top of the page
          </p>
        </div>
      </div>

      <div class="modal-actions">
        <button id="modalCancelBtn" class="modal-btn modal-btn-cancel">Cancel</button>
        <button id="modalSaveBtn" class="modal-btn modal-btn-save">Save Setup</button>
      </div>
    </div>
  </div>

 <!-- FINISH RAFFLE MODAL -->
  <div id="finishModal" class="modal-overlay">
    <div class="modal-content finish-modal-content">
      <div class=\"finish-modal-icon\">üéâ</div>
      <h3 class=\"modal-title\" style=\"text-align: center;\">Finish Raffle</h3>
      <p class=\"finish-modal-text\" id="finishModalText">
        Select the number of winners and enter their information to complete the raffle.
      </p>

      <!-- Winner Selection Section -->
      <div class="winner-section">
        <div class="winner-section-title">
          <span>üèÜ</span>
          <span>Winner Information</span>
        </div>

        <!-- Number of Winners Selector -->
        <div class="winner-count-selector">
          <label class="form-label" style="margin-bottom: 10px;">Number of Winners</label>
          <div class="winner-count-buttons">
            <button type="button" class="winner-count-btn active" data-count="1">     1</button>
            <button type="button" class="winner-count-btn" data-count="2">üèÜx2</button>
            <button type="button" class="winner-count-btn" data-count="3">üèÜx3</button>
            <button type="button" class="winner-count-btn" data-count="4">üèÜ√ó4</button>
            <button type="button" class="winner-count-btn" data-count="5">üèÜ√ó5</button>
          </div>
        </div>

        <!-- Dynamic Winner Entries -->
        <div id="winnerEntriesContainer">
          <!-- Will be populated dynamically -->
        </div>
      </div>

      <div class="finish-modal-actions">
        <button id="finishCompleteBtn" class="finish-btn finish-btn-complete" disabled>
          ‚úì Complete Raffle
        </button>
      </div>
    </div>
  </div>

  <!-- RESTRICTION POPUP MODAL -->
  <div id="restrictionModal" class="modal-overlay">
    <div class="modal-content restriction-modal-content">
      <div class="restriction-modal-icon">‚ö†Ô∏è</div>
      <h3 id="restrictionModalTitle" class="restriction-modal-title">Cannot Finish Raffle!</h3>
      <div id="restrictionMessage" class="restriction-modal-message"></div>
      <div class="restriction-modal-actions">
        <button id="restrictionOkBtn" class="restriction-ok-btn">OK</button>
        <button id="restrictionCancelRaffleBtn" class="restriction-cancel-btn" style="display: none;">√ó Cancel Raffle</button>
      </div>
    </div>
  </div>

  <!-- PAYPAL SCAN CONFIRMATION MODAL -->
  <div id="paypalScanModal" class="modal-overlay">
    <div class="modal-content paypal-scan-modal-content">
      <h3 class="paypal-scan-modal-title">Scan your Gmail for PayPal payment notifications?</h3>
      <div class="paypal-scan-modal-message">
        This will:<br>
        ‚Ä¢ Match payments to participants by amount + name<br>
        ‚Ä¢ Auto-mark participants as paid when matched
      </div>
      <div class="paypal-scan-modal-actions">
        <button id="paypalScanOkBtn" class="paypal-scan-ok-btn">OK</button>
        <button id="paypalScanCancelBtn" class="paypal-scan-cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- CANCEL RAFFLE CONFIRMATION MODAL -->
  <div id="cancelConfirmModal" class="modal-overlay">
    <div class="modal-content cancel-confirm-modal-content">
      <div class="cancel-confirm-title">Are you sure you want to cancel this raffle? It will be saved as incomplete.</div>
      <div class="cancel-confirm-actions">
        <button id="cancelConfirmOkBtn" class="cancel-confirm-ok-btn">OK</button>
        <button id="cancelConfirmCancelBtn" class="cancel-confirm-cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- SUMMARY MODAL -->
  <div id="summaryModal" class="modal-overlay">
    <div class="modal-content summary-modal-content">
      <h3 class="modal-title">Raffle Summary</h3>

      <div class="summary-total-banner">
        <div>
          <div class="summary-total-label">Total Owed</div>
          <div class="summary-total-value" id="summaryTotalOwed">$0</div>
        </div>
        <div style="text-align: right;">
          <div class="summary-total-label">Participants</div>
          <div class="summary-total-value" id="summaryTotalParticipants">0</div>
        </div>
      </div>

      <div class="summary-list" id="summaryList">
        <!-- Participants will be populated here -->
      </div>

      <div class="modal-actions">
        <button id="summaryCloseBtn" class="modal-btn modal-btn-save" style="width: 100%;">Close</button>
      </div>
    </div>
  </div>

  <!-- NAME IMPORT MODAL -->
  <div id="nameImportModal" class="modal-overlay">
    <div class="modal-content" style="width: 600px;">
      <h3 class="modal-title">Import Reddit Name Mappings</h3>

      <div class="modal-form">
        <div class="form-group">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #334155;">Upload File</label>
          <input type="file" id="nameFileInput" accept=".csv,.xlsx,.xls,.tsv,.txt" style="display: block; margin-bottom: 12px; padding: 8px; border: 2px dashed #cbd5e1; border-radius: 8px; width: 100%; cursor: pointer;">
          <p style="font-size: 12px; color: #64748b; margin: 0;">
            Supported: CSV, Excel (.xlsx, .xls), TSV<br>
            Format: <code>reddit_user,real_name</code>
          </p>
        </div>

        <div id="importPreview" style="display: none; margin-top: 16px; padding: 12px; background: #f8fafc; border-radius: 8px;">
          <p style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">Preview (first 5 rows):</p>
          <div id="importPreviewList" style="font-size: 12px; font-family: monospace; color: #475569;"></div>
          <p id="importCount" style="font-size: 13px; color: #16a34a; margin-top: 8px; font-weight: 600;"></p>
        </div>

        <div style="margin-top: 20px; padding: 12px; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px;">
          <p style="font-size: 13px; margin: 0; color: #92400e;">
            <strong>Note:</strong> Names are stored locally. Importing will merge with existing mappings.
          </p>
        </div>
      </div>

      <div class="modal-actions">
        <button id="nameImportBtn" class="modal-btn modal-btn-save" disabled>
          Import Names
        </button>
        <button id="nameExportBtn" class="modal-btn modal-btn-secondary">
          Export Current Mappings
        </button>
        <button id="nameClearBtn" class="modal-btn modal-btn-secondary" style="background: #dc2626; color: white;">
          Clear All Mappings
        </button>
        <button id="nameImportCloseBtn" class="modal-btn modal-btn-secondary">
          Close
        </button>
      </div>
    </div>
  </div>



  <!-- TOAST NOTIFICATION -->
  <div id="successToast" class="toast">
    <button class="toast-close" id="toastClose">√ó</button>
    <div class="toast-header">
      <div class="toast-icon">‚úì</div>
      <h4 class="toast-title" id="toastTitle">Success!</h4>
    </div>
    <div class="toast-body">
      <div id="toastMessage"></div>
    </div>
  </div>

  <!-- ERROR TOAST NOTIFICATION -->
  <div id="errorToast" class="error-toast">
    <button class="toast-close" id="errorToastClose">√ó</button>
    <div class="toast-header">
      <div class="toast-icon">‚úï</div>
      <h4 class="toast-title" id="errorToastTitle">Error</h4>
    </div>
    <div class="toast-body">
      <div id="errorToastMessage"></div>
    </div>
  </div>

  <script>

    // ============ APP STATE ============
    window.appState = {
      activeRaffleId: null,  // Store raffle ID for backend operations
      redditLink: '',
      totalSpots: null,
      costPerSpot: null,
      participants: [],
      createdAt: null,  // Timestamp when raffle setup was saved (ISO 8601 format)
      fastRaffleEnabled: false,
      fastRaffleStartTime: null,
      sortColumn: null,  // Current sort column ('reddit', 'name', 'spots')
      sortDirection: 'asc'  // Sort direction ('asc' or 'desc')
    };

    // Alias for convenience - all references can use 'appState' but it's globally accessible via window.appState
    const appState = window.appState;

    // ============ PERFORMANCE UTILITIES ============
    // Debounce function to limit how often a function can fire
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Helper to get user-specific localStorage key (only used for polling flags, not raffle data)
    function getUserLocalStorageKey(baseKey) {
      // Get user from localStorage (where auth is stored)
      try {
        const userStr = localStorage.getItem('takobot_user');
        if (userStr) {
          const user = JSON.parse(userStr);
          return `user${user.id}_${baseKey}`;
        }
      } catch (e) {
        console.error('Failed to get user from localStorage:', e);
      }
      return `anonymous_${baseKey}`;
    }

    // ============ PERSISTENCE FUNCTIONS ============
    // DATABASE-ONLY: All raffle data is stored in the database
    // User authentication info is stored in localStorage (managed by login system)

    async function saveState() {
      try {
        // ‚úÖ FIX: Save in the SAME format as Reddit parser for consistency
        const participantsForDB = appState.participants.map(p => ({
          redditUser: p.redditUser || '',    // ‚Üê Match Reddit parser format
          name: p.name || '',
          comment: p.comment || '',
          spots: p.spots || 0,               // ‚Üê Match Reddit parser format
          owed: p.owed || 0,                 // ‚Üê Match Reddit parser format
          paid: p.paid || false,             // ‚Üê Match Reddit parser format
          requestLink: p.requestLink || '',
          commentId: p.commentId || '',      // ‚Üê For duplicate detection
          tabbed: p.tabbed || null           // ‚úÖ Save tabbed field
        }));

        // User info comes from localStorage automatically via API.js getUserHeaders()
        const result = await API.saveRaffle({
          redditLink: appState.redditLink,
          totalSpots: appState.totalSpots,
          costPerSpot: appState.costPerSpot,
          participants: participantsForDB,
          fastRaffleEnabled: appState.fastRaffleEnabled,
          fastRaffleStartTime: appState.fastRaffleStartTime
        });

        console.log('üìù Save raffle response:', result);

        // Store the raffle ID from the response (in memory only)
        if (result.ok && result.raffle_id) {
          appState.activeRaffleId = result.raffle_id;
          console.log('‚úÖ Raffle saved to database. ID:', appState.activeRaffleId);
        } else {
          console.warn('‚ö†Ô∏è No raffle ID in response. Result:', result);
        }
      } catch (e) {
        console.error('‚ùå Failed to save state:', e);
      }
    }

   async function loadState() {
      try {
        const result = await API.loadRaffle();
        console.log('üìÇ Load raffle response:', result);

        if (result.ok && result.data) {
          const data = result.data;
          appState.activeRaffleId = data.id || null;
          appState.redditLink = data.redditLink || '';
          appState.totalSpots = data.totalSpots;
          appState.costPerSpot = data.costPerSpot;

          // ‚úÖ No transformation needed - data is already in the correct format from Reddit parser
          appState.participants = (data.participants || []).map(p => ({
            redditUser: p.redditUser || '',
            name: p.name || '',
            comment: p.comment || '',
            spots: p.spots || 0,
            owed: p.owed || 0,
            paid: p.paid || false,
            requestLink: p.requestLink || '',
            commentId: p.commentId || '',
            tabbed: p.tabbed || null  // ‚úÖ Restore tabbed field
          })).reverse();  // ‚úÖ Reverse so newest comments appear first (matches auto-scan behavior)

          appState.fastRaffleEnabled = data.fastRaffleEnabled || false;
          // Convert ISO string to timestamp number
          if (data.fastRaffleStartTime) {
            appState.fastRaffleStartTime = new Date(data.fastRaffleStartTime).getTime();
          } else {
            appState.fastRaffleStartTime = null;
          }

          console.log('‚úÖ Raffle loaded from database. ID:', appState.activeRaffleId);
          console.log('üìä Loaded', appState.participants.length, 'participants');

          // Update modal inputs
          document.getElementById("redditLinkInput").value = appState.redditLink;

          // Only set values if they exist (no default values)
          if (appState.totalSpots) {
            document.getElementById("totalSpotsInput").value = appState.totalSpots;
          }
          if (appState.costPerSpot != null && appState.costPerSpot !== '') {
            document.getElementById("spotCostInput").value = appState.costPerSpot;
          }

          // Update fast raffle checkbox
          const fastRaffleCheckbox = document.getElementById("fastRaffleCheckbox");
          if (fastRaffleCheckbox) {
            fastRaffleCheckbox.checked = appState.fastRaffleEnabled;
          }

          // Rebuild table if there are participants
          if (appState.participants.length > 0) {
            console.log('üîÑ Calling rebuildTable() with', appState.participants.length, 'participants');
            rebuildTable();
            updateStats();
            updateFooter();
            // ‚úÖ Apply default filter on page load (hides Waitlist participants)
            filterAndSearch();
          }

          // Start timer if enabled
          console.log('üîç Timer check - enabled:', appState.fastRaffleEnabled, 'startTime:', appState.fastRaffleStartTime);
          if (appState.fastRaffleEnabled && appState.fastRaffleStartTime) {
            console.log('‚è±Ô∏è Starting timer from loadState');
            startFastRaffleTimer();
          } else {
            console.log('‚è±Ô∏è Timer not started - enabled:', appState.fastRaffleEnabled, 'startTime:', appState.fastRaffleStartTime);
          }
        } else {
          console.log('‚ÑπÔ∏è No active raffle found in database');
        }
      } catch (e) {
        console.error('‚ùå Failed to load state:', e);
      }
    }

    async function clearState() {
      try {
        console.log('üóëÔ∏è Calling API.clearRaffle()...');
        const result = await API.clearRaffle();
        console.log('üóëÔ∏è Clear raffle result:', result);
        if (!result.ok) {
          console.error('‚ùå Failed to clear raffle:', result.error);
        }
      } catch (e) {
        console.error('Failed to clear state:', e);
      }
    }

    // ‚úÖ Sync current tabbed input values back to appState before rebuild
    function syncTabbedInputsToAppState() {
      const tabbedInputs = document.querySelectorAll('.tabbed-search-input');
      tabbedInputs.forEach(input => {
        const index = parseInt(input.dataset.index);
        const selectedReddit = input.dataset.selected || '';
        if (appState.participants[index]) {
          appState.participants[index].tabbed = selectedReddit || null;
        }
      });
    }

    // ‚úÖ NEW: Insert new rows at the top of table without rebuilding entire table
    async function insertNewRowsAtTop(newParticipants) {
      const tbody = document.getElementById("participantsTbody");
      const emptyRow = document.getElementById("emptyRow");
      
      // Remove empty row if it exists
      if (emptyRow) {
        emptyRow.remove();
      }
      
      // Load name mappings for display
      const localMappings = JSON.parse(localStorage.getItem('raffleui_reddit_name_mapping') || '{}');
      let sharedMappings = {};
      try {
        const response = await fetch('/api/settings/get-all-name-mappings', {
          method: 'GET',
          credentials: 'include'
        });
        const data = await response.json();
        if (data.ok) {
          sharedMappings = data.mappings;
        }
      } catch (err) {
        console.error('Failed to load shared name mappings:', err);
      }
      const nameMappings = { ...sharedMappings, ...localMappings };
      
      // Create new rows
      const fragment = document.createDocumentFragment();
      
      newParticipants.forEach((participant) => {
        // Find the index in appState.participants (should be at the beginning)
        const index = appState.participants.findIndex(p => p.commentId === participant.commentId);
        if (index === -1) return; // Safety check
        
        const storedName = nameMappings[participant.redditUser] || nameMappings[participant.redditUser.toLowerCase()];
        const displayName = storedName || participant.name || '';
        
        const row = document.createElement('tr');
        row.dataset.reddit = participant.redditUser;
        row.dataset.name = displayName;
        row.dataset.comment = participant.comment;
        row.dataset.paid = participant.paid;
        row.dataset.spots = participant.spots;
        row.dataset.index = index;
        
        // Add row styling classes based on payment status
        if (participant.paid) {
          row.classList.add('paid-row');
        } else if (participant.spots > 0) {
          row.classList.add('unpaid-row');
        }
        
        const initial = participant.redditUser.charAt(2).toUpperCase();
        
        // Check if this is a tab entry
        const isTab = participant.comment && (
          participant.comment.toLowerCase().includes('tab') ||
          participant.comment.toLowerCase().includes('tabbed') ||
          participant.comment.toLowerCase().includes('wff')
        );
        const tabBadge = isTab ? '<span class="tab-badge">TAB</span>' : '';
        
        const currentTabbed = participant.tabbed || '';
        const tabbedName = currentTabbed ? (nameMappings[currentTabbed] || nameMappings[currentTabbed.toLowerCase()]) : null;
        const currentTabbedDisplay = currentTabbed ? (tabbedName ? `${currentTabbed} (${tabbedName})` : currentTabbed) : '';
        
        row.innerHTML = `
          <td>
            <div class="user-cell">
              <div class="avatar">${initial}</div>
              <a class="reddit-link" href="#" onclick="return false;">${participant.redditUser}</a>
              ${tabBadge}
            </div>
          </td>
          <td><span class="name-field" data-index="${index}" style="cursor: pointer; display: inline-block; min-width: 100px; padding: 4px;" title="Click to edit name">${displayName || '<span style="color: #94a3b8;">‚Äî</span>'}</span></td>
          <td>
            <div class="tabbed-search-container">
              <input
                type="text"
                class="tabbed-search-input"
                data-index="${index}"
                data-reddit="${participant.redditUser}"
                data-selected="${currentTabbed}"
                value="${currentTabbedDisplay}"
                placeholder="‚Äî None ‚Äî"
                autocomplete="off"
              />
              <div class="tabbed-dropdown-list" data-index="${index}"></div>
            </div>
          </td>
          <td><span class=\"comment-muted\">${participant.comment || ''}</span></td>
          <td style="text-align: center;"><span class="spots-pill" data-index="${index}" style="cursor: pointer;" title="Double-click to edit">${participant.spots}</span></td>
          <td style="text-align: center; font-weight: 700;">$${parseFloat(participant.owed).toFixed(2)}</td>
          <td style="text-align: center;">
            <input type="checkbox" class="paid-checkbox" data-index="${index}" ${participant.paid ? 'checked' : ''} />
          </td>
          <td style="text-align: center;"><span class="status-dot ${participant.paid ? 'dot-paid' : 'dot-pending'}"></span></td>
        `;
        
        fragment.appendChild(row);
      });
      
      // Insert at the beginning of tbody
      tbody.insertBefore(fragment, tbody.firstChild);
      
      // Re-attach event listeners for the new rows
      attachSpotEditListeners();
      attachNameEditListeners();
      attachPaidCheckboxListeners();
      attachTabbedDropdownListeners();
      
      console.log(`‚úÖ Inserted ${newParticipants.length} new rows at top of table`);
    }

  async function rebuildTable() {
      // ‚úÖ Close all open dropdowns before rebuilding to prevent positioning issues
      document.querySelectorAll('.tabbed-dropdown-list').forEach(list => {
        list.classList.remove('show');
      });
      
      // ‚úÖ Read current tabbed input values BEFORE clearing the table
      syncTabbedInputsToAppState();
      const tbody = document.getElementById("participantsTbody");
      const emptyRow = document.getElementById("emptyRow");

      if (appState.participants.length === 0) {
        if (!emptyRow) {
          tbody.innerHTML = '<tr id="emptyRow"><td colspan="8" style="padding:26px 24px; text-align:center; color:#64748b;">No participants yet. Click "Setup" to configure your raffle.</td></tr>';
        }
        return;
      }

      if (emptyRow) {
        emptyRow.remove();
      }

      // ‚ö° PERFORMANCE: Full table rebuild. For 100+ participants, this takes ~50-100ms.
      // Future optimization: Implement row recycling (reuse existing DOM nodes, only update changed cells)
      tbody.innerHTML = '';

      // Use DocumentFragment for better performance with large tables
      const fragment = document.createDocumentFragment();

      // Sort participants based on current sort state
      let displayParticipants = [...appState.participants];

      if (appState.sortColumn) {
        displayParticipants.sort((a, b) => {
          let aVal, bVal;

          switch (appState.sortColumn) {
            case 'reddit':
              aVal = (a.redditUser || '').toLowerCase();
              bVal = (b.redditUser || '').toLowerCase();
              break;
            case 'comment':
              // Sort by index (chronological order) - lower index = older comment
              aVal = appState.participants.indexOf(a);
              bVal = appState.participants.indexOf(b);
              break;
            case 'spots':
              aVal = a.spots || 0;
              bVal = b.spots || 0;
              break;
            case 'paid':
              aVal = a.paid ? 1 : 0;
              bVal = b.paid ? 1 : 0;
              break;
            case 'tabbed':
              aVal = (a.tabbed || '').toLowerCase();
              bVal = (b.tabbed || '').toLowerCase();
              break;
            default:
              return 0;
          }

          if (appState.sortColumn === 'spots' || appState.sortColumn === 'paid') {
            // Numeric sort
            return appState.sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
          } else if (appState.sortColumn === 'comment') {
            // Chronological sort (reversed: asc = newest first, desc = oldest first)
            return appState.sortDirection === 'asc' ? bVal - aVal : aVal - bVal;
          } else {
            // String sort
            if (aVal < bVal) return appState.sortDirection === 'asc' ? -1 : 1;
            if (aVal > bVal) return appState.sortDirection === 'asc' ? 1 : -1;
            return 0;
          }
        });
      }

      // Load name mappings: localStorage (personal) FIRST, then database (shared initials) as fallback
      let nameMappings = {};

      // STEP 1: Load personal full names from localStorage
      const localMappings = JSON.parse(localStorage.getItem('raffleui_reddit_name_mapping') || '{}');

      // STEP 2: Fetch shared initials from database
      let sharedMappings = {};
      try {
        const response = await fetch('/api/settings/get-all-name-mappings', {
          method: 'GET',
          credentials: 'include'
        });
        const data = await response.json();
        if (data.ok) {
          sharedMappings = data.mappings;
        }
      } catch (err) {
        console.error('Failed to load shared name mappings:', err);
      }

      // STEP 3: Merge with priority: localStorage > database
      nameMappings = { ...sharedMappings, ...localMappings };

      // STEP 3.5: Remove case-insensitive duplicates while preserving localStorage priority
      const deduplicatedMappings = {};
      const seenLowercase = {};

      // First pass: Add all entries and track sources
      const allEntries = [];

      // Add database entries first (lower priority)
      for (const [redditUser, realName] of Object.entries(sharedMappings)) {
        allEntries.push({ redditUser, realName, source: 'database' });
      }

      // Add localStorage entries (higher priority)
      for (const [redditUser, realName] of Object.entries(localMappings)) {
        allEntries.push({ redditUser, realName, source: 'localStorage' });
      }

      // Second pass: Deduplicate with localStorage priority
      for (const entry of allEntries) {
        const lowerUser = entry.redditUser.toLowerCase();

        if (!seenLowercase[lowerUser]) {
          // First time seeing this username (case-insensitive)
          deduplicatedMappings[entry.redditUser] = entry.realName;
          seenLowercase[lowerUser] = entry;
        } else {
          // Duplicate found - check priority
          const existing = seenLowercase[lowerUser];

          // localStorage always wins over database
          if (entry.source === 'localStorage' && existing.source === 'database') {
            // Replace database entry with localStorage entry
            delete deduplicatedMappings[existing.redditUser];
            deduplicatedMappings[entry.redditUser] = entry.realName;
            seenLowercase[lowerUser] = entry;
          } else if (entry.source === 'localStorage' && existing.source === 'localStorage') {
            // Both are localStorage - prefer lowercase key
            if (entry.redditUser === lowerUser && existing.redditUser !== lowerUser) {
              delete deduplicatedMappings[existing.redditUser];
              deduplicatedMappings[entry.redditUser] = entry.realName;
              seenLowercase[lowerUser] = entry;
            }
          }
          // If entry is database and existing is localStorage, keep existing (skip entry)
        }
      }

      nameMappings = deduplicatedMappings;

      // STEP 4: Store in global cache for use by summary sidebar AND tabbed search
      cachedNameMappings = nameMappings;

      // ‚úÖ Store globally for tabbed search (includes shared + spreadsheet)
      window.allTabbedUsers = Object.keys(nameMappings).sort().map(reddit => ({
        reddit,
        name: nameMappings[reddit] || ''
      }));

      const tabbedMappings = JSON.parse(localStorage.getItem('raffleui_tabbed_mapping') || '{}');

      displayParticipants.forEach((participant, index) => {
        // Index is already correct since we're not reversing

        // Use pre-loaded name mappings instead of function call per participant
        // Use case-insensitive lookup to handle different casing in database vs participants
        const storedName = nameMappings[participant.redditUser] || nameMappings[participant.redditUser.toLowerCase()];
        const displayName = storedName || participant.name || '';

        const row = document.createElement('tr');
        row.dataset.reddit = participant.redditUser;
        row.dataset.name = displayName;  // ‚úÖ Use displayName from mappings for search functionality
        row.dataset.comment = participant.comment;
        row.dataset.paid = participant.paid;
        row.dataset.spots = participant.spots;
        row.dataset.index = index;  // Use correct index for editing

        // ‚úÖ Add row styling classes based on payment status
        if (participant.paid) {
          row.classList.add('paid-row');
        } else if (participant.spots > 0) {
          // Only show unpaid status if they have 1+ spots assigned
          row.classList.add('unpaid-row');
        }
        // If spots = 0, participant is on waitlist (no background color)

        const initial = participant.redditUser.charAt(2).toUpperCase();
        const statusClass = participant.paid ? 'status-paid' : 'status-pending';
        const statusIcon = participant.paid ? '‚úì' : '‚è±';
        const statusText = participant.paid ? 'Paid' : 'Pending';

        // Check if this is a tab entry (includes tab/tabbed/wff in comment)
        const isTab = participant.comment && (
          participant.comment.toLowerCase().includes('tab') ||
          participant.comment.toLowerCase().includes('tabbed') ||
          participant.comment.toLowerCase().includes('wff')
        );
        const tabBadge = isTab ? '<span class="tab-badge">TAB</span>' : '';

        // ‚úÖ NEW: Prepare search input with current tabbed value
        const currentTabbed = participant.tabbed || '';
        const tabbedName = currentTabbed ? (nameMappings[currentTabbed] || nameMappings[currentTabbed.toLowerCase()]) : null;
        const currentTabbedDisplay = currentTabbed ? (tabbedName ? `${currentTabbed} (${tabbedName})` : currentTabbed) : '';

        row.innerHTML = `
          <td>
            <div class="user-cell">
              <div class="avatar">${initial}</div>
              <a class="reddit-link" href="#" onclick="return false;">${participant.redditUser}</a>
              ${tabBadge}
            </div>
          </td>
          <td><span class="name-field" data-index="${index}" style="cursor: pointer; display: inline-block; min-width: 100px; padding: 4px;" title="Click to edit name">${displayName || '<span style="color: #94a3b8;">‚Äî</span>'}</span></td>
          <td>
            <div class="tabbed-search-container">
              <input
                type="text"
                class="tabbed-search-input"
                data-index="${index}"
                data-reddit="${participant.redditUser}"
                data-selected="${currentTabbed}"
                value="${currentTabbedDisplay}"
                placeholder="‚Äî None ‚Äî"
                autocomplete="off"
              />
              <div class="tabbed-dropdown-list" data-index="${index}"></div>
            </div>
          </td>
          <td><span class=\"comment-muted\">${participant.comment || ''}</span></td>
          <td style="text-align: center;"><span class="spots-pill" data-index="${index}" style="cursor: pointer;" title="Double-click to edit">${participant.spots}</span></td>
          <td style="text-align: center; font-weight: 700;">$${parseFloat(participant.owed).toFixed(2)}</td>
          <td style="text-align: center;">
            <input type="checkbox" class="paid-checkbox" data-index="${index}" ${participant.paid ? 'checked' : ''} />
          </td>
          <td style="text-align: center;"><span class="status-dot ${participant.paid ? 'dot-paid' : 'dot-pending'}"></span></td>
        `;

        fragment.appendChild(row);
      });

      // Single DOM update instead of multiple appendChild calls
      tbody.appendChild(fragment);

      // Add double-click edit functionality
      attachSpotEditListeners();

      // Add name edit functionality
      attachNameEditListeners();

      // Add checkbox event listeners
      attachPaidCheckboxListeners();

      // Add tabbed dropdown listeners
      attachTabbedDropdownListeners();

      // Add click handlers for tab rows
      if (typeof window.attachTabRowClickHandlers === 'function') {
        attachTabRowClickHandlers();
      }

      // ‚úÖ Restore tabbed column visibility after table rebuild
      const tabbedVisible = loadTabbedColumnVisibility();
      applyTabbedColumnVisibility(tabbedVisible);
    }

    // ‚úÖ Helper function to check if spots exceed limit
    function checkSpotsLimit(newSpotsToAdd, excludeIndex = null) {
      if (appState.totalSpots === null || appState.totalSpots === undefined) {
        return { valid: true }; // No limit set
      }

      // Calculate current total spots (excluding the participant being edited)
      let currentTotal = 0;
      appState.participants.forEach((p, idx) => {
        if (excludeIndex === null || idx !== excludeIndex) {
          currentTotal += parseInt(p.spots) || 0;
        }
      });

      const proposedTotal = currentTotal + newSpotsToAdd;

      if (proposedTotal > appState.totalSpots) {
        return {
          valid: false,
          currentTotal,
          proposedTotal,
          limit: appState.totalSpots,
          exceededBy: proposedTotal - appState.totalSpots
        };
      }

      return { valid: true };
    }

    // ‚úÖ Flag to track if spot edit listener is attached
    let spotEditListenerAttached = false;

    function attachSpotEditListeners() {
      // Only attach once using event delegation
      if (!spotEditListenerAttached) {
        document.addEventListener('dblclick', function(e) {
          const pill = e.target.closest('.spots-pill');
          if (!pill) return;

          const index = parseInt(pill.dataset.index);
          const currentSpots = appState.participants[index].spots;

          // Create input field
          const input = document.createElement('input');
          input.type = 'number';
          input.value = currentSpots;
          input.min = '0';
          input.style.width = '50px';
          input.style.padding = '4px 8px';
          input.style.border = '2px solid #6E5FFC';
          input.style.borderRadius = '999px';
          input.style.textAlign = 'center';
          input.style.fontSize = '12px';
          input.style.fontWeight = '700';
          input.style.color = '#6E5FFC';
          input.style.background = '#efe9ff';
          input.style.outline = 'none';

          // Replace pill with input
          const originalContent = pill.textContent;
          pill.textContent = '';
          pill.appendChild(input);
          input.focus();
          input.select();

          // Save on Enter or blur
          const saveEdit = async () => {
            const newSpots = parseInt(input.value) || 0;

            if (newSpots < 0) {
              showErrorToast('Invalid Spot Value', ['Spots cannot be negative']);
              input.value = currentSpots;
              return;
            }

            // ‚úÖ Check if new spots would exceed the limit (warn but allow)
            const spotCheck = checkSpotsLimit(newSpots, index);
            if (!spotCheck.valid) {
              showErrorToast('‚ö†Ô∏è Spot Limit Warning', [
                `This raffle has a limit of ${spotCheck.limit} spots.`,
                `Current total: ${spotCheck.currentTotal} spots`,
                `Proposed total: ${spotCheck.proposedTotal} spots (exceeds by ${spotCheck.exceededBy})`,
                `‚úì Update allowed - please verify this is correct.`
              ]);
              // Continue with the update despite exceeding limit
            }

            // ‚úÖ AUTO-RECORD PARSER CORRECTION (if enabled and spots were changed)
            if (currentSpots !== newSpots && appState.participants[index].comment) {
              try {
                // Check database setting
                const settingResponse = await fetch('/api/settings/auto_record_corrections');
                let shouldAutoRecord = false;
                
                if (settingResponse.ok) {
                  const settingResult = await settingResponse.json();
                  shouldAutoRecord = settingResult.data === 'true';
                }
                
                if (shouldAutoRecord) {
                  await fetch('/api/parser/record-correction', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                      comment: appState.participants[index].comment,
                      wrongParse: currentSpots,
                      correctParse: newSpots
                    })
                  });
                  console.log(`üéì Auto-recorded correction: "${appState.participants[index].comment}" ${currentSpots} ‚Üí ${newSpots}`);
                }
              } catch (err) {
                console.warn('Failed to check/record parser correction:', err);
                // Don't block the save if correction recording fails
              }
            }

            // Update participant data
            appState.participants[index].spots = newSpots;
            appState.participants[index].owed = newSpots * appState.costPerSpot;

            // Sync tabbed inputs before saving
            syncTabbedInputsToAppState();

            // Save to database
            await saveState();

            // ‚úÖ Update ONLY the pill and owed cell without rebuilding
            pill.textContent = newSpots;
            const row = pill.closest('tr');
            const owedCell = row.children[5]; // 6th column (0-indexed)
            if (owedCell) {
              owedCell.textContent = `$${parseFloat(appState.participants[index].owed).toFixed(2)}`;
            }

            // ‚úÖ Update row dataset for spots
            row.dataset.spots = newSpots;

            // ‚úÖ Update row styling based on spots (0 spots = waitlist, no color)
            if (appState.participants[index].paid) {
              row.classList.remove('unpaid-row');
              row.classList.add('paid-row');
            } else if (newSpots > 0) {
              row.classList.remove('paid-row');
              row.classList.add('unpaid-row');
            } else {
              // 0 spots = waitlist (remove both classes for no color)
              row.classList.remove('paid-row', 'unpaid-row');
            }

            // ‚úÖ Handle real-time filter updates for Waitlist <-> All Payments
            const paymentFilter = document.getElementById('paymentFilter').value;
            if (paymentFilter === 'drama' && newSpots > 0) {
              // Moving out of Waitlist (0 ‚Üí 1+), hide row
              row.classList.add('hidden');
            } else if (paymentFilter !== 'drama' && newSpots === 0 && currentSpots > 0) {
              // Moving into Waitlist (1+ ‚Üí 0), hide row
              row.classList.add('hidden');
            } else if (paymentFilter === 'drama' && newSpots === 0) {
              // Staying in Waitlist, ensure visible
              row.classList.remove('hidden');
            } else if (paymentFilter !== 'drama' && newSpots > 0) {
              // Re-apply filter logic for non-Waitlist filters
              filterAndSearch();
            }

            updateStats();
            updateFooter();

            // Show toast
            showToast('Spots Updated', [`${appState.participants[index].redditUser}: ${currentSpots} ‚Üí ${newSpots} spots`]);
          };

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              saveEdit();
            } else if (e.key === 'Escape') {
              // Just restore the original text without rebuilding
              pill.textContent = originalContent;
            }
          });

          input.addEventListener('blur', saveEdit);
        });

        spotEditListenerAttached = true;
        console.log('‚úÖ Spot edit listener attached (event delegation)');
      }
    }

    // ============ NAME MAPPING LOCALSTORAGE ============
    const NAME_MAPPING_KEY = 'raffleui_reddit_name_mapping';

    // Global cache for merged name mappings (localStorage + DB)
    let cachedNameMappings = {};

    function saveNameMapping(redditUser, realName) {
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');

        // Always save with lowercase key to prevent case-sensitive duplicates
        const normalizedKey = redditUser.toLowerCase();

        // Remove any case variants that might exist
        for (const key in mappings) {
          if (key.toLowerCase() === normalizedKey && key !== normalizedKey) {
            delete mappings[key];
          }
        }

        mappings[normalizedKey] = realName;
        localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(mappings));

        // Update cache with normalized key
        cachedNameMappings[normalizedKey] = realName;
      } catch (e) {
        console.error('Failed to save name mapping:', e);
      }
    }

    function removeNameMapping(redditUser) {
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');

        // Remove both the exact key and any normalized versions
        const normalizedKey = redditUser.toLowerCase();

        // Remove any case variants
        for (const key in mappings) {
          if (key.toLowerCase() === normalizedKey) {
            delete mappings[key];
          }
        }

        localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(mappings));

        // Update cache to remove the entry
        delete cachedNameMappings[redditUser];
        delete cachedNameMappings[normalizedKey];
      } catch (e) {
        console.error('Failed to remove name mapping:', e);
      }
    }

    function getNameFromMapping(redditUser) {
      // Check cache first (has both localStorage and DB data merged)
      // Use case-insensitive lookup
      if (cachedNameMappings[redditUser]) {
        return cachedNameMappings[redditUser];
      }
      if (cachedNameMappings[redditUser.toLowerCase()]) {
        return cachedNameMappings[redditUser.toLowerCase()];
      }

      // Fallback to localStorage only
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');
        return mappings[redditUser] || mappings[redditUser.toLowerCase()] || '';
      } catch (e) {
        return '';
      }
    }

    function loadAllMappings() {
      try {
        return JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');
      } catch (e) {
        return {};
      }
    }

    // ============ CLEANUP DUPLICATE NAME MAPPINGS ============
    function cleanupDuplicateNameMappings() {
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');
        const cleaned = {};
        const seenLowercase = {};
        let duplicatesRemoved = 0;

        for (const [redditUser, realName] of Object.entries(mappings)) {
          const lowerUser = redditUser.toLowerCase();

          if (!seenLowercase[lowerUser]) {
            // First time seeing this username (case-insensitive)
            cleaned[redditUser] = realName;
            seenLowercase[lowerUser] = redditUser;
          } else {
            // Duplicate found - prefer lowercase version
            const existingKey = seenLowercase[lowerUser];
            duplicatesRemoved++;

            if (redditUser === lowerUser && existingKey !== lowerUser) {
              // Current is lowercase, existing is not - replace
              cleaned[redditUser] = realName;
              delete cleaned[existingKey];
              seenLowercase[lowerUser] = redditUser;
            }
            // Otherwise skip this duplicate (keep the first one we found)
          }
        }

        // Save cleaned mappings back to localStorage
        if (duplicatesRemoved > 0) {
          localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(cleaned));
          console.log(`ÔøΩÔøΩ Removed ${duplicatesRemoved} duplicate name mapping(s)`);
        }

        return duplicatesRemoved;
      } catch (e) {
        console.error('Failed to cleanup duplicate name mappings:', e);
        return 0;
      }
    }

    // Run cleanup on page load
    cleanupDuplicateNameMappings();

    // Also cleanup database duplicates
    // DISABLED - API endpoint not available
    /*
    async function cleanupDatabaseDuplicates() {
      try {
        const response = await fetch('/api/settings/cleanup-duplicate-mappings', {
          method: 'POST',
          credentials: 'include'
        });
        const data = await response.json();
        if (data.ok && data.duplicatesRemoved > 0) {
          console.log(`‚úÖ Database cleanup: ${data.message}`);
        }
      } catch (e) {
        console.error('Failed to cleanup database duplicates:', e);
      }
    }

    // Run database cleanup once on page load
    cleanupDatabaseDuplicates();
    */

    function saveAllMappings(mappings) {
      try {
        localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(mappings));
      } catch (e) {
        console.error('Failed to save mappings:', e);
      }
    }

    function clearAllMappings() {
      localStorage.removeItem(NAME_MAPPING_KEY);
    }

    function exportMappingsAsCSV() {
      const mappings = loadAllMappings();
      let csv = 'reddit_user,real_name\n';
      for (const [reddit, name] of Object.entries(mappings)) {
        csv += `${reddit},${name}\n`;
      }
      return csv;
    }

    // ============ TABBED MAPPING LOCALSTORAGE ============
    const TABBED_MAPPING_KEY = 'raffleui_tabbed_mapping';

    function saveTabbedMapping(redditUser, tabbedToUser) {
      try {
        const mappings = JSON.parse(localStorage.getItem(TABBED_MAPPING_KEY) || '{}');
        if (tabbedToUser) {
          mappings[redditUser] = tabbedToUser;
        } else {
          delete mappings[redditUser]; // Remove if set to empty
        }
        localStorage.setItem(TABBED_MAPPING_KEY, JSON.stringify(mappings));
        console.log('‚úÖ Tabbed mapping saved:', redditUser, '‚Üí', tabbedToUser || 'none');
      } catch (e) {
        console.error('Failed to save tabbed mapping:', e);
      }
    }

    function getTabbedMapping(redditUser) {
      try {
        const mappings = JSON.parse(localStorage.getItem(TABBED_MAPPING_KEY) || '{}');
        return mappings[redditUser] || '';
      } catch (e) {
        return '';
      }
    }

    // ‚úÖ Flag to track if global listeners are attached
    let tabbedListenersAttached = false;

    // ‚úÖ NEW: Search-based tabbed input with all shared mappings + spreadsheet names
    function attachTabbedDropdownListeners() {
      // Only attach document-level click handler once
      if (!tabbedListenersAttached) {
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.tabbed-search-container')) {
            document.querySelectorAll('.tabbed-dropdown-list').forEach(list => {
              list.classList.remove('show');
            });
          }
        });
        
        // Use event delegation for focus and input events
        document.addEventListener('focus', async function(e) {
          if (e.target.classList.contains('tabbed-search-input')) {
            const input = e.target;
            const index = parseInt(input.dataset.index);
            const dropdownList = document.querySelector(`.tabbed-dropdown-list[data-index="${index}"]`);
            showDropdown(input, dropdownList);
          }
        }, true); // Use capture phase
        
        document.addEventListener('input', function(e) {
          if (e.target.classList.contains('tabbed-search-input')) {
            const input = e.target;
            const index = parseInt(input.dataset.index);
            const searchTerm = input.value.toLowerCase();
            const dropdownList = document.querySelector(`.tabbed-dropdown-list[data-index="${index}"]`);
            filterAndShowDropdown(input, dropdownList, searchTerm);
          }
        });
        
        // Handle selection from dropdown
        document.addEventListener('click', async function(e) {
          const item = e.target.closest('.tabbed-dropdown-item');
          if (!item) return;
          
          const dropdownList = item.closest('.tabbed-dropdown-list');
          if (!dropdownList) return;
          
          const index = parseInt(dropdownList.dataset.index);
          const input = document.querySelector(`.tabbed-search-input[data-index="${index}"]`);
          if (!input) return;
          
          const redditUser = input.dataset.reddit;
          const selectedUser = item.dataset.reddit || '';
          const selectedName = item.dataset.name || '';

          // Update input display
          input.value = selectedUser ? (selectedName ? `${selectedUser} (${selectedName})` : selectedUser) : '';
          input.dataset.selected = selectedUser;

          // Save to participant
          if (appState.participants[index]) {
            appState.participants[index].tabbed = selectedUser || null;
            await saveState();
          }

          // Show feedback
          if (selectedUser) {
            showToast('Tab Assignment Updated', [`${redditUser} tabbed to ${selectedUser}`]);
          } else {
            showToast('Tab Removed', [`${redditUser} tab assignment cleared`]);
          }

          // Hide dropdown
          dropdownList.classList.remove('show');

          // Refresh summary to show updated counts
          if (typeof populateSummary === 'function') {
            populateSummary();
          }
        });
        
        tabbedListenersAttached = true;
        console.log('‚úÖ Tabbed dropdown listeners attached (event delegation)');
      }
    }

    function showDropdown(input, dropdownList) {
      const selected = input.dataset.selected || '';
      filterAndShowDropdown(input, dropdownList, '', selected);
    }

    function filterAndShowDropdown(input, dropdownList, searchTerm = '', selectedUser = '') {
      if (!window.allTabbedUsers) return;

      searchTerm = searchTerm.toLowerCase();
      selectedUser = selectedUser || input.dataset.selected || '';

      // Filter users
      const filtered = searchTerm
        ? window.allTabbedUsers.filter(u =>
            u.reddit.toLowerCase().includes(searchTerm) ||
            u.name.toLowerCase().includes(searchTerm)
          )
        : window.allTabbedUsers;

      // Build dropdown HTML
      let html = '<div class="tabbed-dropdown-item" data-reddit="" data-name="">‚Äî None ‚Äî</div>';

      filtered.slice(0, 50).forEach(user => {
        const isSelected = user.reddit === selectedUser ? 'selected' : '';
        const displayName = user.name ? `<span class="tabbed-dropdown-item-name">(${user.name})</span>` : '';
        html += `<div class="tabbed-dropdown-item ${isSelected}" data-reddit="${user.reddit}" data-name="${user.name}">${user.reddit}${displayName}</div>`;
      });

      if (filtered.length > 50) {
        html += '<div class="tabbed-dropdown-item" style="color: #94a3b8; cursor: default; pointer-events: none;">...and more</div>';
      }

      dropdownList.innerHTML = html;

      // ‚úÖ Position dropdown using fixed positioning
      const rect = input.getBoundingClientRect();
      dropdownList.style.top = `${rect.bottom + 4}px`;
      dropdownList.style.left = `${rect.left}px`;
      dropdownList.style.width = `${rect.width}px`;

      dropdownList.classList.add('show');
    }

    // ============ NAME EDIT FUNCTIONALITY ============
    function attachNameEditListeners() {
      const nameFields = document.querySelectorAll('.name-field');

      nameFields.forEach(field => {
        field.addEventListener('click', function() {
          const index = parseInt(this.dataset.index);
          const participant = appState.participants[index];
          const currentName = getNameFromMapping(participant.redditUser) || participant.name || '';

          // Create input field
          const input = document.createElement('input');
          input.type = 'text';
          input.value = currentName;
          input.style.width = '140px';
          input.style.padding = '4px 8px';
          input.style.border = '1px solid #cbd5e1';
          input.style.borderRadius = '4px';
          input.style.fontSize = '14px';
          input.style.fontFamily = 'Inter, sans-serif';

          // Replace field with input
          const parentTd = this.parentElement;
          parentTd.innerHTML = '';
          parentTd.appendChild(input);
          input.focus();
          input.select();

          const saveEdit = async () => {
            const newName = input.value.trim();

            // Save to localStorage (or remove if empty)
            if (newName) {
              saveNameMapping(participant.redditUser, newName);
            } else {
              // Remove from localStorage when name is cleared
              removeNameMapping(participant.redditUser);
            }

            // Update participant object
            appState.participants[index].name = newName;

            // Sync tabbed inputs before saving
            syncTabbedInputsToAppState();

            await saveState();

            // ‚úÖ Restore the name field span (replacing the input)
            const newSpan = document.createElement('span');
            newSpan.className = 'name-field';
            newSpan.dataset.index = index;
            newSpan.style.cssText = 'cursor: pointer; display: inline-block; min-width: 100px; padding: 4px;';
            newSpan.title = 'Click to edit name';
            newSpan.innerHTML = newName || '<span style="color: #94a3b8;">‚Äî</span>';

            // Replace input with span
            parentTd.innerHTML = '';
            parentTd.appendChild(newSpan);

            // Re-attach listener by calling attachNameEditListeners again
            attachNameEditListeners();

            // Show toast
            showToast('Name Updated', [`${participant.redditUser} ‚Üí ${newName || '(cleared)'}`]);
          };

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              saveEdit();
            } else if (e.key === 'Escape') {
              // Restore the original field without saving
              const cancelSpan = document.createElement('span');
              cancelSpan.className = 'name-field';
              cancelSpan.dataset.index = index;
              cancelSpan.style.cssText = 'cursor: pointer; display: inline-block; min-width: 100px; padding: 4px;';
              cancelSpan.title = 'Click to edit name';
              cancelSpan.innerHTML = currentName || '<span style="color: #94a3b8;">‚Äî</span>';

              parentTd.innerHTML = '';
              parentTd.appendChild(cancelSpan);

              // Re-attach listener
              attachNameEditListeners();
            }
          });

          input.addEventListener('blur', saveEdit);
        });
      });
    }

    function attachPaidCheckboxListeners() {
      const checkboxes = document.querySelectorAll('.paid-checkbox');

      checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', async function() {
          const index = parseInt(this.dataset.index);
          const newPaidStatus = this.checked;
          const participant = appState.participants[index];

          // Update participant paid status
          appState.participants[index].paid = newPaidStatus;

          // ‚úÖ Sync tabbed inputs before saving
          syncTabbedInputsToAppState();

          // Save to database
          await saveState();

          // ‚úÖ Update ONLY the status chip without rebuilding the entire table
          const row = this.closest('tr');
          const statusDot = row.querySelector('.status-dot');
          if (statusDot) {
            statusDot.className = newPaidStatus ? 'status-dot dot-paid' : 'status-dot dot-pending';
          }

          // ‚úÖ Toggle row styling based on payment status (Purple & Green Theme)
          if (newPaidStatus) {
            row.classList.remove('unpaid-row');
            row.classList.add('paid-row');
          } else {
            row.classList.remove('paid-row');
            row.classList.add('unpaid-row');
          }

          // ‚úÖ Update row dataset for sorting
          row.dataset.paid = newPaidStatus;

          // ‚úÖ If pending filter is active and marking as paid, hide the row in real-time
          const paymentFilter = document.getElementById('paymentFilter').value;
          if (paymentFilter === 'pending' && newPaidStatus) {
            row.classList.add('hidden');
          }
          // If paid filter is active and marking as unpaid, hide the row
          if (paymentFilter === 'paid' && !newPaidStatus) {
            row.classList.add('hidden');
          }

          // Update stats
          updateStats();

          // Log activity
          await API.logActivity({
            type: newPaidStatus ? 'payment' : 'edit',
            title: newPaidStatus ? 'Payment received' : 'Payment unmarked',
            details: `${participant.redditUser} ‚Ä¢ $${parseFloat(participant.owed).toFixed(2)}`,
            badge: newPaidStatus ? 'Payment' : 'Edit'
          });

          // Show toast
          const statusText = newPaidStatus ? 'marked as paid' : 'marked as unpaid';
          showToast('Payment Status Updated', [`${participant.redditUser} ${statusText}`]);
        });
      });
    }

    // ============ UTILITY FUNCTIONS ============
    function showToast(title, details) {
      const toast = document.getElementById("successToast");
      const toastTitle = document.getElementById("toastTitle");
      const toastMessage = document.getElementById("toastMessage");

      // Clear any existing toast and timeout
      toast.classList.remove("show");

      // Use requestAnimationFrame to ensure the removal takes effect before re-showing
      requestAnimationFrame(() => {
        toastTitle.textContent = title;
        toastMessage.innerHTML = details.map(d => `<div class="toast-detail">${d}</div>`).join('');

        toast.classList.add("show");

        setTimeout(() => {
          toast.classList.remove("show");
        }, 3000); // Show for 3 seconds
      });
    }

    function showErrorToast(title, details) {
      const errorToast = document.getElementById("errorToast");
      const errorToastTitle = document.getElementById("errorToastTitle");
      const errorToastMessage = document.getElementById("errorToastMessage");

      errorToastTitle.textContent = title;
      errorToastMessage.innerHTML = details.map(d => `<div class="toast-detail">${d}</div>`).join('');

      errorToast.classList.add("show");

      setTimeout(() => {
        errorToast.classList.remove("show");
      }, 3000); // Show for 3 seconds
    }

function updateStats() {
      const totalSpotsEl = document.getElementById("totalSpots");
      const spotsRemainingEl = document.getElementById("spotsRemaining");
      const costPerSpotEl = document.getElementById("costPerSpot");
      const totalOwedEl = document.getElementById("totalOwed");
      const totalPaidEl = document.getElementById("totalPaid");

      totalSpotsEl.textContent = appState.totalSpots !== null ? appState.totalSpots : '-';
      costPerSpotEl.textContent = appState.costPerSpot !== null ? `$${parseFloat(appState.costPerSpot).toFixed(2)}` : '-';

      // ‚úÖ Exclude Waitlist participants (0 spots) from all stats
      const raffleParticipants = appState.participants.filter(p => (p.spots || 0) > 0);

      const spotsClaimed = raffleParticipants.reduce((sum, p) => sum + (p.spots || 0), 0);
      const spotsRemaining = appState.totalSpots !== null ? Math.max(0, appState.totalSpots - spotsClaimed) : '-';  // ADD Math.max(0, ...)
      spotsRemainingEl.textContent = spotsRemaining;

      // Stop auto-polling when raffle is full (0 spots remaining)
      if (spotsRemaining === 0 && pollingInterval) {
        stopAutoPolling();
        stopPollCountdown(); // ‚úÖ Also stop the poll countdown timer
        console.log('üéØ Raffle is full! Auto-polling stopped.');
      }

      // NOTE: Removed auto-restart logic to prevent duplicate polling intervals
      // Auto-polling is started once on page load and manages itself

      const totalOwed = raffleParticipants.reduce((sum, p) => sum + (p.owed || 0), 0);
      const totalPaid = raffleParticipants.filter(p => p.paid).reduce((sum, p) => sum + (p.owed || 0), 0);

      totalOwedEl.textContent = `$${totalOwed.toFixed(2)}`;

      // Show the difference (Total Paid - Total Owed)
      const difference = totalPaid - totalOwed;
      totalPaidEl.textContent = `$${difference.toFixed(2)}`;
    }

    function updateFooter() {
      const tbody = document.getElementById("participantsTbody");
      const visibleRows = Array.from(tbody.querySelectorAll("tr:not(.hidden):not(#emptyRow)"));
      
      // ‚úÖ Exclude Waitlist participants (0 spots) from counts
      const raffleParticipants = appState.participants.filter(p => (p.spots || 0) > 0);
      const waitlistParticipants = appState.participants.filter(p => (p.spots || 0) === 0);
      
      const totalCount = raffleParticipants.length;
      const visibleCount = visibleRows.length;

      const paidCount = raffleParticipants.filter(p => p.paid).length;
      const pendingCount = totalCount - paidCount;

      document.getElementById("footerShowing").textContent = `Showing ${visibleCount} of ${totalCount} participants`;
      document.getElementById("footerStats").innerHTML = `Paid: <strong>${paidCount}</strong> &nbsp;&nbsp; Pending: <strong>${pendingCount}</strong>`;
      document.getElementById("totalParticipants").textContent = totalCount;
    }

    function filterAndSearch() {
      // ‚ö° PERFORMANCE: Debounced via debouncedSearch (300ms delay after typing stops)
      const searchQuery = document.getElementById("participantSearch").value.toLowerCase();
      const paymentFilter = document.getElementById("paymentFilter").value;
      const tbody = document.getElementById("participantsTbody");
      const rows = Array.from(tbody.querySelectorAll("tr:not(#emptyRow)"));

      rows.forEach(row => {
        const redditUser = row.dataset.reddit?.toLowerCase() || '';
        const name = row.dataset.name?.toLowerCase() || '';
        const comment = row.dataset.comment?.toLowerCase() || '';
        const paid = row.dataset.paid === 'true';
        const spots = parseInt(row.dataset.spots) || 0;

        // Check if comment contains tab/tabbed/wff
        const isTab = comment.includes('tab') || comment.includes('wff');

        const matchesSearch = redditUser.includes(searchQuery) ||
                            name.includes(searchQuery) ||
                            comment.includes(searchQuery);
        
        // Waitlist filter: ONLY 0-spot participants (waiting for spots to open)
        // All other filters: EXCLUDE 0-spot participants (only active raffle entries)
        let matchesFilter;
        if (paymentFilter === 'drama') {
          matchesFilter = spots === 0;  // Waitlist
        } else if (paymentFilter === 'all') {
          matchesFilter = spots > 0;
        } else if (paymentFilter === 'paid') {
          matchesFilter = paid && spots > 0;
        } else if (paymentFilter === 'pending') {
          matchesFilter = !paid && spots > 0;
        } else if (paymentFilter === 'tabs') {
          matchesFilter = isTab && spots > 0;
        } else {
          matchesFilter = false;
        }

        // Use toggle for slightly better performance
        row.classList.toggle('hidden', !(matchesSearch && matchesFilter));
      });

      updateFooter();
    }

    // ============ TABLE SORTING ============
    function sortTable(column) {
      // Toggle sort direction if clicking same column
      if (appState.sortColumn === column) {
        appState.sortDirection = appState.sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        appState.sortColumn = column;
        appState.sortDirection = 'asc';
      }

      // Update header UI
      document.querySelectorAll('.p-table thead th.sortable').forEach(th => {
        th.classList.remove('sorted-asc', 'sorted-desc');
      });

      const activeHeader = document.querySelector(`.p-table thead th[data-sort="${column}"]`);
      if (activeHeader) {
        activeHeader.classList.add(`sorted-${appState.sortDirection}`);
      }

      // Efficient DOM reordering instead of rebuilding table
      reorderTableRows();
    }

    function reorderTableRows() {
      const tbody = document.getElementById('participantsTbody');
      const rows = Array.from(tbody.querySelectorAll('tr:not(#emptyRow)'));

      // Sort rows based on data attributes stored on the row
      rows.sort((rowA, rowB) => {
        let aVal, bVal;

        switch (appState.sortColumn) {
          case 'reddit':
            aVal = (rowA.dataset.reddit || '').toLowerCase();
            bVal = (rowB.dataset.reddit || '').toLowerCase();
            break;
          case 'comment':
            // Sort by index (chronological order) - lower index = older comment
            aVal = parseInt(rowA.dataset.index || '0');
            bVal = parseInt(rowB.dataset.index || '0');
            break;
          case 'spots':
            // Get spots from the Spots cell
            aVal = parseInt(rowA.querySelector('td:nth-child(5)')?.textContent || '0');
            bVal = parseInt(rowB.querySelector('td:nth-child(5)')?.textContent || '0');
            break;
          case 'paid':
            aVal = rowA.dataset.paid === 'true' ? 1 : 0;
            bVal = rowB.dataset.paid === 'true' ? 1 : 0;
            break;
          case 'tabbed':
            // Get tabbed from the Tabbed cell
            aVal = (rowA.querySelector('td:nth-child(3)')?.textContent || '').toLowerCase();
            bVal = (rowB.querySelector('td:nth-child(3)')?.textContent || '').toLowerCase();
            break;
          default:
            return 0;
        }

        if (appState.sortColumn === 'spots' || appState.sortColumn === 'paid') {
          // Numeric sort
          return appState.sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
        } else if (appState.sortColumn === 'comment') {
          // Chronological sort (reversed: asc = newest first, desc = oldest first)
          return appState.sortDirection === 'asc' ? bVal - aVal : aVal - bVal;
        } else {
          // String sort
          if (aVal < bVal) return appState.sortDirection === 'asc' ? -1 : 1;
          if (aVal > bVal) return appState.sortDirection === 'asc' ? 1 : -1;
          return 0;
        }
      });

      // Reorder DOM elements efficiently
      rows.forEach(row => tbody.appendChild(row));

      // Make sure empty row stays at the end
      const emptyRow = document.getElementById('emptyRow');
      if (emptyRow) {
        tbody.appendChild(emptyRow);
      }
    }

    async function saveToHistory(status, winner = null) {
      try {
        // Get current user
        let currentUsername = null;
        try {
          const userResult = await API.checkAuth();
          if (userResult.ok && userResult.data) {
            currentUsername = userResult.data.username;
          }
        } catch (e) {
          console.error('Failed to get current user:', e);
        }

        await API.saveToHistory({
          raffleDate: new Date().toISOString(),
          status: status,
          redditLink: appState.redditLink,
          totalSpots: appState.totalSpots,
          costPerSpot: appState.costPerSpot,
          participants: appState.participants,
          totalOwed: appState.participants.reduce((sum, p) => sum + (p.owed || 0), 0),
          totalPaid: appState.participants.filter(p => p.paid).reduce((sum, p) => sum + (p.owed || 0), 0),
          winner: winner,
          username: currentUsername,
          fastRaffleEnabled: appState.fastRaffleEnabled,
          fastRaffleStartTime: appState.fastRaffleStartTime
        });

        console.log(`‚úÖ Saved raffle to history for user: ${currentUsername}`);

        // Also log activity
        await API.logActivity({
          type: status === 'completed' ? 'completed' : 'cancelled',
          title: status === 'completed'
            ? `Raffle completed${winner ? ` - Winner: <span class="activity-highlight">${winner.username}</span>` : ''}`
            : 'Raffle cancelled',
          details: status === 'completed'
            ? `${appState.participants.length} participants ‚Ä¢ Total value: $${appState.participants.reduce((sum, p) => sum + (p.owed || 0), 0).toLocaleString()}${winner ? ` ‚Ä¢ Winning spot: #${winner.spot}` : ''}`
            : `${appState.participants.length} participants ‚Ä¢ Raffle cancelled before completion`,
          badge: status === 'completed' ? 'Completed' : 'Cancelled'
        });
      } catch (e) {
        console.error('Failed to save to history:', e);
      }
    }

  async function resetRaffle() {
      console.log('üîÑ resetRaffle() called - clearing app state and database');
      appState.activeRaffleId = null;  // Clear raffle ID
      appState.redditLink = '';
      appState.totalSpots = null;
      appState.costPerSpot = null;
      appState.participants = [];
      appState.fastRaffleEnabled = false;
      appState.fastRaffleStartTime = null;

      await clearState();
      console.log('‚úÖ resetRaffle() complete - raffle cleared from database');

      // Stop and hide timer
      stopFastRaffleTimer();

      const tbody = document.getElementById("participantsTbody");
      tbody.innerHTML = '<tr id="emptyRow"><td colspan="8" style="padding:26px 24px; text-align:center; color:#64748b;">No participants yet. Click "Setup" to configure your raffle.</td></tr>';

      document.getElementById("redditLinkInput").value = '';
      document.getElementById("totalSpotsInput").value = ''; // CHANGED from '100' to ''
      document.getElementById("spotCostInput").value = ''; // CHANGED from '50' to ''
      const fastRaffleCheckbox = document.getElementById("fastRaffleCheckbox");
      if (fastRaffleCheckbox) fastRaffleCheckbox.checked = false;
      document.getElementById("participantSearch").value = '';
      document.getElementById("paymentFilter").value = 'all';

      updateStats();
      updateFooter();
    }

    // ============ SIDEBAR NAVIGATION ============
    (function () {
      const nav = document.getElementById("sidebarNav");
      const square = document.getElementById("activeSquare");
      function moveSquareTo(item) {
        const navRect = nav.getBoundingClientRect();
        const itemRect = item.getBoundingClientRect();
        const navTop = parseFloat(getComputedStyle(nav).top) || 0;
        square.style.top = navTop + (itemRect.top - navRect.top) + "px";
      }
      const active = nav.querySelector(".is-active");
      if (active) {
        // Disable transition for initial positioning
        square.style.transition = "none";
        moveSquareTo(active);
        square.style.opacity = "1";
        // Re-enable transition after positioning
        setTimeout(() => {
          square.style.transition = "top 140ms ease";
        }, 50);
      }
    })();

    // ============ COLUMN RESIZE ============
    (function () {
      const table = document.getElementById("participantsTable");
      if (!table) return;

      const STORAGE_KEY = "raffleui_participants_colwidths_v1";
      const colgroup = table.querySelector("colgroup");
      const cols = Array.from(colgroup.querySelectorAll("col"));
      const ths = Array.from(table.querySelectorAll("thead th"));

      try {
        const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || "null");
        if (saved && Array.isArray(saved) && saved.length === cols.length) {
          saved.forEach((w, i) => {
            if (typeof w === "number" && w > 40) cols[i].style.width = Math.round(w) + "px";
          });
        }
      } catch (_) {}

      let isDragging = false;
      let startX = 0;
      let startWidth = 0;
      let colIndex = -1;

      function onMove(e) {
        if (!isDragging) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const dx = clientX - startX;
        const minW = 70;
        const newW = Math.max(minW, startWidth + dx);
        cols[colIndex].style.width = Math.round(newW) + "px";
        document.documentElement.classList.add("resizing");
      }

      function saveWidths() {
        const widths = cols.map(c => Math.round(parseFloat(getComputedStyle(c).width) || 0));
        localStorage.setItem(STORAGE_KEY, JSON.stringify(widths));
      }

      function onUp() {
        if (!isDragging) return;
        isDragging = false;
        colIndex = -1;
        document.documentElement.classList.remove("resizing");
        saveWidths();
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
        window.removeEventListener("touchmove", onMove, { passive:false });
        window.removeEventListener("touchend", onUp);
      }

      ths.forEach((th) => {
        const handle = th.querySelector(".col-resizer");
        if (!handle) return;

        handle.addEventListener("mousedown", (e) => {
          e.preventDefault();
          const idx = parseInt(th.dataset.col, 10);
          if (!Number.isFinite(idx)) return;

          isDragging = true;
          colIndex = idx;
          startX = e.clientX;
          startWidth = parseFloat(getComputedStyle(cols[idx]).width) || cols[idx].getBoundingClientRect().width;

          window.addEventListener("mousemove", onMove);
          window.addEventListener("mouseup", onUp);
        });

        handle.addEventListener("touchstart", (e) => {
          e.preventDefault();
          const idx = parseInt(th.dataset.col, 10);
          if (!Number.isFinite(idx)) return;

          isDragging = true;
          colIndex = idx;
          startX = e.touches[0].clientX;
          startWidth = parseFloat(getComputedStyle(cols[idx]).width) || cols[idx].getBoundingClientRect().width;

          window.addEventListener("touchmove", onMove, { passive:false });
          window.addEventListener("touchend", onUp);
        }, { passive:false });
      });
    })();

    // ============ SETTINGS BUTTON ============
    document.getElementById("settingsBtn").addEventListener("click", () => {
      window.location.href = "/settings";
    });

 // ============ SETUP MODAL ============
    (function () {
      const setupBtn = document.getElementById("setupBtn");
      const modal = document.getElementById("setupModal");
      const cancelBtn = document.getElementById("modalCancelBtn");
      const saveBtn = document.getElementById("modalSaveBtn");

      const redditLinkInput = document.getElementById("redditLinkInput");
      const totalSpotsInput = document.getElementById("totalSpotsInput");
      const spotCostInput = document.getElementById("spotCostInput");
      const pollingIntervalInput = document.getElementById("pollingIntervalInput");
      const fastRaffleCheckbox = document.getElementById("fastRaffleCheckbox");

      setupBtn.addEventListener("click", () => {
        modal.classList.add("show");
      });

      function closeModal() {
        modal.classList.remove("show");
      }

      cancelBtn.addEventListener("click", closeModal);

      // REMOVED: modal.addEventListener("click", ...) to prevent closing on outside click

      // Validate Reddit URL
      function validateRedditUrl(url) {
        if (!url || url.trim() === '') {
          return { valid: true, url: '' }; // Allow empty URLs
        }

        const trimmedUrl = url.trim();

        // Check if it's a valid Reddit post URL
        const redditRegex = /^https?:\/\/(www\.)?(reddit\.com|old\.reddit\.com)\/r\/[^\/]+\/comments\/[^\/]+\/[^\/]+\/?/i;

        if (!redditRegex.test(trimmedUrl)) {
          return {
            valid: false,
            error: 'Invalid Reddit URL format.\n\nPlease enter a complete Reddit post URL like:\nhttps://reddit.com/r/WatchURaffle/comments/abc123/post_title/'
          };
        }

        // Ensure it has https://
        let validUrl = trimmedUrl;
        if (!validUrl.startsWith('http://') && !validUrl.startsWith('https://')) {
          validUrl = 'https://' + validUrl;
        }

        return { valid: true, url: validUrl };
      }

      saveBtn.addEventListener("click", async () => {
        const redditLinkValue = redditLinkInput.value;

        // Validate all fields are filled out
        if (!redditLinkValue || !redditLinkValue.trim()) {
          showErrorToast('Reddit Link Required', [
            'Please enter a Reddit post URL to continue.',
            'Example: https://reddit.com/r/WatchURaffle/comments/abc123/post_title/'
          ]);
          redditLinkInput.focus();
          return;
        }

        if (!totalSpotsInput.value || totalSpotsInput.value.trim() === '') {
          showErrorToast('Total Spots Required', [
            'Please enter the total number of spots for this raffle.'
          ]);
          totalSpotsInput.focus();
          return;
        }

        if (!spotCostInput.value || spotCostInput.value.trim() === '') {
          showErrorToast('Cost Per Spot Required', [
            'Please enter the cost per spot in dollars.'
          ]);
          spotCostInput.focus();
          return;
        }

        // Validate numeric values
        const totalSpots = parseInt(totalSpotsInput.value);
        const spotCost = parseFloat(spotCostInput.value);

        if (isNaN(totalSpots) || totalSpots <= 0) {
          showErrorToast('Invalid Total Spots', [
            'Total spots must be a positive number.'
          ]);
          totalSpotsInput.focus();
          return;
        }

        if (isNaN(spotCost) || spotCost <= 0) {
          showErrorToast('Invalid Cost Per Spot', [
            'Cost per spot must be a positive number (minimum $0.01).'
          ]);
          spotCostInput.focus();
          return;
        }

        // Validate Reddit URL
        const validation = validateRedditUrl(redditLinkValue);
        if (!validation.valid) {
          showErrorToast('Invalid Reddit URL format', [
            'Please enter a complete Reddit post URL like:',
            'https://reddit.com/r/WatchURaffle/comments/abc123/post_title/'
          ]);
          redditLinkInput.focus();
          return;
        }

        const data = {
          redditLink: validation.url,
          totalSpots: totalSpots,
          spotCost: spotCost,
          fastRaffleEnabled: fastRaffleCheckbox.checked
        };

        appState.redditLink = data.redditLink;
        appState.totalSpots = data.totalSpots;
        appState.costPerSpot = data.spotCost;
        appState.fastRaffleEnabled = data.fastRaffleEnabled;

        // Set creation timestamp if this is the first time setup is saved
        if (!appState.createdAt) {
          appState.createdAt = new Date().toISOString();
          console.log('üïê Raffle creation timestamp set:', appState.createdAt);
        }

        // Start fast raffle timer if enabled
        if (data.fastRaffleEnabled) {
          appState.fastRaffleStartTime = Date.now();
          startFastRaffleTimer();
        } else {
          stopFastRaffleTimer();
        }

        await saveState();

        // Debug: Verify raffle ID was saved
        console.log('üîç After saveState(), activeRaffleId =', appState.activeRaffleId);

        updateStats();

        // Log activity
        await API.logActivity({
          type: 'setup',
          title: 'Raffle setup configured',
          details: `${data.totalSpots} spots @ $${data.spotCost} each${data.redditLink ? ' ‚Ä¢ Reddit link added' : ''}`,
          badge: 'Raffle Setup'
        });

        const details = [];
        if (data.redditLink) {
          details.push('üìù Reddit post linked');
        }
        details.push(`üéØ ${data.totalSpots} spots @ $${data.spotCost} each`);
        details.push(`ü§ñ Auto-scanning every 10 sec`);

        showToast('Setup Saved Successfully!', details);
        closeModal();
      });
    })();

 // ============ SUMMARY MODAL ============
    (function () {
      const summaryBtn = document.getElementById("summaryBtn");
      const modal = document.getElementById("summaryModal");
      const closeBtn = document.getElementById("summaryCloseBtn");

      summaryBtn.addEventListener("click", () => {
        populateSummary();
        modal.classList.add("show");
      });

      function closeModal() {
        modal.classList.remove("show");
      }

      closeBtn.addEventListener("click", closeModal);

      modal.addEventListener("click", (e) => {
        if (e.target === modal) closeModal();
      });

      function populateSummary() {
        // ‚úÖ NEW LOGIC: Separate tabbed and non-tabbed ENTRIES per person
        const payerGroupsNonTabbed = {};
        const tabbedEntries = []; // ‚úÖ NEW: Store individual payer-recipient pairs

        appState.participants.forEach(p => {
          // Check if this entry has a tabbed assignment
          const tabbedUser = p.tabbed || '';
          const isTabbed = !!tabbedUser;

          const payer = p.redditUser;

          if (isTabbed) {
            // ‚úÖ NEW: Create individual entry for each payer-recipient pair
            tabbedEntries.push({
              payer: payer,
              payerName: p.name,
              recipient: tabbedUser,
              spots: parseInt(p.spots) || 0,
              owed: parseFloat(p.owed) || 0,
              paid: p.paid
            });
          } else {
            // ‚úÖ This entry is NON-TABBED - add to non-tabbed groups
            if (!payerGroupsNonTabbed[payer]) {
              payerGroupsNonTabbed[payer] = {
                redditUser: payer,
                name: p.name,
                spots: 0,
                owed: 0,
                paid: p.paid,
                recipients: []
              };
            }

            payerGroupsNonTabbed[payer].spots += parseInt(p.spots) || 0;
            payerGroupsNonTabbed[payer].owed += parseFloat(p.owed) || 0;
          }
        });

        // Combine arrays
        const nonTabbedArray = Object.values(payerGroupsNonTabbed);

        // Separate by paid status
        const unpaidNonTabbed = nonTabbedArray.filter(p => !p.paid && p.spots > 0);
        const unpaidTabbedRaw = tabbedEntries.filter(e => !e.paid && e.spots > 0);
        const paidNonTabbed = nonTabbedArray.filter(p => p.paid && p.spots > 0);
        const paidTabbedRaw = tabbedEntries.filter(e => e.paid && e.spots > 0);

        // ‚úÖ GROUP tabbed entries by payer (combine multiple recipients)
        const groupTabbedByPayer = (entries) => {
          const grouped = {};
          entries.forEach(entry => {
            const key = entry.payer;
            if (!grouped[key]) {
              grouped[key] = {
                payer: entry.payer,
                payerName: entry.payerName,
                recipients: new Set(), // ‚úÖ Use Set to auto-deduplicate
                spots: 0,
                owed: 0,
                paid: entry.paid
              };
            }
            grouped[key].recipients.add(entry.recipient); // ‚úÖ Add to Set
            grouped[key].spots += entry.spots;
            grouped[key].owed += entry.owed;
          });
          // ‚úÖ Convert Set to Array for each group
          return Object.values(grouped).map(group => ({
            ...group,
            recipients: Array.from(group.recipients)
          }));
        };

        const unpaidTabbed = groupTabbedByPayer(unpaidTabbedRaw);
        const paidTabbed = groupTabbedByPayer(paidTabbedRaw);

        // Sort all arrays alphabetically
        unpaidNonTabbed.sort((a, b) => a.redditUser.localeCompare(b.redditUser));
        unpaidTabbed.sort((a, b) => a.payer.localeCompare(b.payer));
        paidNonTabbed.sort((a, b) => a.redditUser.localeCompare(b.redditUser));
        paidTabbed.sort((a, b) => a.payer.localeCompare(b.payer));

        const totalOwed = [...unpaidNonTabbed, ...unpaidTabbed].reduce((sum, p) => sum + (p.owed || 0), 0);
        const totalPaid = [...paidNonTabbed, ...paidTabbed].reduce((sum, p) => sum + (p.owed || 0), 0);
        const totalParticipants = nonTabbedArray.length + tabbedEntries.length;

        document.getElementById("summaryTotalOwed").textContent = `$${totalOwed.toLocaleString()}`;
        document.getElementById("summaryTotalParticipants").textContent = totalParticipants;

        const summaryList = document.getElementById("summaryList");
        summaryList.innerHTML = '';

        if (appState.participants.length === 0) {
          summaryList.innerHTML = '<div style="padding: 40px; text-align: center; color: #9CA3AF;">No participants yet</div>';
          return;
        }

        // Add summary stats header
        const statsHeader = document.createElement('div');
        statsHeader.style.cssText = 'display: flex; gap: 16px; padding: 16px; background: #F3F4F6; border-radius: 8px; margin-bottom: 20px;';
        statsHeader.innerHTML = `
          <div style="flex: 1; text-align: center;">
            <div style="font-size: 12px; color: #6B7280; margin-bottom: 4px;">Total Collected</div>
            <div style="font-size: 20px; font-weight: 700; color: #16a34a;">$${totalPaid.toLocaleString()}</div>
          </div>
          <div style="flex: 1; text-align: center;">
            <div style="font-size: 12px; color: #6B7280; margin-bottom: 4px;">Still Owed</div>
            <div style="font-size: 20px; font-weight: 700; color: #dc2626;">$${totalOwed.toLocaleString()}</div>
          </div>
        `;
        summaryList.appendChild(statsHeader);

        // ‚úÖ Unpaid NON-TABBED participants section
        if (unpaidNonTabbed.length > 0) {
          const unpaidHeader = document.createElement('div');
          unpaidHeader.style.cssText = 'font-size: 14px; font-weight: 700; color: #dc2626; padding: 12px 0 8px 0; border-top: 2px solid #fee2e2;';
          unpaidHeader.innerHTML = `‚è± Pending Payment (${unpaidNonTabbed.length})`;
          summaryList.appendChild(unpaidHeader);

          unpaidNonTabbed.forEach(participant => {
            const initial = participant.redditUser.charAt(2).toUpperCase();
            const displayName = getNameFromMapping(participant.redditUser) || participant.name || '';
            const nameDisplay = displayName ? `<div style="font-size: 11px; color: #64748b; margin-top: 2px;">${displayName}</div>` : '';

            // ‚úÖ NEW: Show who this payment is from (tab recipients)
            const forNote = participant.recipients.length > 0
              ? ` <span style="font-size: 11px; color: #94a3b8;">(from ${participant.recipients.join(', ')})</span>`
              : '';

            const participantEl = document.createElement('div');
            participantEl.className = 'summary-participant';
            participantEl.style.background = '#fef3c7';
            participantEl.innerHTML = `
              <div class="summary-user-info">
                <div class="summary-avatar">${initial}</div>
                <div>
                  <div class="summary-username">${participant.redditUser}${forNote}</div>
                  ${nameDisplay}
                </div>
              </div>
              <div class="summary-stats">
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Spots</div>
                  <div class="summary-stat-value">${participant.spots}</div>
                </div>
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Owed</div>
                  <div class="summary-stat-value summary-owed-value" style="color: #dc2626; font-weight: 700;">$${parseFloat(participant.owed).toFixed(2)}</div>
                </div>
              </div>
            `;
            summaryList.appendChild(participantEl);
          });
        }

        // ‚úÖ Unpaid TABBED participants section
        if (unpaidTabbed.length > 0) {
          const unpaidTabbedHeader = document.createElement('div');
          unpaidTabbedHeader.style.cssText = 'font-size: 14px; font-weight: 700; color: #dc2626; padding: 20px 0 8px 0; border-top: 2px solid #fee2e2; margin-top: 16px;';
          unpaidTabbedHeader.innerHTML = `‚è± Pending Payment - Tabbed Spots (${unpaidTabbed.length})`;
          summaryList.appendChild(unpaidTabbedHeader);

          unpaidTabbed.forEach(entry => {
            // Get payer's real name from mapping
            const payerRealName = getNameFromMapping(entry.payer) || entry.payerName || 'Unknown';

            // ‚úÖ Combine recipients with commas
            const recipientsList = entry.recipients.join(', ');
            const spotsText = entry.spots === 1 ? 'spot' : 'spots';

            const participantEl = document.createElement('div');
            participantEl.className = 'summary-participant';
            participantEl.style.background = '#fef3c7';
            participantEl.innerHTML = `
              <div class="summary-user-info" style="flex: 1;">
                <div style="font-size: 13px; font-weight: 600; color: #1e293b;">
                  ${recipientsList} paying ${entry.spots} ${spotsText} for ${entry.payer} (${payerRealName})
                </div>
              </div>
              <div class="summary-stats">
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Spots</div>
                  <div class="summary-stat-value">${entry.spots}</div>
                </div>
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Owed</div>
                  <div class="summary-stat-value summary-owed-value" style="color: #dc2626; font-weight: 700;">$${entry.owed.toFixed(2)}</div>
                </div>
              </div>
            `;
            summaryList.appendChild(participantEl);
          });
        }

        // ‚úÖ Paid NON-TABBED participants section
        if (paidNonTabbed.length > 0) {
          const paidHeader = document.createElement('div');
          paidHeader.style.cssText = 'font-size: 14px; font-weight: 700; color: #16a34a; padding: 20px 0 8px 0; border-top: 2px solid #dcfce7; margin-top: 16px;';
          paidHeader.innerHTML = `‚úì Paid (${paidNonTabbed.length})`;
          summaryList.appendChild(paidHeader);

          paidNonTabbed.forEach(participant => {
            const initial = participant.redditUser.charAt(2).toUpperCase();
            const displayName = getNameFromMapping(participant.redditUser) || participant.name || '';
            const nameDisplay = displayName ? `<div style="font-size: 11px; color: #64748b; margin-top: 2px;">${displayName}</div>` : '';

            // ‚úÖ NEW: Show who this payment is from (tab recipients)
            const forNote = participant.recipients.length > 0
              ? ` <span style="font-size: 11px; color: #94a3b8;">(from ${participant.recipients.join(', ')})</span>`
              : '';

            const participantEl = document.createElement('div');
            participantEl.className = 'summary-participant';
            participantEl.style.background = '#dcfce7';
            participantEl.innerHTML = `
              <div class="summary-user-info">
                <div class="summary-avatar">${initial}</div>
                <div>
                  <div class="summary-username">${participant.redditUser}${forNote}</div>
                  ${nameDisplay}
                </div>
              </div>
              <div class="summary-stats">
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Spots</div>
                  <div class="summary-stat-value">${participant.spots}</div>
                </div>
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Paid</div>
                  <div class="summary-stat-value" style="color: #16a34a; font-weight: 700;">$${parseFloat(participant.owed).toFixed(2)}</div>
                </div>
              </div>
            `;
            summaryList.appendChild(participantEl);
          });
        }

        // ‚úÖ Paid TABBED participants section
        if (paidTabbed.length > 0) {
          const paidTabbedHeader = document.createElement('div');
          paidTabbedHeader.style.cssText = 'font-size: 14px; font-weight: 700; color: #16a34a; padding: 20px 0 8px 0; border-top: 2px solid #dcfce7; margin-top: 16px;';
          paidTabbedHeader.innerHTML = `‚úì Paid - Tabbed Spots (${paidTabbed.length})`;
          summaryList.appendChild(paidTabbedHeader);

          paidTabbed.forEach(entry => {
            // Get payer's real name from mapping
            const payerRealName = getNameFromMapping(entry.payer) || entry.payerName || 'Unknown';

            // ‚úÖ Combine recipients with commas
            const recipientsList = entry.recipients.join(', ');
            const spotsText = entry.spots === 1 ? 'spot' : 'spots';

            const participantEl = document.createElement('div');
            participantEl.className = 'summary-participant';
            participantEl.style.background = '#dcfce7';
            participantEl.innerHTML = `
              <div class="summary-user-info" style="flex: 1;">
                <div style="font-size: 13px; font-weight: 600; color: #1e293b;">
                  ${recipientsList} paying ${entry.spots} ${spotsText} for ${entry.payer} (${payerRealName})
                </div>
              </div>
              <div class="summary-stats">
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Spots</div>
                  <div class="summary-stat-value">${entry.spots}</div>
                </div>
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Paid</div>
                  <div class="summary-stat-value" style="color: #16a34a; font-weight: 700;">$${entry.owed.toFixed(2)}</div>
                </div>
              </div>
            `;
            summaryList.appendChild(participantEl);
          });
        }
      }
    })();



 // ============ NAME IMPORT MODAL ============
    // Note: This modal is now primarily used in Settings page
    // Keeping the handler logic here for potential inline use
    (function () {
      const modal = document.getElementById("nameImportModal");
      if (!modal) return; // Modal might not exist on this page

      const closeBtn = document.getElementById("nameImportCloseBtn");
      const fileInput = document.getElementById("nameFileInput");
      const importNowBtn = document.getElementById("nameImportBtn");
      const exportBtn = document.getElementById("nameExportBtn");
      const clearBtn = document.getElementById("nameClearBtn");
      const preview = document.getElementById("importPreview");
      const previewList = document.getElementById("importPreviewList");
      const importCount = document.getElementById("importCount");

      let parsedData = null;

      function closeModal() {
        modal.classList.remove("show");
        fileInput.value = '';
        preview.style.display = 'none';
        parsedData = null;
        importNowBtn.disabled = true;
      }

      if (closeBtn) closeBtn.addEventListener("click", closeModal);

      if (modal) {
        modal.addEventListener("click", (e) => {
          if (e.target === modal) closeModal();
        });
      }

      // File input change handler
      fileInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          const data = await parseFile(file);
          parsedData = data;

          // Show preview
          const entries = Object.entries(data);
          const previewEntries = entries.slice(0, 5);

          previewList.innerHTML = previewEntries
            .map(([reddit, name]) => `${reddit} ‚Üí ${name}`)
            .join('<br>');

          importCount.textContent = `Ready to import ${entries.length} name mappings`;
          preview.style.display = 'block';
          importNowBtn.disabled = false;

        } catch (error) {
          showErrorToast('File Parse Error', [error.message]);
          preview.style.display = 'none';
          importNowBtn.disabled = true;
        }
      });

      // Parse file (CSV or Excel)
      async function parseFile(file) {
        const fileName = file.name.toLowerCase();

        if (fileName.endsWith('.csv') || fileName.endsWith('.tsv') || fileName.endsWith('.txt')) {
          return parseCSV(file);
        } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
          return parseExcel(file);
        } else {
          throw new Error('Unsupported file format. Use CSV, TSV, or Excel (.xlsx, .xls)');
        }
      }

      // Parse CSV
      async function parseCSV(file) {
        const text = await file.text();
        const lines = text.split('\n').filter(line => line.trim());
        const mappings = {};

        // Skip header if present
        const startIndex = lines[0].toLowerCase().includes('reddit') ? 1 : 0;

        for (let i = startIndex; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          const parts = line.split(',').map(p => p.trim());
          if (parts.length >= 2) {
            const reddit = parts[0];
            const name = parts.slice(1).join(',').replace(/^["']|["']$/g, ''); // Handle quoted names
            if (reddit && name) {
              mappings[reddit] = name;
            }
          }
        }

        return mappings;
      }

      // Parse Excel
      async function parseExcel(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = (e) => {
            try {
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
              const rows = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });

              const mappings = {};
              // Skip header if present
              const startIndex = rows[0] && String(rows[0][0]).toLowerCase().includes('reddit') ? 1 : 0;

              for (let i = startIndex; i < rows.length; i++) {
                const row = rows[i];
                if (row && row.length >= 2) {
                  const reddit = String(row[0]).trim();
                  const name = String(row[1]).trim();
                  if (reddit && name) {
                    mappings[reddit] = name;
                  }
                }
              }

              resolve(mappings);
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = () => reject(new Error('Failed to read file'));
          reader.readAsArrayBuffer(file);
        });
      }

      // Import button handler
      importNowBtn.addEventListener("click", () => {
        if (!parsedData) return;

        // Merge with existing mappings
        const existing = loadAllMappings();
        const merged = { ...existing, ...parsedData };
        saveAllMappings(merged);

        // Rebuild table to show new names
        rebuildTable();
        filterAndSearch(); // ‚úÖ Re-apply current filter

        showToast('Names Imported!', [
          `‚úì ${Object.keys(parsedData).length} mappings imported`,
          `üìã Total mappings: ${Object.keys(merged).length}`,
          'üîÑ Names updated in table'
        ]);

        closeModal();
      });

      // Export button handler
      exportBtn.addEventListener("click", () => {
        const csv = exportMappingsAsCSV();
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `reddit_names_${new Date().toISOString().split('T')[0]}.csv`;
        a.click();
        URL.revokeObjectURL(url);

        showToast('Mappings Exported!', ['üì• CSV file downloaded']);
      });

      // Clear button handler
      clearBtn.addEventListener("click", () => {
        if (confirm('Are you sure you want to clear all name mappings? This cannot be undone.')) {
          clearAllMappings();
          rebuildTable();
          filterAndSearch(); // ‚úÖ Re-apply current filter
          showToast('Mappings Cleared!', ['üóëÔ∏è All name mappings removed']);
        }
      });
    })();

 // ============ RESTRICTION MODAL ============
    (function () {
      const restrictionModal = document.getElementById("restrictionModal");
      const restrictionMessage = document.getElementById("restrictionMessage");
      const restrictionModalTitle = document.getElementById("restrictionModalTitle");
      const restrictionOkBtn = document.getElementById("restrictionOkBtn");
      const restrictionCancelRaffleBtn = document.getElementById("restrictionCancelRaffleBtn");

      window.showRestrictionModal = function(message, showCancelButton = false, title = "Cannot Finish Raffle!") {
        restrictionModalTitle.textContent = title;
        restrictionMessage.innerHTML = message;
        restrictionCancelRaffleBtn.style.display = showCancelButton ? "block" : "none";
        restrictionModal.classList.add("show");
      };

      restrictionOkBtn.addEventListener("click", () => {
        restrictionModal.classList.remove("show");
      });

      restrictionCancelRaffleBtn.addEventListener("click", () => {
        restrictionModal.classList.remove("show");
        showCancelConfirmModal();
      });

      restrictionModal.addEventListener("click", (e) => {
        if (e.target === restrictionModal) {
          restrictionModal.classList.remove("show");
        }
      });
    })();

 // ============ CANCEL RAFFLE CONFIRMATION MODAL ============
    (function () {
      const cancelConfirmModal = document.getElementById("cancelConfirmModal");
      const cancelConfirmOkBtn = document.getElementById("cancelConfirmOkBtn");
      const cancelConfirmCancelBtn = document.getElementById("cancelConfirmCancelBtn");

      window.showCancelConfirmModal = function() {
        cancelConfirmModal.classList.add("show");
      };

      cancelConfirmOkBtn.addEventListener("click", async () => {
        cancelConfirmModal.classList.remove("show");
        await saveToHistory('cancelled', null);
        showToast('Raffle Cancelled', ['Saved to history as cancelled']);
        await resetRaffle();
      });

      cancelConfirmCancelBtn.addEventListener("click", () => {
        cancelConfirmModal.classList.remove("show");
      });

      cancelConfirmModal.addEventListener("click", (e) => {
        if (e.target === cancelConfirmModal) {
          cancelConfirmModal.classList.remove("show");
        }
      });
    })();

 // ============ PAYPAL SCAN CONFIRMATION MODAL ============
    (function () {
      const paypalScanModal = document.getElementById("paypalScanModal");
      const paypalScanOkBtn = document.getElementById("paypalScanOkBtn");
      const paypalScanCancelBtn = document.getElementById("paypalScanCancelBtn");
      let scanCallback = null;

      window.showPaypalScanModal = function(onConfirm) {
        scanCallback = onConfirm;
        paypalScanModal.classList.add("show");
      };

      paypalScanOkBtn.addEventListener("click", () => {
        paypalScanModal.classList.remove("show");
        if (scanCallback) {
          scanCallback();
          scanCallback = null;
        }
      });

      paypalScanCancelBtn.addEventListener("click", () => {
        paypalScanModal.classList.remove("show");
        scanCallback = null;
      });

      paypalScanModal.addEventListener("click", (e) => {
        if (e.target === paypalScanModal) {
          paypalScanModal.classList.remove("show");
          scanCallback = null;
        }
      });
    })();

 // ============ FINISH RAFFLE MODAL ============
    (function () {
      const finishBtn = document.getElementById("finishRaffleBtn");
      const modal = document.getElementById("finishModal");
      const completeBtn = document.getElementById("finishCompleteBtn");
      const winnerEntriesContainer = document.getElementById("winnerEntriesContainer");
      let winnerCount = 1;

   finishBtn.addEventListener("click", () => {
        // Check if setup is complete first
        if (!appState.redditLink || !appState.costPerSpot || appState.totalSpots === null) {
          showRestrictionModal(`Setup is incomplete.<br>Please configure Reddit Link, Total Spots, and Cost Per Spot before finishing the raffle.`);
          return;
        }

        // Calculate current stats - ‚úÖ Exclude Waitlist participants (0 spots)
        const raffleParticipants = appState.participants.filter(p => (p.spots || 0) > 0);
        const spotsClaimed = raffleParticipants.reduce((sum, p) => sum + (p.spots || 0), 0);
        const spotsRemaining = appState.totalSpots !== null ? Math.max(0, appState.totalSpots - spotsClaimed) : 0;
        const totalOwed = raffleParticipants.reduce((sum, p) => sum + (p.owed || 0), 0);
        const totalPaid = raffleParticipants.filter(p => p.paid).reduce((sum, p) => sum + (p.owed || 0), 0);
        const unpaidAmount = totalOwed - totalPaid;

        // Check if raffle can be finished
        if (spotsRemaining > 0) {
          showRestrictionModal(`There are still <strong>${spotsRemaining}</strong> spots remaining.<br>All spots must be filled before selecting a winner.`, true);
          return;
        }

        if (unpaidAmount > 0) {
          showRestrictionModal(`There is still <strong>$${unpaidAmount.toLocaleString()}</strong> owed.<br>All payments must be collected before selecting a winner.`, true);
          return;
        }

        // If all checks pass, open the modal
        winnerCount = 1;
        updateWinnerCountButtons();
        renderWinnerEntries();
        completeBtn.disabled = true;

        modal.classList.add("show");

        // Populate username dropdown
        populateUsernameDropdown();
      });

      function closeModal() {
        modal.classList.remove("show");
      }

      modal.addEventListener("click", (e) => {
        if (e.target === modal) closeModal();
      });

      // Winner count button handlers
      document.querySelectorAll('.winner-count-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          winnerCount = parseInt(btn.dataset.count);
          updateWinnerCountButtons();
          renderWinnerEntries();
          validateWinnerInput();
        });
      });

      function updateWinnerCountButtons() {
        document.querySelectorAll('.winner-count-btn').forEach(btn => {
          if (parseInt(btn.dataset.count) === winnerCount) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });

        // Update modal text
        const modalText = document.getElementById('finishModalText');
        if (modalText) {
          if (winnerCount === 1) {
            modalText.textContent = 'Enter the winner\'s information to complete the raffle.';
          } else {
            modalText.textContent = `Enter information for all ${winnerCount} winners to complete the raffle.`;
          }
        }
      }

      function renderWinnerEntries() {
        winnerEntriesContainer.innerHTML = '';
        const totalSpots = appState.totalSpots || 100;

        for (let i = 0; i < winnerCount; i++) {
          const entry = document.createElement('div');
          entry.className = 'winner-entry';
          entry.innerHTML = `
            <div class="winner-entry-header">${winnerCount === 1 ? 'Winner' : `Winner #${i + 1}`}</div>
            <div class="form-group" style="margin-bottom: 12px;">
              <label class="form-label">Reddit Username</label>
              <div class="username-dropdown-container">
                <input
                  type="text"
                  class="form-input winner-username-input"
                  data-index="${i}"
                  placeholder="Search Reddit username..."
                  autocomplete="off"
                />
                <div class="username-dropdown-list" data-index="${i}"></div>
              </div>
            </div>
            <div class="form-group">
              <label class="form-label">Winning Spot Number</label>
              <input
                type="number"
                class="form-input winner-spot-input"
                data-index="${i}"
                placeholder="Enter spot number (1-${totalSpots})"
                min="1"
                max="${totalSpots}"
              />
            </div>
          `;
          winnerEntriesContainer.appendChild(entry);
        }

        // Attach event listeners
        attachWinnerInputListeners();
      }

      function attachWinnerInputListeners() {
        // Username inputs
        document.querySelectorAll('.winner-username-input').forEach(input => {
          input.addEventListener('input', (e) => {
            filterUsernameDropdown(e.target.value, parseInt(e.target.dataset.index));
            validateWinnerInput();
          });

          input.addEventListener('focus', (e) => {
            if (e.target.value) {
              filterUsernameDropdown(e.target.value, parseInt(e.target.dataset.index));
            }
          });
        });

        // Spot inputs
        document.querySelectorAll('.winner-spot-input').forEach(input => {
          input.addEventListener('input', validateWinnerInput);
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.username-dropdown-container')) {
            document.querySelectorAll('.username-dropdown-list').forEach(list => {
              list.classList.remove('show');
            });
          }
        });
      }

         // Populate username dropdown with unique Reddit usernames
      function populateUsernameDropdown() {
        // Get unique Reddit usernames
        const usernames = [...new Set(appState.participants.map(p => p.redditUser))].sort();

        // Store for filtering
        window.allUsernames = usernames;
      }

      // Filter and display username dropdown
      function filterUsernameDropdown(searchTerm, index) {
        const dropdownList = document.querySelector(`.username-dropdown-list[data-index="${index}"]`);
        if (!dropdownList) return;

        const searchLower = searchTerm.toLowerCase();

        // Filter usernames
        const filtered = window.allUsernames.filter(u => u.toLowerCase().includes(searchLower));

        // Clear list
        dropdownList.innerHTML = '';

        if (searchTerm && filtered.length > 0) {
          filtered.forEach(username => {
            const item = document.createElement('div');
            item.className = 'username-dropdown-item';
            item.textContent = username;
            item.addEventListener('click', () => {
              const input = document.querySelector(`.winner-username-input[data-index="${index}"]`);
              input.value = username;
              dropdownList.classList.remove('show');
              validateWinnerInput();

              // Focus on spot input
              const spotInput = document.querySelector(`.winner-spot-input[data-index="${index}"]`);
              if (spotInput) spotInput.focus();
            });
            dropdownList.appendChild(item);
          });
          dropdownList.classList.add('show');
        } else {
          dropdownList.classList.remove('show');
        }
      }

      function validateWinnerInput() {
        const totalSpots = appState.totalSpots || 100;
        let allValid = true;

        const usernameInputs = document.querySelectorAll('.winner-username-input');
        const spotInputs = document.querySelectorAll('.winner-spot-input');

        // Check each winner entry
        for (let i = 0; i < winnerCount; i++) {
          const username = usernameInputs[i]?.value.trim();
          const spotValue = parseInt(spotInputs[i]?.value);
          const hasUsername = username !== '';
          const hasSpot = spotInputs[i]?.value !== '' && spotValue > 0 && spotValue <= totalSpots;

          if (!hasUsername || !hasSpot) {
            allValid = false;
            break;
          }
        }

        // Check for duplicate spots
        if (allValid) {
          const spots = Array.from(spotInputs).map(input => parseInt(input.value));
          const uniqueSpots = new Set(spots);
          if (uniqueSpots.size !== spots.length) {
            allValid = false;
          }
        }

        completeBtn.disabled = !allValid;
      }

      completeBtn.addEventListener("click", async () => {
        const totalSpots = appState.totalSpots || 100;
        const winners = [];

        // Collect all winner data
        const usernameInputs = document.querySelectorAll('.winner-username-input');
        const spotInputs = document.querySelectorAll('.winner-spot-input');

        for (let i = 0; i < winnerCount; i++) {
          const username = usernameInputs[i].value.trim();
          const spot = parseInt(spotInputs[i].value);

          if (!username || !spot) {
            showErrorToast('Missing Information', [`Please enter username and spot for Winner #${i + 1}.`]);
            return;
          }

          if (spot < 1 || spot > totalSpots) {
            showErrorToast('Invalid Spot Number', [`Spot number for Winner #${i + 1} must be between 1 and ${totalSpots}.`]);
            return;
          }

          winners.push({ username, spot });
        }

        // Check for duplicate spots
        const spots = winners.map(w => w.spot);
        const uniqueSpots = new Set(spots);
        if (uniqueSpots.size !== spots.length) {
          showErrorToast('Duplicate Spots', ['Each winner must have a unique spot number.']);
          return;
        }

        // Save with single winner or multiple winners
        const winnerData = winnerCount === 1 ? winners[0] : winners;

        await saveToHistory('completed', winnerData);

        // Stop fast raffle timer
        stopFastRaffleTimer();

        // Show toast
        if (winnerCount === 1) {
          showToast(
            `üèÜ Winner: ${winners[0].username}`,
            [`Spot #${winners[0].spot}`]
          );
        } else {
          showToast(
            `üèÜ ${winnerCount} Winners Selected!`,
            winners.map((w, i) => `#${i + 1}: ${w.username} (Spot #${w.spot})`)
          );
        }

        await resetRaffle();
        closeModal();
      });
    })();

    // ============ SCAN EMAIL BUTTON ============
    document.getElementById("scanEmailBtn").addEventListener("click", async () => {
      // Debug: Log the current app state
      console.log('üîç Scan Email clicked. Current state:', {
        activeRaffleId: appState.activeRaffleId,
        redditLink: appState.redditLink,
        totalSpots: appState.totalSpots,
        costPerSpot: appState.costPerSpot,
        participantCount: appState.participants.length
      });

      // Check if raffle exists
      if (!appState.activeRaffleId) {
        console.error('‚ùå Cannot scan email: No active raffle ID found');
        showErrorToast('No Active Raffle', [
          'Please save your raffle configuration first.',
          'Click "Setup" ‚Üí enter raffle details ‚Üí click "Save"'
        ]);
        return;
      }

      console.log('‚úÖ Active raffle ID found:', appState.activeRaffleId);

      // Check if Gmail OAuth credentials are configured
      try {
        const checkResponse = await fetch('/api/paypal/check-credentials');
        
        // If server error (500), skip the check and let the scan handle it
        if (!checkResponse.ok) {
          console.warn('‚ö†Ô∏è Credential check endpoint error, skipping pre-check. Status:', checkResponse.status);
          // Continue to scan - it will show proper error if credentials are really missing
        } else {
          const checkResult = await checkResponse.json();

          if (!checkResult.ok || !checkResult.hasCredentials) {
            showRestrictionModal(
              `Please upload your Gmail OAuth credentials in <b>Settings</b> before scanning emails.<br><br>Go to Settings ‚Üí Bot Configuration ‚Üí Upload Gmail OAuth JSON file.`,
              false,
              "Gmail OAuth Not Configured"
            );
            return;
          }
        }
      } catch (error) {
        console.error('Failed to check Gmail credentials:', error);
        // Continue anyway - the actual scan will catch this error
      }

      // Show confirmation modal before scanning
      showPaypalScanModal(async () => {
        try {
        const requestBody = {
          raffle_id: appState.activeRaffleId
        };

        // Send timestamp if available, otherwise fall back to days_back
        if (appState.createdAt) {
          requestBody.since_timestamp = appState.createdAt;
        } else {
          requestBody.days_back = 7;
        }

        const response = await fetch('/api/paypal/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });

        const result = await response.json();

        if (!result.ok) {
          // Check if credentials are missing
          if (result.error && result.error.includes('Gmail credentials not found')) {
            showRestrictionModal(`Gmail not connected.<br><br>Please upload your Gmail OAuth credentials in <b>Settings</b> to use this feature.`);
          } else {
            showRestrictionModal(`Scan failed.<br><br>${result.error || 'Unknown error'}`);
          }
          return;
        }

        // Show results
        const details = [
          `üìß Emails scanned: ${result.processed || 0}`,
          `‚úÖ Payments matched: ${result.matched || 0}`
        ];

        // Add specific match details if available
        if (result.results && result.results.length > 0) {
          const matched = result.results.filter(r => r.status === 'matched');

          if (matched.length > 0) {
            details.push('');
            details.push('‚úÖ Matched Payments:');
            matched.forEach(m => {
              details.push(`‚Ä¢ ${m.payer_name || 'Unknown'}: $${m.amount} ‚Üí u/${m.reddit_user}`);
            });
          }
        }

        showToast('Email Scan Complete!', details);

        // Reload participants to show updated payment status
        if (result.matched > 0) {
          loadState();
        }

      } catch (error) {
        console.error('Scan email error:', error);
        showRestrictionModal(`Failed to scan emails.<br><br>${error.message}`);
      }
      });
    });

    // ============ CLEAR IDS BUTTON ============
    document.getElementById("clearIdsBtn").addEventListener("click", async () => {
      if (!appState.activeRaffleId) {
        showRestrictionModal(`No active raffle found.`);
        return;
      }

      try {
        // Call backend to clear processed PayPal transaction records
        const response = await fetch('/api/paypal/clear', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            raffle_id: appState.activeRaffleId
          })
        });

        const result = await response.json();

        if (!result.ok) {
          showRestrictionModal(`Failed to clear email records.<br><br>${result.error || 'Unknown error'}`);
          return;
        }

        // Log activity
        await API.logActivity({
          type: 'modification',
          title: 'Cleared processed email records',
          details: `${result.deleted} processed PayPal transaction records cleared - emails can now be rescanned`,
          badge: 'Email Records Cleared'
        });

        const details = [
          `üóëÔ∏è ${result.deleted} email records cleared`,
          `üîÑ Emails can now be rescanned`,
          'üí° Previous payments can be matched again'
        ];
        showToast('Email IDs Cleared!', details);

      } catch (error) {
        console.error('Clear IDs error:', error);
        showRestrictionModal(`Failed to clear records.<br><br>${error.message}`);
      }
    });

    // ============ MARK ALL PAID BUTTON ============
    document.getElementById("markPaidBtn").addEventListener("click", async () => {
      // Check if setup is complete first
      if (!appState.redditLink || !appState.costPerSpot || appState.totalSpots === null) {
        showRestrictionModal(`Setup is incomplete.<br>Please configure Reddit Link, Total Spots, and Cost Per Spot before marking payments.`);
        return;
      }

      // ‚úÖ Exclude Waitlist participants (0 spots) from stats and marking
      const raffleParticipants = appState.participants.filter(p => (p.spots || 0) > 0);
      const pendingCount = raffleParticipants.filter(p => !p.paid).length;
      const totalAmount = raffleParticipants.reduce((sum, p) => sum + (p.owed || 0), 0);

      // ‚úÖ Only mark raffle participants (spots > 0) as paid, not Waitlist participants
      appState.participants.forEach(p => {
        if ((p.spots || 0) > 0) {
          p.paid = true;
        }
      });
      await saveState();

      // Update payment status directly without rebuilding entire table
      const tbody = document.getElementById("participantsTbody");
      const rows = tbody.querySelectorAll('tr:not(#emptyRow)');
      rows.forEach((row) => {
        const index = parseInt(row.dataset.index);
        if (appState.participants[index] && (appState.participants[index].spots || 0) > 0) {
          // ‚úÖ Only update rows with spots > 0 (skip Waitlist participants)
          // Update checkbox
          const checkbox = row.querySelector('.paid-checkbox');
          if (checkbox) {
            checkbox.checked = true;
          }

          // Update status dot
          const statusDot = row.querySelector('.status-dot');
          if (statusDot) {
            statusDot.className = 'status-dot dot-paid';
          }

          // Update row styling
          row.classList.remove('unpaid-row');
          row.classList.add('paid-row');

          // Update row data attribute
          row.dataset.paid = 'true';
        }
      });

      updateStats();
      updateFooter();

      // Log activity
      await API.logActivity({
        type: 'payment',
        title: 'All participants marked as paid',
        details: `${pendingCount} payments confirmed ‚Ä¢ Total: $${totalAmount.toLocaleString()}`,
        badge: 'Payment Confirmed'
      });

      const details = [
        `‚úì ${pendingCount} participants marked as paid`,
        `üí∞ Total confirmed: $${totalAmount.toLocaleString()}`,
        'üéâ All payments complete!'
      ];
      showToast('Payments Updated!', details);
    });

    // ============ SEARCH & FILTER ============
    // Debounced search - waits 300ms after user stops typing before filtering
    const debouncedSearch = debounce(filterAndSearch, 300);
    document.getElementById("participantSearch").addEventListener("input", debouncedSearch);
    document.getElementById("paymentFilter").addEventListener("change", filterAndSearch);

    // ============ TABLE SORTING ============
    // Sorting is only enabled for Spots and Paid columns (defined in HTML)

    document.querySelectorAll('.p-table thead th.sortable').forEach(th => {
      th.addEventListener('click', (e) => {
        // Don't sort if clicking on the column resizer
        if (e.target.classList.contains('col-resizer')) {
          return;
        }
        const sortColumn = th.dataset.sort;
        if (sortColumn) {
          sortTable(sortColumn);
        }
      });
    });

    // ============ KEYBOARD SHORTCUTS: CTRL + F, CTRL + R ============
    document.addEventListener("keydown", (e) => {
      // Check if CTRL + F (or CMD + F on Mac)
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault(); // Prevent browser's default find
        const searchInput = document.getElementById("participantSearch");
        if (searchInput) {
          searchInput.focus();
          searchInput.select(); // Select all text in the search box
        }
      }
      
      // Check if CTRL + R (or CMD + R on Mac) - Refresh page
      if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault(); // Prevent default to control the reload
        location.reload(); // Refresh the page
      }
    });

    // ============ TOAST CLOSE ============
    document.getElementById("toastClose").addEventListener("click", () => {
      document.getElementById("successToast").classList.remove("show");
    });

    document.getElementById("errorToastClose").addEventListener("click", () => {
      document.getElementById("errorToast").classList.remove("show");
    });

    // ============ TABBED COLUMN PERSISTENCE ============
    function saveTabbedColumnVisibility(isVisible) {
      localStorage.setItem('raffleui_tabbed_column_visible', isVisible ? '1' : '0');
    }

    function loadTabbedColumnVisibility() {
      const saved = localStorage.getItem('raffleui_tabbed_column_visible');
      return saved === null ? true : saved === '1'; // Default to visible
    }

    function applyTabbedColumnVisibility(isVisible) {
      const table = document.getElementById('participantsTable');
      if (!table) return;

      // Update colgroup
      const colTabbed = table.querySelector('.col-tabbed');
      if (colTabbed) {
        colTabbed.style.display = isVisible ? '' : 'none';
      }

      // Update header
      const thTabbed = table.querySelector('th[data-col="2"]');
      if (thTabbed) {
        thTabbed.style.display = isVisible ? '' : 'none';
      }

      // Update all body cells in the Tabbed column
      const tabbedCells = table.querySelectorAll('tbody tr td:nth-child(3)');
      tabbedCells.forEach(cell => {
        cell.style.display = isVisible ? '' : 'none';
      });
    }

    // ============ INITIALIZE ============
    (async function init() {
      // Initialize user cache FIRST
      await API.initUser();

      // Load state (now with user cached)
      await loadState();

      // ‚úÖ Restore tabbed column visibility
      const tabbedVisible = loadTabbedColumnVisibility();
      applyTabbedColumnVisibility(tabbedVisible);

      // Defer heavy operations slightly to let the page render
      requestAnimationFrame(() => {
        updateStats();
        updateFooter();

        // Start auto-polling after a short delay to avoid blocking initial render
        setTimeout(() => {
          startAutoPolling();
        }, 100);
      });
    })();

    // ============ AUTO-POLLING REDDIT SCAN ============
    let pollingInterval = null;
    let isScanning = false;

    async function performAutoScan() {
      // Prevent concurrent scans
      if (isScanning) {
        console.log('‚ö†Ô∏è Scan already in progress, skipping...');
        return;
      }

      // Only scan if Reddit link and cost per spot are configured
      if (!appState.redditLink || !appState.costPerSpot) {
        return;
      }

      isScanning = true;

      // Validate Reddit URL format before scanning
      const redditRegex = /^https?:\/\/(www\.)?(reddit\.com|old\.reddit\.com)\/r\/[^\/]+\/comments\/[^\/]+\/[^\/]+\/?/i;
      if (!redditRegex.test(appState.redditLink)) {
        console.error('‚ùå Invalid Reddit URL format detected. Auto-scan skipped.');
        return;
      }

      console.log('üîÑ Auto-scanning Reddit...');

      try {
        // OPTIMIZATION: Pass existing comment IDs to backend to skip AI parsing
        const existingCommentIds = appState.participants.map(p => p.commentId).filter(Boolean);
        console.log(`üìä Passing ${existingCommentIds.length} existing comment IDs to skip AI parsing`);

        // Calculate current assigned spots to prevent overfilling
        const currentAssignedSpots = appState.participants.reduce((sum, p) => sum + (parseInt(p.spots) || 0), 0);
        console.log(`üìä Current assigned spots: ${currentAssignedSpots}/${appState.totalSpots || 'unlimited'}`);

        const result = await API.scanReddit(appState.redditLink, appState.costPerSpot, appState.totalSpots, existingCommentIds, currentAssignedSpots);

        if (!result.ok) {
          console.error('Auto-scan failed:', result.error);
          return;
        }

        const newParticipants = result.participants || [];

        if (newParticipants.length === 0) {
          console.log('‚úì Auto-scan complete - no new participants');
          return;
        }

        // DEBUG: Log comment IDs for auto-scan
        console.log('üîÑ AUTO-SCAN - Existing participants:', appState.participants.length);
        console.log('üîÑ AUTO-SCAN - Existing comment IDs:', existingCommentIds);
        console.log('üîÑ AUTO-SCAN - New participants from Reddit:', newParticipants.length);
        console.log('üîÑ AUTO-SCAN - New comment IDs:', newParticipants.map(p => p.commentId));

        // FILTER OUT DUPLICATES: Only add comments we haven't seen before
        const existingCommentIdsSet = new Set(existingCommentIds);
        const trulyNewParticipants = newParticipants.filter(newP => !existingCommentIdsSet.has(newP.commentId));

        console.log('üîÑ AUTO-SCAN - Filtered to truly new:', trulyNewParticipants.length);

        if (trulyNewParticipants.length === 0) {
          console.log('‚úì Auto-scan complete - no new comments (all already added)');
          return;
        }

        // Add only NEW participants (prepend in correct order so newest appear at top)
        // trulyNewParticipants is already sorted newest-first from the parser
        appState.participants.unshift(...trulyNewParticipants);

        await saveState();
        
        // ‚úÖ OPTIMIZED: Insert new rows at top without rebuilding entire table
        await insertNewRowsAtTop(trulyNewParticipants);
        
        updateStats();
        updateFooter();
        // ‚úÖ Apply default filter after auto-scan (hides Waitlist participants)
        filterAndSearch();

        // Log activity
        await API.logActivity({
          type: 'participant',
          title: `Auto-scan: ${trulyNewParticipants.length} entries added`,
          details: `${trulyNewParticipants.length} participant entries found via automatic Reddit scan`,
          badge: 'Auto-Scan'
        });

        // Show notification
        const details = [
          `üë• ${trulyNewParticipants.length} new entries found`,
          `üìä Total entries: ${appState.participants.length}`
        ];
        showToast('Auto-Scan Complete!', details);

        console.log(`‚úì Auto-scan complete - ${trulyNewParticipants.length} new participants added`);

      } catch (error) {
        console.error('Auto-scan error:', error);
      } finally {
        isScanning = false;
      }
    }

    function startAutoPolling() {
      // GUARD: If polling is already running, don't start another one
      if (pollingInterval) {
        console.log('‚ö†Ô∏è Auto-polling already running, skipping duplicate start');
        return;
      }

      // Only start polling if setup is configured
      if (!appState.redditLink || !appState.costPerSpot) {
        document.getElementById('autoScanIndicator').style.display = 'none';
        localStorage.setItem(getUserLocalStorageKey('autoPollingActive'), 'false');
        return;
      }

      // Show indicator
      document.getElementById('autoScanIndicator').style.display = 'inline-flex';

      // Mark polling as active in localStorage so other pages know (user-specific)
      localStorage.setItem(getUserLocalStorageKey('autoPollingActive'), 'true');
      localStorage.setItem(getUserLocalStorageKey('autoPollingRaffleId'), appState.activeRaffleId);

      // Start polling every 10 seconds (10000ms)
      pollingInterval = setInterval(() => {
        performAutoScan();
        resetPollCountdown();
      }, 10000);

      // Start countdown timer
      startPollCountdown();

      console.log('‚úì Auto-polling started - scanning every 10 seconds (active across all pages)');
    }

    function stopAutoPolling() {
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      document.getElementById('autoScanIndicator').style.display = 'none';

      // Stop countdown timer
      if (typeof stopPollCountdown === 'function') {
        stopPollCountdown();
      }

      // Mark polling as inactive in localStorage
      localStorage.setItem(getUserLocalStorageKey('autoPollingActive'), 'false');

      console.log('‚úì Auto-polling stopped');
    }

    // Don't stop polling when navigating away - let it run in background
    // window.addEventListener('beforeunload', stopAutoPolling);

    // Restart polling when setup is saved
    const originalSaveBtn = document.getElementById("modalSaveBtn");
    if (originalSaveBtn) {
      originalSaveBtn.addEventListener("click", () => {
        setTimeout(() => {
          startAutoPolling();
        }, 500);
      });
    }

    // ===== CHECK AND RESUME POLLING ON PAGE LOAD =====
    (function() {
      // Wait for page to fully load and appState to be populated
      setTimeout(() => {
        const isPollingActive = localStorage.getItem(getUserLocalStorageKey('autoPollingActive')) === 'true';
        const savedRaffleId = localStorage.getItem(getUserLocalStorageKey('autoPollingRaffleId'));

        // If polling was active and we have the same raffle loaded
        if (isPollingActive && savedRaffleId && appState.activeRaffleId == savedRaffleId) {
          console.log('üîÑ Resuming auto-polling from previous session...');
          startAutoPolling();
        }
      }, 1000);
    })();

    // ===== LISTEN FOR BACKGROUND SCAN EVENTS =====
    window.addEventListener('backgroundScanComplete', async (event) => {
      console.log('üîî Background scan completed on another page. Reloading data...');

      // Reload participant data
      await loadState();

      // Show subtle notification
      const details = [
        `üë• ${event.detail.newCount} new participant(s) found`,
        `üíú Scanned while you were away`
      ];
      showToast('Auto-Scan Complete!', details);
    });

        // ===== AUTO-OPEN SETUP MODAL FROM DASHBOARD =====
(function() {
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('setup') === 'open') {
    // Wait for page to fully load
    setTimeout(() => {
      const setupBtn = document.getElementById('setupBtn');
      if (setupBtn) {
        setupBtn.click();
      }
    }, 500);

    // Clean URL (remove ?setup=open)
    window.history.replaceState({}, document.title, '/active-raffle');
  }
})();

// ===== ACCESS DENIED MODAL =====
function showAccessDenied() {
  const overlay = document.getElementById('accessDeniedOverlay');
  if (!overlay) {
    showErrorToast('Access Denied', ['Admins only']);
    return;
  }
  overlay.classList.add('show');
  document.body.style.overflow = 'hidden';
}

function closeAccessDenied(event) {
  if (!event || event.target === document.getElementById('accessDeniedOverlay')) {
    const overlay = document.getElementById('accessDeniedOverlay');
    if (overlay) {
      overlay.classList.remove('show');
      document.body.style.overflow = '';
    }
  }
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const overlay = document.getElementById('accessDeniedOverlay');
    if (overlay && overlay.classList.contains('show')) {
      closeAccessDenied({ target: overlay });
    }
  }
});

// ============ FAST RAFFLE TIMER ============
let fastRaffleTimerInterval = null;

function startFastRaffleTimer() {
  const timerElement = document.getElementById('fastRaffleTimer');
  const displayElement = document.getElementById('timerDisplay');

  if (!timerElement || !displayElement) return;

  // Show the timer
  timerElement.classList.add('active');

  // Clear any existing interval
  if (fastRaffleTimerInterval) {
    clearInterval(fastRaffleTimerInterval);
  }

  function updateTimer() {
    if (!appState.fastRaffleStartTime) {
      stopFastRaffleTimer();
      return;
    }

    // Calculate elapsed time
    const elapsed = Date.now() - appState.fastRaffleStartTime;
    const totalDuration = 75 * 60 * 1000; // 1 hour 15 minutes in milliseconds
    const remaining = Math.max(0, totalDuration - elapsed);

    if (remaining === 0) {
      displayElement.textContent = '00:00:00';
      timerElement.classList.add('warning');
      stopFastRaffleTimer();
      return;
    }

    // Convert to hours, minutes, seconds
    const hours = Math.floor(remaining / (60 * 60 * 1000));
    const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
    const seconds = Math.floor((remaining % (60 * 1000)) / 1000);

    // Format as HH:MM:SS
    const formatted =
      String(hours).padStart(2, '0') + ':' +
      String(minutes).padStart(2, '0') + ':' +
      String(seconds).padStart(2, '0');

    displayElement.textContent = formatted;

    // Turn red when under 1 hour
    if (remaining < 60 * 60 * 1000) {
      timerElement.classList.add('warning');
    } else {
      timerElement.classList.remove('warning');
    }
  }

  // Update immediately
  updateTimer();

  // Update every second
  fastRaffleTimerInterval = setInterval(updateTimer, 1000);

  console.log('‚è±Ô∏è Fast raffle timer started');
}

function stopFastRaffleTimer() {
  const timerElement = document.getElementById('fastRaffleTimer');

  if (fastRaffleTimerInterval) {
    clearInterval(fastRaffleTimerInterval);
    fastRaffleTimerInterval = null;
  }

  if (timerElement) {
    timerElement.classList.remove('active');
    timerElement.classList.remove('warning');
  }

  console.log('ÔøΩÔøΩÔøΩÔ∏è Fast raffle timer stopped');
}

  </script>

  <!-- ACCESS DENIED MODAL -->
  <div class="access-denied-overlay" id="accessDeniedOverlay" onclick="closeAccessDenied(event)">
    <div class="access-denied-modal" onclick="event.stopPropagation()">
      <div class="access-modal-header">
        <div class="access-modal-icon">üîí</div>
        <h2 class="access-modal-title">Access Denied</h2>
        <p class="access-modal-subtitle">Admin privileges required</p>
      </div>
      <div class="access-modal-body">
        <p class="access-modal-message">
          You don't have permission to access this page. This area is restricted to administrators only.
        </p>
        <div class="access-modal-actions">
          <button class="access-modal-btn access-modal-btn-primary" onclick="closeAccessDenied()">
            Got it
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Poll Countdown Timer -->
  <script>
    let pollCountdownInterval = null;
    let pollTimeRemaining = 10; // 10 seconds

    function startPollCountdown() {
      pollTimeRemaining = 10;
      updatePollTimerDisplay();

      if (pollCountdownInterval) {
        clearInterval(pollCountdownInterval);
      }

      pollCountdownInterval = setInterval(() => {
        if (pollTimeRemaining > 0) {
          pollTimeRemaining--;
          updatePollTimerDisplay();
        }
      }, 1000);
    }

    function resetPollCountdown() {
      pollTimeRemaining = 10;
      updatePollTimerDisplay();
    }

    function updatePollTimerDisplay() {
      const timerEl = document.getElementById('nextPollTimer');
      if (timerEl) {
        timerEl.textContent = pollTimeRemaining;
      }
    }

    function stopPollCountdown() {
      if (pollCountdownInterval) {
        clearInterval(pollCountdownInterval);
        pollCountdownInterval = null;
      }
    }
  </script>

</body>
</html>
