<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Active Raffle</title>
<script src="/static/api.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>
  
  <!-- Dark Mode System -->
  <link rel="stylesheet" href="/static/dark-mode.css" />
  <script src="/static/dark-mode.js"></script>

  <style>
    /* ============================== MASTER LAYOUT VARIABLES ============================== */
    :root{
      --app-width: 1600px;
      --app-height: 1020px;
      --sidebar-width: 252px;
      --content-left: 360px;
      --content-width: 1120px;
    }

    body{
      background-color:#FAF8F6;
      display:flex;
      justify-content:flex-start;  /* Align left instead of center */
      align-items:flex-start;      /* Align top instead of center */
      height:100vh;
      margin:0;
      font-family:'Inter',sans-serif;
      overflow: hidden;
    }

    /* Scale down for smaller screens */
    @media (max-width: 1600px), (max-height: 1020px) {
      .white-square {
        transform-origin: top left;  /* Scale from top-left corner */
        transform: scale(calc(min(100vw / 1600, 100vh / 1020)));
      }
    }

    .top-sidebar{
      position:absolute; top:0; left:-30px;
      width: calc(var(--sidebar-width) + 30px);
      height:200px;
      clip-path: inset(0 0 0 30px);
      background-image:url('/static/assets/Background/Top-Sidebar.png');
      background-size:cover; background-repeat:no-repeat;
      z-index:5;
    }

    .tako{
      position:absolute;
      top:60px; left:calc(var(--sidebar-width) / 2);
      transform:translate(-50%,-50%);
      width:148px; height:148px;
      background-image:url('/static/assets/Icons/TAKO%201.png');
      background-size:contain;
      background-repeat:no-repeat;
      background-position:center;
      z-index:25;
      pointer-events:none;
    }

    .sidebar{
      position:absolute;
      left:-30px; bottom:0px;
      width: calc(var(--sidebar-width) + 30px);
      clip-path: inset(0 0 0 30px);
      height:900px;
      background-image:url('/static/assets/Background/Sidebar.png');
      background-size:cover;
      background-repeat:no-repeat;
      z-index:10;
    }
      border-bottom-left-radius:30px;
      z-index:10;
    }

    .rectangle{
      position:absolute;
      top:135px; left:0;
      width:165px; height:48px;
      background-image:url('/static/assets/Background/Rectangle.png');
      background-size:cover;
      background-repeat:no-repeat;
      z-index:20;
      pointer-events:none;
    }

    .square{
      position:absolute;
      top:140px; left:30px;
      width:244px; height:52px;
      background-image:url('/static/assets/Background/Square.png');
      background-size:cover;
      background-repeat:no-repeat;
      background-position:center;
      z-index:30;
      pointer-events:none;
      transition:top 140ms ease;
      opacity:0;
    }

    .sidebar-nav{
      position:absolute;
      top:140px; left:55px;
      width:244px;
      font-size:16px;
      line-height:58px;
      z-index:40;
    }

    .sidebar-nav a{
      display:block;
      position:relative;
      padding-left:26px;
      color:#ffffff;
      text-decoration:none;
      font-weight:400;
      user-select:none;
      cursor:pointer;
    }

    .sidebar-nav a.is-active{
      color:#6E5FFC;
      font-weight:600;
    }

    .nav-icon{
      position:absolute;
      left:-5px; top:17px;
      width:20px; height:20px;
      filter:brightness(0) invert(1);
      pointer-events:none;
      z-index:41;
    }

    .sidebar-nav a.is-active .nav-icon{
      filter:brightness(0) saturate(100%) invert(46%) sepia(82%) saturate(2780%) hue-rotate(222deg);
    }

    /* USER SECTION */
    .user-section {
      position: absolute;
      bottom: 20px;
      left: 30px;
      width: 192px;
      z-index: 45;
    }

    /* APP VERSION */
    .app-version {
      position: absolute;
      bottom: 78px;
      left: 30px;
      width: 192px;
      text-align: right;
      font-size: 11px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.4);
      z-index: 45;
      letter-spacing: 0.5px;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .user-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 700;
      color: #fff;
      flex-shrink: 0;
    }

    .user-details {
      flex: 1;
      min-width: 0;
    }

    .user-name {
      font-size: 16px;
      font-weight: 600;
      color: #fff;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .user-role {
      font-size: 13px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.7);
      margin: 2px 0 0 0;
    }

    .logout-btn {
      width: 100%;
      height: 42px;
      border: none;
      border-radius: 10px;
      background: rgba(236, 72, 153, 0.85);
      color: #fff;
      font-size: 15px;
      font-weight: 600;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .logout-btn:hover {
      background: rgba(236, 72, 153, 1);
      transform: translateY(-1px);
    }

    .logout-btn:active {
      transform: translateY(0);
    }

    /* SEARCH BAR */


    /* TOP RIGHT ICONS */
    #themeToggle { position: absolute; top: 48px; right: 130px; width: 44px; height: 24px; cursor: pointer; }
    #settingsBtn { position: absolute; top: 48px; right: 70px; width: 24px; height: 24px; cursor: pointer; }

    /* FAST RAFFLE TIMER */
    .fast-raffle-timer {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #7C3AED 0%, #EC4899 100%);
      color: white;
      padding: 12px 32px;
      border-radius: 12px;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 1px;
      box-shadow: 0 8px 24px rgba(124, 58, 237, 0.35);
      z-index: 100;
      display: none;
      font-variant-numeric: tabular-nums;
    }

    .fast-raffle-timer.active {
      display: block;
    }

    .fast-raffle-timer.warning {
      background: linear-gradient(135deg, #F59E0B 0%, #EF4444 100%);
      box-shadow: 0 8px 24px rgba(239, 68, 68, 0.35);
      animation: pulse-warning 2s ease-in-out infinite;
    }

    @keyframes pulse-warning {
      0%, 100% {
        transform: translateX(-50%) scale(1);
        box-shadow: 0 8px 24px rgba(239, 68, 68, 0.35);
      }
      50% {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 12px 32px rgba(239, 68, 68, 0.5);
      }
    }

    /* STATS */
    .stats-row{
      position:absolute;
      top:110px;
      left:var(--content-left);
      width:var(--content-width);
      display:grid;
      grid-template-columns:repeat(5, 1fr);
      gap:18px;
      z-index:55;
    }

    .stat-card{
      border-radius:16px;
      padding:14px 18px;
      color:#fff;
      box-shadow:0 10px 18px rgba(0,0,0,0.12);
      min-height:78px;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }

    .stat-label{
      font-size:12px;
      letter-spacing:1px;
      font-weight:700;
      text-transform:uppercase;
      opacity:0.9;
      margin-bottom:6px;
    }

    .stat-value{
      font-size:30px;
      font-weight:700;
      line-height:1;
    }

    .c-pink{   background:#ff4fb2; }
    .c-purple{ background:#a855f7; }
    .c-green{  background:#00c26f; }
    .c-orange{ background:#f59e0b; }
    .c-blue{   background:#3b82f6; }

    /* PARTICIPANTS CARD */
    .participants-card{
      position:absolute;
      top:235px;
      left:276px;
      width:1400px;
      height:calc(var(--app-height) - 235px - 40px);
      background:#ffffff;
      border-radius:18px;
      box-shadow:0 18px 30px rgba(0,0,0,0.10);
      overflow:hidden;
      z-index:52;
      display:flex;
      flex-direction:column;
    }

    .participants-header{
      padding:22px 24px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:18px;
      border-bottom:1px solid #eef0f4;
      background:#ffffff;
    }

    .participants-title{
      margin:0;
      font-size:18px;
      font-weight:700;
      color:#111827;
    }

    .participants-sub{
      margin-top:6px;
      font-size:13px;
      color:#64748b;
      font-weight:500;
    }

    .table-wrap{
      flex:1;
      overflow:auto;
      background:#ffffff;
    }

    table.p-table{
      width:100%;
      border-collapse:collapse;
      font-size:14px;
      table-layout:fixed;
    }

    .p-table col.col-reddit  { width:260px; }
    .p-table col.col-name    { width:170px; }
    .p-table col.col-tabbed  { width:180px; }
    .p-table col.col-comment { width:auto;  }
    .p-table col.col-spots   { width:90px;  }
    .p-table col.col-owed    { width:90px;  }
    .p-table col.col-paid    { width:80px;  }
    .p-table col.col-status  { width:120px; }

    .p-table thead th{
      text-align:left;
      padding:14px 24px;
      font-size:11px;
      letter-spacing:0.8px;
      text-transform:uppercase;
      color:#334155;
      background:#ffffff;
      position:sticky;
      top:0;
      z-index:1;
      border-bottom:1px solid #eef0f4;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    .p-table tbody td{
      padding:18px 24px;
      border-bottom:1px solid #eef0f4;
      vertical-align:middle;
      color:#0f172a;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    .user-cell{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:0;
    }

    .avatar{
      width:34px;
      height:34px;
      border-radius:50%;
      display:grid;
      place-items:center;
      color:#fff;
      font-weight:700;
      background:linear-gradient(135deg,#a855f7,#ff4fb2);
      flex-shrink:0;
    }

    .reddit-link{
      color:#6E5FFC;
      text-decoration:none;
      font-weight:600;
    }

    .comment-muted{
      color:#334155;
      font-style:italic;
    }

    .spots-pill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:34px;
      height:26px;
      padding:0 10px;
      border-radius:999px;
      background:#efe9ff;
      color:#6E5FFC;
      font-weight:700;
      font-size:12px;
    }

    .status-chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;

    .tab-badge {
      display: inline-block;
      margin-left: 8px;
      padding: 2px 8px;
      background: #fbbf24;
      color: #78350f;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
    }

    .editable-field:hover {
      background: rgba(139, 92, 246, 0.1);
    }
      font-weight:700;
      font-size:12px;
      white-space:nowrap;
    }

    .status-paid{ background:#dcfce7; color:#166534; }
    .status-pending{ background:#fef3c7; color:#92400e; }

    /* Paid Checkbox Styling */
    .paid-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: #16a34a;
      transform: scale(1.2);
    }

    .paid-checkbox:hover {
      opacity: 0.8;
    }

    /* Tabbed Dropdown Styling */
    .tabbed-dropdown {
      width: 100%;
      max-width: 170px;
      padding: 6px 10px;
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      background: #ffffff;
      color: #334155;
      font-size: 13px;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s ease;
      outline: none;
    }

    .tabbed-dropdown:hover {
      border-color: #8b5cf6;
      background: #faf5ff;
    }

    .tabbed-dropdown:focus {
      border-color: #8b5cf6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .tabbed-dropdown option {
      padding: 8px;
      background: #ffffff;
      color: #334155;
    }

    .tabbed-dropdown option:hover {
      background: #f3f4f6;
    }

    .paid-checkbox:hover {
      transform: scale(1.3);
    }

    .dot{
      width:18px;
      height:18px;
      border-radius:50%;
      display:grid;
      place-items:center;
      font-size:12px;
      line-height:1;
      background:rgba(255,255,255,0.55);
    }

    .participants-foot{
      padding:14px 24px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      border-top:1px solid #eef0f4;
      color:#475569;
      font-size:13px;
      background:#ffffff;
    }

    /* Resize handles */
    .th-inner{ position:relative; padding-right:14px; }
    .col-resizer{
      position:absolute;
      top:0;
      right:-8px;
      width:16px;
      height:100%;
      cursor:col-resize;
      user-select:none;
      touch-action:none;
    }
    .col-resizer::after{
      content:"";
      position:absolute;
      top:20%;
      left:50%;
      transform:translateX(-50%);
      width:2px;
      height:60%;
      background:rgba(15,23,42,0.12);
      border-radius:2px;
      opacity:0;
      transition:opacity 120ms ease;
    }
    th:hover .col-resizer::after{ opacity:1; }
    .resizing *{ cursor:col-resize !important; user-select:none !important; }

    /* Buttons */
    .btn {
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      transition: all 150ms ease;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .btn-blue   { background: #3B82F6; }
    .btn-green  { background: #10B981; }
    .btn-purple { background: linear-gradient(90deg, #7C3AED, #EC4899); }
    .btn-orange { background: #F97316; }
    .btn-red    { background: #EF4444; }

    .search-box input {
      height: 40px;
      padding: 0 14px;
      border-radius: 12px;
      border: 1px solid #E6E8F0;
      font-size: 14px;
    }

    .filter-select {
      height: 40px;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid #E6E8F0;
      font-size: 14px;
      background: #fff;
      cursor: pointer;
    }

/* MODAL STYLES */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: none; /* CHANGED from flex to none */
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .modal-overlay.show {
      display: flex; /* ADDED: Show when .show class is added */
    }

    .modal-content {
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 32px 24px;
      width: 600px;
      max-width: 90vw;
      transform: scale(0.9);
      transition: transform 200ms ease;
    }

    .modal-overlay.show .modal-content {
      transform: scale(1);
    }

    .modal-title {
      font-size: 24px;
      font-weight: 700;
      margin: 0 0 24px 0;
      color: #111827;
    }

    .modal-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-label {
      font-size: 14px;
      font-weight: 500;
      color: #374151;
      margin-bottom: 8px;
    }

    .form-input {
      width: 100%;
      padding: 10px 11px;
      border: 1px solid #D1D5DB;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }

    .form-input:focus {
      border-color: #8B5CF6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 32px;
    }

    .form-hint {
      font-size: 12px;
      color: #6B7280;
      margin-top: 4px;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      margin-top: 32px;
    }

    .modal-btn {
      flex: 1;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 150ms ease;
    }

    .modal-btn-cancel {
      background: #ffffff;
      color: #374151;
      border: 1px solid #D1D5DB;
    }

    .modal-btn-cancel:hover {
      background: #F9FAFB;
    }

    .modal-btn-save {
      background: linear-gradient(90deg, #3B82F6, #2563EB);
      color: #ffffff;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .modal-btn-save:hover {
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    }

    /* FINISH RAFFLE MODAL */
    .finish-modal-content {
      width: 540px;
    }

    .finish-modal-icon {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, #FF4FB2, #A855F7);
      border-radius: 50%;
      display: grid;
      place-items: center;
      margin: 0 auto 20px;
      font-size: 40px;
    }

    .finish-modal-text {
      font-size: 15px;
      color: #6B7280;
      margin-bottom: 28px;
      line-height: 1.6;
      text-align: center;
    }

    .winner-section {
      background: #F9FAFB;
      border: 1px solid #E5E7EB;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 28px;
    }

    .winner-section-title {
      font-size: 15px;
      font-weight: 700;
      color: #111827;
      margin: 0 0 16px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .winner-count-selector {
      margin-bottom: 20px;
    }

    .winner-count-buttons {
      display: flex;
      gap: 8px;
    }

    .winner-count-btn {
      flex: 1;
      padding: 10px 16px;
      border: 2px solid #E5E7EB;
      border-radius: 8px;
      background: white;
      color: #6B7280;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 150ms ease;
    }

    .winner-count-btn:hover {
      border-color: #A855F7;
      color: #A855F7;
    }

    .winner-count-btn.active {
      border-color: #A855F7;
      background: #A855F7;
      color: white;
      box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
    }

    .winner-entry {
      margin-bottom: 20px;
      padding: 16px;
      background: white;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      animation: slideIn 200ms ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .winner-entry-header {
      font-size: 13px;
      font-weight: 600;
      color: #6B7280;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

          .username-dropdown-container {
      position: relative;
    }

    .username-dropdown-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: white;
      border: 1px solid #D1D5DB;
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      display: none;
    }

    .username-dropdown-list.show {
      display: block;
    }

    .username-dropdown-item {
      padding: 10px 14px;
      cursor: pointer;
      transition: background 150ms ease;
    }

    .username-dropdown-item:hover {
      background: #F3F4F6;
    }

    .username-dropdown-item.selected {
      background: #EFE9FF;
      color: #6E5FFC;
      font-weight: 600;
    }

    .winner-form-row {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
    }

    .form-select {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid #D1D5DB;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      background: white;
      cursor: pointer;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }

    .form-select:focus {
      border-color: #10B981;
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
    }

    .finish-modal-actions {
      display: flex;
      gap: 12px;
    }

    .finish-btn {
      flex: 1;
      padding: 14px 24px;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 150ms ease;
    }

    .finish-btn-complete {
      background: linear-gradient(90deg, #10B981, #059669);
      color: white;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .finish-btn-complete:hover {
      box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
      transform: translateY(-1px);
    }

    .finish-btn-complete:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .finish-btn-cancel-raffle {
      background: linear-gradient(90deg, #EF4444, #DC2626);
      color: white;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }

    .finish-btn-cancel-raffle:hover {
      box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
      transform: translateY(-1px);
    }

    .or-divider {
      text-align: center;
      color: #9CA3AF;
      font-size: 13px;
      font-weight: 600;
      margin: 16px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* RESTRICTION MODAL */
    .restriction-modal-content {
      width: 420px;
      background: #2B2B3D;
      border-radius: 16px;
      padding: 40px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .restriction-modal-icon {
      width: 64px;
      height: 64px;
      background: rgba(251, 191, 36, 0.15);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 20px;
      font-size: 32px;
    }

    .restriction-modal-title {
      font-size: 22px;
      font-weight: 600;
      color: #E5E7EB;
      margin: 0 0 16px 0;
      text-align: center;
    }

    .restriction-modal-message {
      font-size: 15px;
      color: #9CA3AF;
      line-height: 1.6;
      margin-bottom: 32px;
      text-align: center;
    }

    .restriction-modal-message strong {
      color: #FFFFFF;
      font-weight: 600;
    }

    .restriction-ok-btn {
      width: 100%;
      height: 48px;
      background: #4F89C7;
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .restriction-ok-btn:hover {
      background: #5A96D4;
      transform: translateY(-1px);
    }

    .restriction-ok-btn:active {
      transform: translateY(0);
    }

    .restriction-cancel-btn {
      width: 100%;
      height: 48px;
      background: #DC4444;
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .restriction-cancel-btn:hover {
      background: #E65555;
      transform: translateY(-1px);
    }

    .restriction-cancel-btn:active {
      transform: translateY(0);
    }

    .restriction-modal-actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* PAYPAL SCAN CONFIRMATION MODAL */
    .paypal-scan-modal-content {
      width: 440px;
      background: #2B2B3D;
      border-radius: 16px;
      padding: 32px;
      text-align: left;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .paypal-scan-modal-title {
      font-size: 18px;
      font-weight: 600;
      color: #E5E7EB;
      margin: 0 0 20px 0;
      text-align: left;
      line-height: 1.4;
    }

    .paypal-scan-modal-message {
      font-size: 14px;
      color: #9CA3AF;
      line-height: 1.8;
      margin-bottom: 28px;
      text-align: left;
    }

    .paypal-scan-modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .paypal-scan-ok-btn {
      height: 44px;
      padding: 0 28px;
      background: #7C3AED;
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .paypal-scan-ok-btn:hover {
      background: #8B5CF6;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
    }

    .paypal-scan-ok-btn:active {
      transform: translateY(0);
    }

    .paypal-scan-cancel-btn {
      height: 44px;
      padding: 0 24px;
      background: transparent;
      color: #9CA3AF;
      border: 1px solid #4B5563;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .paypal-scan-cancel-btn:hover {
      background: #374151;
      color: #E5E7EB;
      border-color: #6B7280;
    }

    .paypal-scan-cancel-btn:active {
      transform: scale(0.98);
    }

    /* CANCEL RAFFLE CONFIRMATION MODAL */
    .cancel-confirm-modal-content {
      width: 420px;
      background: #2B2B3D;
      border-radius: 12px;
      padding: 32px;
      text-align: left;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .cancel-confirm-title {
      font-size: 15px;
      color: #E5E7EB;
      line-height: 1.5;
      margin-bottom: 24px;
    }

    .cancel-confirm-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .cancel-confirm-ok-btn {
      padding: 10px 28px;
      background: #4F89C7;
      color: #FFFFFF;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .cancel-confirm-ok-btn:hover {
      background: #5A96D4;
      transform: translateY(-1px);
    }

    .cancel-confirm-cancel-btn {
      padding: 10px 24px;
      background: transparent;
      color: #9CA3AF;
      border: 1px solid #4B5563;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .cancel-confirm-cancel-btn:hover {
      background: rgba(75, 85, 99, 0.3);
      border-color: #6B7280;
      color: #D1D5DB;
    }

    /* AUTO-SCAN INDICATOR */
    .auto-scan-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }

    .auto-scan-pulse {
      width: 8px;
      height: 8px;
      background: white;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.5;
        transform: scale(1.2);
      }
    }

    /* SUMMARY MODAL */
    .summary-modal-content {
      width: 700px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }

    .summary-total-banner {
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
      padding: 20px 28px;
      border-radius: 12px;
      margin-bottom: 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .summary-total-label {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.9;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .summary-total-value {
      font-size: 36px;
      font-weight: 700;
    }

    .summary-list {
      max-height: 450px;
      overflow-y: auto;
      margin-bottom: 24px;
    }

    .summary-participant {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid #E5E7EB;
      transition: background 150ms ease;
    }

    .summary-participant:hover {
      background: #F9FAFB;
    }

    .summary-participant:last-child {
      border-bottom: none;
    }

    .summary-user-info {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }

    .summary-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      color: #fff;
      font-weight: 700;
      font-size: 14px;
      background: linear-gradient(135deg, #A855F7, #FF4FB2);
      flex-shrink: 0;
    }

    .summary-username {
      font-size: 15px;
      font-weight: 600;
      color: #111827;
    }

    .summary-stats {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .summary-stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .summary-stat-label {
      font-size: 11px;
      font-weight: 600;
      color: #6B7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .summary-stat-value {
      font-size: 16px;
      font-weight: 700;
      color: #111827;
    }

    .summary-owed-value {
      color: #10B981;
    }

    /* TOAST NOTIFICATION */
    .toast {
      position: absolute;
      top: 30px;
      right: 30px;
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
      padding: 20px 28px;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(16, 185, 129, 0.5);
      font-size: 15px;
      font-weight: 600;
      z-index: 10000;
      min-width: 380px;
      max-width: 480px;
      opacity: 0;
      transform: translateX(400px);
      transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1),
                  transform 400ms cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }

    .toast-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .toast-icon {
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.25);
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-size: 18px;
      flex-shrink: 0;
    }

    .toast-title {
      font-size: 16px;
      font-weight: 700;
      margin: 0;
    }

    .toast-body {
      margin-left: 44px;
      font-size: 13px;
      font-weight: 500;
      line-height: 1.6;
      opacity: 0.95;
    }

    .toast-detail {
      margin-top: 4px;
      color: rgba(255, 255, 255, 0.9);
    }

    .toast-close {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 24px;
      height: 24px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 16px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: background 150ms ease;
    }

    .toast-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* ERROR TOAST */
    .error-toast {
      position: absolute;
      top: 110px;
      right: 40px;
      background: linear-gradient(135deg, #EF4444, #DC2626);
      color: white;
      padding: 20px 28px;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(239, 68, 68, 0.5);
      font-size: 15px;
      font-weight: 600;
      z-index: 10000;
      min-width: 380px;
      max-width: 480px;
      opacity: 0;
      transform: translateX(400px);
      transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1),
                  transform 400ms cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }

    .error-toast.show {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }

    /* Hidden rows */
    .hidden { display: none !important; }

    /* ==============================
       ACCESS DENIED MODAL
       ============================== */
    .access-denied-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      z-index: 999999;
      animation: fadeIn 0.2s ease;
    }

    .access-denied-overlay.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .access-denied-modal {
      background: white;
      border-radius: 24px;
      padding: 0;
      width: 440px;
      max-width: 90vw;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      animation: slideUp 0.3s ease;
      overflow: hidden;
    }

    .access-modal-header {
      background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
      padding: 32px;
      text-align: center;
      position: relative;
    }

    .access-modal-icon {
      width: 72px;
      height: 72px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px;
      font-size: 36px;
      animation: shake 0.5s ease;
    }

    @keyframes shake {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-10deg); }
      75% { transform: rotate(10deg); }
    }

    .access-modal-title {
      font-size: 26px;
      font-weight: 800;
      color: white;
      margin: 0 0 8px 0;
      letter-spacing: -0.5px;
    }

    .access-modal-subtitle {
      font-size: 14px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
      margin: 0;
    }

    .access-modal-body {
      padding: 32px;
      text-align: center;
    }

    .access-modal-message {
      font-size: 16px;
      font-weight: 500;
      color: #374151;
      line-height: 1.6;
      margin: 0 0 24px 0;
    }

    .access-modal-actions {
      display: flex;
      gap: 12px;
    }

    .access-modal-btn {
      flex: 1;
      padding: 14px 24px;
      border: none;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 700;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s;
    }

    .access-modal-btn-primary {
      background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
      color: white;
    }

    .access-modal-btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(139, 92, 246, 0.4);
    }

    .access-modal-btn-primary:active {
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <div class="white-square">
    <div class="top-sidebar"></div>
    <div class="tako"></div>
    <div class="sidebar"></div>
    <div class="rectangle"></div>
    <div class="square" id="activeSquare"></div>

    <div id="themeToggle" title="Theme Toggle">
      <img src="/static/assets/Icons/OFF.png" alt="Theme toggle">
    </div>
    <div id="settingsBtn" title="Settings">
      <img src="/static/assets/Icons/Notifications%20Copy.png" alt="Settings">
    </div>

    <!-- FAST RAFFLE TIMER -->
    <div id="fastRaffleTimer" class="fast-raffle-timer">
      <span id="timerDisplay">01:15:00</span>
    </div>

    <!-- STATS -->
    <section class="stats-row" aria-label="Active raffle overview">
      <div class="stat-card c-pink">
        <div class="stat-label">Total Spots</div>
        <div class="stat-value" id="totalSpots">-</div>
      </div>
      <div class="stat-card c-purple">
        <div class="stat-label">Spots Remaining</div>
        <div class="stat-value" id="spotsRemaining">-</div>
      </div>
      <div class="stat-card c-green">
        <div class="stat-label">Cost Per Spot</div>
        <div class="stat-value" id="costPerSpot">-</div>
      </div>
      <div class="stat-card c-orange">
        <div class="stat-label">Total Owed</div>
        <div class="stat-value" id="totalOwed">$0</div>
      </div>
      <div class="stat-card c-blue">
        <div class="stat-label">Outstanding Balance</div>
        <div class="stat-value" id="totalPaid">$0</div>
      </div>
    </section>

    <!-- TABLE -->
    <section class="participants-card">
      <div class="participants-header">
        <div>
          <h3 class="participants-title">Participants</h3>
          <div class="participants-sub"><span id="totalParticipants">0</span> total participants ‚Ä¢ Next poll in <span id="nextPollTimer">60</span>s</div>
        </div>
<div style="display:flex; gap:10px;">
  <button id="setupBtn" class="btn btn-blue">Setup</button>
  <button id="summaryBtn" class="btn btn-purple">Summary</button>
  <button id="markPaidBtn" class="btn btn-green">Mark All Paid</button>
  <button id="scanEmailBtn" class="btn btn-purple">Scan Email</button>
  <button id="clearIdsBtn" class="btn btn-orange">Clear IDs</button>
  <button id="finishRaffleBtn" class="btn btn-red">Finish Raffle</button>
</div>

        <div style="display:flex; gap:12px; align-items:center;">
          <div class="search-box">
            <input id="participantSearch" type="text" placeholder="Search participants..." />
          </div>

          <select id="paymentFilter" class="filter-select">
            <option value="all">All Payments</option>
            <option value="paid">Paid</option>
            <option value="pending">Pending</option>
            <option value="tabs">Tabs Only</option>
          </select>
        </div>
      </div>

      <div class="table-wrap">
        <table class="p-table" id="participantsTable">
          <colgroup>
            <col class="col-reddit">
            <col class="col-name">
            <col class="col-tabbed">
            <col class="col-comment">
            <col class="col-spots">
            <col class="col-owed">
            <col class="col-paid">
            <col class="col-status">
          </colgroup>

          <thead>
            <tr>
              <th data-col="0"><div class="th-inner">Reddit User<span class="col-resizer"></span></div></th>
              <th data-col="1"><div class="th-inner">Name<span class="col-resizer"></span></div></th>
              <th data-col="2"><div class="th-inner">Tabbed<span class="col-resizer"></span></div></th>
              <th data-col="3"><div class="th-inner">Comment<span class="col-resizer"></span></div></th>
              <th data-col="4"><div class="th-inner">Spots<span class="col-resizer"></span></div></th>
              <th data-col="5"><div class="th-inner">Owed<span class="col-resizer"></span></div></th>
              <th data-col="6"><div class="th-inner">Paid<span class="col-resizer"></span></div></th>
              <th data-col="7"><div class="th-inner">Status<span class="col-resizer"></span></div></th>
            </tr>
          </thead>
          <tbody id="participantsTbody">
            <tr id="emptyRow">
              <td colspan="8" style="padding:26px 24px; text-align:center; color:#64748b;">
                No participants yet. Click "Setup" to configure your raffle.
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="participants-foot">
        <div id="footerShowing">Showing 0 of 0 participants</div>
        <div id="autoScanIndicator" class="auto-scan-indicator" style="display: none;">
          <div class="auto-scan-pulse"></div>
          <span>Auto scanning Every 10 Seconds</span>
        </div>
        <div id="footerStats">Paid: <strong>0</strong> &nbsp;&nbsp; Pending: <strong>0</strong></div>
      </div>
    </section>

   <!-- NAV -->
<nav class="sidebar-nav" id="sidebarNav">
  <a class="nav-item" href="/dashboard"><img class="nav-icon" src="/static/assets/Icons/Heart-Rate.png" alt="">Dashboard</a>
  <a class="nav-item is-active" href="/active-raffle"><img class="nav-icon" src="/static/assets/Icons/Graph%20Copy.png" alt="">Active Raffle</a>
  <a class="nav-item" href="/raffle-history"><img class="nav-icon" src="/static/assets/Icons/Graph.png" alt="">Raffle History</a>
  <a class="nav-item" href="/activity-log"><img class="nav-icon" src="/static/assets/Icons/activity.png" alt="">Activity Log</a>
  <a class="nav-item" href="/profile"><img class="nav-icon" src="/static/assets/Icons/icons8-user-30%201.png" alt="">Profile</a>
  <a class="nav-item" href="/discord"><img class="nav-icon" src="/static/assets/Icons/discord_white_logo%201.png" alt="">Discord</a>
  <a class="nav-item" href="/help"><img class="nav-icon" src="/static/assets/Icons/help.png" alt="">Help</a>
  <a class="nav-item" href="/donate"><img class="nav-icon" src="/static/assets/Icons/Graph%20Copy%204.png" alt="">Donate</a>
  <a class="nav-item" href="/admin">Admin</a>
</nav>

<!-- USER SECTION -->
<div class="user-section" id="userSection">
  <div class="user-info">
    <div class="user-avatar" id="userAvatar">U</div>
    <div class="user-details">
      <p class="user-name" id="userName">User</p>
      <p class="user-role" id="userRole">Admin</p>
    </div>
  </div>
  <button class="logout-btn" id="sidebarLogoutBtn">Logout</button>
</div>

<!-- APP VERSION -->
<div class="app-version">v1.0.0</div>

<script>
  // ============ USER SECTION & LOGOUT ============
  (async function() {
    const userAvatar = document.getElementById('userAvatar');
    const userName = document.getElementById('userName');
    const userRole = document.getElementById('userRole');
    const logoutBtn = document.getElementById('sidebarLogoutBtn');

    // Fetch current user info
    try {
      const response = await fetch('/api/auth/current-user');
      if (response.ok) {
        const result = await response.json();
        if (result.ok && result.data) {
          const user = result.data;

          // Update username
          if (user.username) {
            userName.textContent = user.username;
            // Update avatar with first letter
            userAvatar.textContent = user.username.charAt(0).toUpperCase();
          }

          // Update role
          if (user.role) {
            userRole.textContent = user.role.charAt(0).toUpperCase() + user.role.slice(1);
          } else if (user.isAdmin) {
            userRole.textContent = 'Admin';
          } else {
            userRole.textContent = 'User';
          }
        }
      }
    } catch (error) {
      console.error('Failed to fetch user info:', error);
    }

    // Logout button handler
    logoutBtn?.addEventListener('click', async () => {
      try {
        const response = await fetch('/api/auth/logout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        const result = await response.json();

        if (result.ok) {
          window.location.href = '/login';
        } else {
          alert('‚ùå Logout failed: ' + (result.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Logout error:', error);
        alert('‚ùå Logout failed: ' + error.message);
      }
    });
  })();

  // Sidebar Admin Control - Intercept admin links for non-admin users
  (function() {
    const sidebarNav = document.getElementById('sidebarNav');
    if (!sidebarNav) return;

    // Find admin links
    const allLinks = sidebarNav.querySelectorAll('.nav-item');
    allLinks.forEach(link => {
      const href = link.getAttribute('href');

      // Prevent reload when clicking active raffle link on active raffle page
      if (href === '/active-raffle') {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          // Do nothing - already on this page
        });
      }

      if (href === '/admin' || href === '/user-management' || href === './admin.html' || href === './user_management.html') {
        // Add click handler that runs BEFORE navigation - block by default, only allow if admin
        link.addEventListener('click', async function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          // Check if user is admin
          if (window.adminCheckComplete === true) {
            // Admin confirmed - allow navigation
            window.location.href = href;
          } else {
            // Non-admin or check not complete - show modal and stay here
            showAccessDenied();
          }
        }, true);
      }
    });

    // Check if user is admin (async)
    (async function() {
      try {
        const response = await fetch('/api/auth/current-user');
        if (!response.ok) return;

        const data = await response.json();
        if (data.data?.isAdmin === true) {
          window.adminCheckComplete = true;
          console.log('‚úÖ Admin access granted');
        } else {
          console.log('üîí Admin links blocked for non-admin user');
        }
      } catch (error) {
        console.error('Error checking admin status:', error);
      }
    })();
  })();
</script>

 <!-- SETUP MODAL -->
  <div id="setupModal" class="modal-overlay">
    <div class="modal-content" style="width: 600px;">
      <h3 class="modal-title">Raffle Setup</h3>

      <div class="modal-form">
        <div class="form-group">
          <label class="form-label">Reddit Link</label>
          <input
            type="url"
            id="redditLinkInput"
            class="form-input"
            placeholder="https://reddit.com/r/WatchURaffle/comments/abc123/post_title/"
          />
          <p style="font-size: 12px; color: #64748b; margin: 6px 0 0 0;">
            Enter the complete Reddit post URL (must include /comments/)
          </p>
        </div>

<div class="form-row" style="gap: 50px !important;">
          <div class="form-group">
            <label class="form-label">Total Spots</label>
            <input
              type="number"
              id="totalSpotsInput"
              class="form-input"
              placeholder="100"
            />
          </div>

          <div class="form-group">
            <label class="form-label">Cost Per Spot ($)</label>
            <input
              type="number"
              id="spotCostInput"
              class="form-input"
              placeholder="e.g. 50 or 0.25"
              step="0.01"
              min="0.01"
            />
          </div>
        </div>

        <div class="form-group" style="margin-top: 16px;">
          <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; user-select: none;">
            <input
              type="checkbox"
              id="fastRaffleCheckbox"
              style="width: 18px; height: 18px; cursor: pointer;"
            />
            <span class="form-label" style="margin: 0; cursor: pointer;">
              Enable Fast Raffle Timer (1 hour 15 minutes)
            </span>
          </label>
          <p style="font-size: 12px; color: #64748b; margin: 6px 0 0 28px;">
            A countdown timer will appear at the top of the page
          </p>
        </div>
      </div>

      <div class="modal-actions">
        <button id="modalCancelBtn" class="modal-btn modal-btn-cancel">Cancel</button>
        <button id="modalSaveBtn" class="modal-btn modal-btn-save">Save Setup</button>
      </div>
    </div>
  </div>

 <!-- FINISH RAFFLE MODAL -->
  <div id="finishModal" class="modal-overlay">
    <div class="modal-content finish-modal-content">
      <div class=\"finish-modal-icon\">üéâ</div>
      <h3 class=\"modal-title\" style=\"text-align: center;\">Finish Raffle</h3>
      <p class=\"finish-modal-text\" id="finishModalText">
        Select the number of winners and enter their information to complete the raffle.
      </p>

      <!-- Winner Selection Section -->
      <div class="winner-section">
        <div class="winner-section-title">
          <span>üèÜ</span>
          <span>Winner Information</span>
        </div>

        <!-- Number of Winners Selector -->
        <div class="winner-count-selector">
          <label class="form-label" style="margin-bottom: 10px;">Number of Winners</label>
          <div class="winner-count-buttons">
            <button type="button" class="winner-count-btn active" data-count="1">üèÜ 1</button>
            <button type="button" class="winner-count-btn" data-count="2">üèÜx2</button>
            <button type="button" class="winner-count-btn" data-count="3">üèÜx3</button>
            <button type="button" class="winner-count-btn" data-count="4">üèÜ√ó4</button>
            <button type="button" class="winner-count-btn" data-count="5">üèÜ√ó5</button>
          </div>
        </div>

        <!-- Dynamic Winner Entries -->
        <div id="winnerEntriesContainer">
          <!-- Will be populated dynamically -->
        </div>
      </div>

      <div class="finish-modal-actions">
        <button id="finishCompleteBtn" class="finish-btn finish-btn-complete" disabled>
          ‚úì Complete Raffle
        </button>
      </div>
    </div>
  </div>

  <!-- RESTRICTION POPUP MODAL -->
  <div id="restrictionModal" class="modal-overlay">
    <div class="modal-content restriction-modal-content">
      <div class="restriction-modal-icon">‚ö†Ô∏è</div>
      <h3 id="restrictionModalTitle" class="restriction-modal-title">Cannot Finish Raffle!</h3>
      <div id="restrictionMessage" class="restriction-modal-message"></div>
      <div class="restriction-modal-actions">
        <button id="restrictionOkBtn" class="restriction-ok-btn">OK</button>
        <button id="restrictionCancelRaffleBtn" class="restriction-cancel-btn" style="display: none;">√ó Cancel Raffle</button>
      </div>
    </div>
  </div>

  <!-- PAYPAL SCAN CONFIRMATION MODAL -->
  <div id="paypalScanModal" class="modal-overlay">
    <div class="modal-content paypal-scan-modal-content">
      <h3 class="paypal-scan-modal-title">Scan your Gmail for PayPal payment notifications?</h3>
      <div class="paypal-scan-modal-message">
        This will:<br>
        ‚Ä¢ Match payments to participants by amount + name<br>
        ‚Ä¢ Auto-mark participants as paid when matched
      </div>
      <div class="paypal-scan-modal-actions">
        <button id="paypalScanOkBtn" class="paypal-scan-ok-btn">OK</button>
        <button id="paypalScanCancelBtn" class="paypal-scan-cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- CANCEL RAFFLE CONFIRMATION MODAL -->
  <div id="cancelConfirmModal" class="modal-overlay">
    <div class="modal-content cancel-confirm-modal-content">
      <div class="cancel-confirm-title">Are you sure you want to cancel this raffle? It will be saved as incomplete.</div>
      <div class="cancel-confirm-actions">
        <button id="cancelConfirmOkBtn" class="cancel-confirm-ok-btn">OK</button>
        <button id="cancelConfirmCancelBtn" class="cancel-confirm-cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- SUMMARY MODAL -->
  <div id="summaryModal" class="modal-overlay">
    <div class="modal-content summary-modal-content">
      <h3 class="modal-title">Raffle Summary</h3>

      <div class="summary-total-banner">
        <div>
          <div class="summary-total-label">Total Owed</div>
          <div class="summary-total-value" id="summaryTotalOwed">$0</div>
        </div>
        <div style="text-align: right;">
          <div class="summary-total-label">Participants</div>
          <div class="summary-total-value" id="summaryTotalParticipants">0</div>
        </div>
      </div>

      <div class="summary-list" id="summaryList">
        <!-- Participants will be populated here -->
      </div>

      <div class="modal-actions">
        <button id="summaryCloseBtn" class="modal-btn modal-btn-save" style="width: 100%;">Close</button>
      </div>
    </div>
  </div>

  <!-- NAME IMPORT MODAL -->
  <div id="nameImportModal" class="modal-overlay">
    <div class="modal-content" style="width: 600px;">
      <h3 class="modal-title">Import Reddit Name Mappings</h3>

      <div class="modal-form">
        <div class="form-group">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #334155;">Upload File</label>
          <input type="file" id="nameFileInput" accept=".csv,.xlsx,.xls,.tsv,.txt" style="display: block; margin-bottom: 12px; padding: 8px; border: 2px dashed #cbd5e1; border-radius: 8px; width: 100%; cursor: pointer;">
          <p style="font-size: 12px; color: #64748b; margin: 0;">
            Supported: CSV, Excel (.xlsx, .xls), TSV<br>
            Format: <code>reddit_user,real_name</code>
          </p>
        </div>

        <div id="importPreview" style="display: none; margin-top: 16px; padding: 12px; background: #f8fafc; border-radius: 8px;">
          <p style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">Preview (first 5 rows):</p>
          <div id="importPreviewList" style="font-size: 12px; font-family: monospace; color: #475569;"></div>
          <p id="importCount" style="font-size: 13px; color: #16a34a; margin-top: 8px; font-weight: 600;"></p>
        </div>

        <div style="margin-top: 20px; padding: 12px; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px;">
          <p style="font-size: 13px; margin: 0; color: #92400e;">
            <strong>Note:</strong> Names are stored locally. Importing will merge with existing mappings.
          </p>
        </div>
      </div>

      <div class="modal-actions">
        <button id="nameImportBtn" class="modal-btn modal-btn-save" disabled>
          Import Names
        </button>
        <button id="nameExportBtn" class="modal-btn modal-btn-secondary">
          Export Current Mappings
        </button>
        <button id="nameClearBtn" class="modal-btn modal-btn-secondary" style="background: #dc2626; color: white;">
          Clear All Mappings
        </button>
        <button id="nameImportCloseBtn" class="modal-btn modal-btn-secondary">
          Close
        </button>
      </div>
    </div>
  </div>



  <!-- TOAST NOTIFICATION -->
  <div id="successToast" class="toast">
    <button class="toast-close" id="toastClose">√ó</button>
    <div class="toast-header">
      <div class="toast-icon">‚úì</div>
      <h4 class="toast-title" id="toastTitle">Success!</h4>
    </div>
    <div class="toast-body">
      <div id="toastMessage"></div>
    </div>
  </div>

  <!-- ERROR TOAST NOTIFICATION -->
  <div id="errorToast" class="error-toast">
    <button class="toast-close" id="errorToastClose">√ó</button>
    <div class="toast-header">
      <div class="toast-icon">‚úï</div>
      <h4 class="toast-title" id="errorToastTitle">Error</h4>
    </div>
    <div class="toast-body">
      <div id="errorToastMessage"></div>
    </div>
  </div>

  <script>

    // ============ APP STATE ============
    window.appState = {
      activeRaffleId: null,  // Store raffle ID for backend operations
      redditLink: '',
      totalSpots: null,
      costPerSpot: null,
      participants: [],
      createdAt: null,  // Timestamp when raffle setup was saved (ISO 8601 format)
      fastRaffleEnabled: false,
      fastRaffleStartTime: null
    };
    
    // Alias for convenience - all references can use 'appState' but it's globally accessible via window.appState
    const appState = window.appState;
    
    // Helper to get user-specific localStorage key (only used for polling flags, not raffle data)
    function getUserLocalStorageKey(baseKey) {
      // Get user from localStorage (where auth is stored)
      try {
        const userStr = localStorage.getItem('takobot_user');
        if (userStr) {
          const user = JSON.parse(userStr);
          return `user${user.id}_${baseKey}`;
        }
      } catch (e) {
        console.error('Failed to get user from localStorage:', e);
      }
      return `anonymous_${baseKey}`;
    }

    // ============ PERSISTENCE FUNCTIONS ============
    // DATABASE-ONLY: All raffle data is stored in the database
    // User authentication info is stored in localStorage (managed by login system)
    
    async function saveState() {
      try {
        // ‚úÖ FIX: Save in the SAME format as Reddit parser for consistency
        const participantsForDB = appState.participants.map(p => ({
          redditUser: p.redditUser || '',    // ‚Üê Match Reddit parser format
          name: p.name || '',
          comment: p.comment || '',
          spots: p.spots || 0,               // ‚Üê Match Reddit parser format
          owed: p.owed || 0,                 // ‚Üê Match Reddit parser format
          paid: p.paid || false,             // ‚Üê Match Reddit parser format
          requestLink: p.requestLink || '',
          commentId: p.commentId || ''       // ‚Üê For duplicate detection
        }));
        
        // User info comes from localStorage automatically via API.js getUserHeaders()
        const result = await API.saveRaffle({
          redditLink: appState.redditLink,
          totalSpots: appState.totalSpots,
          costPerSpot: appState.costPerSpot,
          participants: participantsForDB,
          fastRaffleEnabled: appState.fastRaffleEnabled,
          fastRaffleStartTime: appState.fastRaffleStartTime
        });
        
        console.log('üìù Save raffle response:', result);
        
        // Store the raffle ID from the response (in memory only)
        if (result.ok && result.raffle_id) {
          appState.activeRaffleId = result.raffle_id;
          console.log('‚úÖ Raffle saved to database. ID:', appState.activeRaffleId);
        } else {
          console.warn('‚ö†Ô∏è No raffle ID in response. Result:', result);
        }
      } catch (e) {
        console.error('‚ùå Failed to save state:', e);
      }
    }

   async function loadState() {
      try {
        const result = await API.loadRaffle();
        console.log('üìÇ Load raffle response:', result);
        
        if (result.ok && result.data) {
          const data = result.data;
          appState.activeRaffleId = data.id || null;
          appState.redditLink = data.redditLink || '';
          appState.totalSpots = data.totalSpots;
          appState.costPerSpot = data.costPerSpot;
          
          // ‚úÖ No transformation needed - data is already in the correct format from Reddit parser
          appState.participants = (data.participants || []).map(p => ({
            redditUser: p.redditUser || '',
            name: p.name || '',
            comment: p.comment || '',
            spots: p.spots || 0,
            owed: p.owed || 0,
            paid: p.paid || false,
            requestLink: p.requestLink || '',
            commentId: p.commentId || ''
          }));
          
          appState.fastRaffleEnabled = data.fastRaffleEnabled || false;
          // Convert ISO string to timestamp number
          if (data.fastRaffleStartTime) {
            appState.fastRaffleStartTime = new Date(data.fastRaffleStartTime).getTime();
          } else {
            appState.fastRaffleStartTime = null;
          }
          
          console.log('‚úÖ Raffle loaded from database. ID:', appState.activeRaffleId);
          console.log('üìä Loaded', appState.participants.length, 'participants');

          // Update modal inputs
          document.getElementById("redditLinkInput").value = appState.redditLink;

          // Only set values if they exist (no default values)
          if (appState.totalSpots) {
            document.getElementById("totalSpotsInput").value = appState.totalSpots;
          }
          if (appState.costPerSpot != null && appState.costPerSpot !== '') {
            document.getElementById("spotCostInput").value = appState.costPerSpot;
          }
          
          // Update fast raffle checkbox
          const fastRaffleCheckbox = document.getElementById("fastRaffleCheckbox");
          if (fastRaffleCheckbox) {
            fastRaffleCheckbox.checked = appState.fastRaffleEnabled;
          }

          // Rebuild table if there are participants
          if (appState.participants.length > 0) {
            console.log('üîÑ Calling rebuildTable() with', appState.participants.length, 'participants');
            rebuildTable();
            updateStats();
            updateFooter();
          }
          
          // Start timer if enabled
          console.log('üîç Timer check - enabled:', appState.fastRaffleEnabled, 'startTime:', appState.fastRaffleStartTime);
          if (appState.fastRaffleEnabled && appState.fastRaffleStartTime) {
            console.log('‚è±Ô∏è Starting timer from loadState');
            startFastRaffleTimer();
          } else {
            console.log('‚è±Ô∏è Timer not started - enabled:', appState.fastRaffleEnabled, 'startTime:', appState.fastRaffleStartTime);
          }
        } else {
          console.log('‚ÑπÔ∏è No active raffle found in database');
        }
      } catch (e) {
        console.error('‚ùå Failed to load state:', e);
      }
    }

    async function clearState() {
      try {
        console.log('üóëÔ∏è Calling API.clearRaffle()...');
        const result = await API.clearRaffle();
        console.log('üóëÔ∏è Clear raffle result:', result);
        if (!result.ok) {
          console.error('‚ùå Failed to clear raffle:', result.error);
        }
      } catch (e) {
        console.error('Failed to clear state:', e);
      }
    }

  function rebuildTable() {
      const tbody = document.getElementById("participantsTbody");
      const emptyRow = document.getElementById("emptyRow");

      if (appState.participants.length === 0) {
        if (!emptyRow) {
          tbody.innerHTML = '<tr id="emptyRow"><td colspan="8" style="padding:26px 24px; text-align:center; color:#64748b;">No participants yet. Click "Setup" to configure your raffle.</td></tr>';
        }
        return;
      }

      if (emptyRow) {
        emptyRow.remove();
      }

      tbody.innerHTML = '';

      // Use DocumentFragment for better performance with large tables
      const fragment = document.createDocumentFragment();

      // Python parser already sorts newest first (by timestamp), so use as-is
      const displayParticipants = appState.participants;

      // Batch localStorage lookups - read once instead of per participant
      const nameMappings = JSON.parse(localStorage.getItem('raffleui_reddit_name_mapping') || '{}');
      const tabbedMappings = JSON.parse(localStorage.getItem('raffleui_tabbed_mapping') || '{}');
      
      // Get all unique Reddit usernames for dropdown
      const allRedditUsers = Object.keys(nameMappings).sort();

      displayParticipants.forEach((participant, index) => {
        // Index is already correct since we're not reversing

        const row = document.createElement('tr');
        row.dataset.reddit = participant.redditUser;
        row.dataset.name = participant.name;
        row.dataset.comment = participant.comment;
        row.dataset.paid = participant.paid;
        row.dataset.index = index;  // Use correct index for editing

        const initial = participant.redditUser.charAt(2).toUpperCase();
        const statusClass = participant.paid ? 'status-paid' : 'status-pending';
        const statusIcon = participant.paid ? '‚úì' : '‚è±';
        const statusText = participant.paid ? 'Paid' : 'Pending';

        // Check if this is a tab entry
        const isTab = participant.comment && (participant.comment.toLowerCase().includes('tab') || participant.comment.toLowerCase().includes('tabbed'));
        const tabBadge = isTab ? '<span class="tab-badge">TAB</span>' : '';

        // Use pre-loaded name mappings instead of function call per participant
        const storedName = nameMappings[participant.redditUser];
        const displayName = storedName || participant.name || '';

        // Build dropdown options (use participant.tabbed for THIS row only)
        const currentTabbed = participant.tabbed || '';
        let dropdownOptions = '<option value="">‚Äî None ‚Äî</option>';
        allRedditUsers.forEach(redditUser => {
          const selected = redditUser === currentTabbed ? 'selected' : '';
          const name = nameMappings[redditUser] || '';
          const displayText = name ? `${redditUser} (${name})` : redditUser;
          dropdownOptions += `<option value="${redditUser}" ${selected}>${displayText}</option>`;
        });

        row.innerHTML = `
          <td>
            <div class="user-cell">
              <div class="avatar">${initial}</div>
              <a class="reddit-link" href="#" onclick="return false;">${participant.redditUser}</a>
              ${tabBadge}
            </div>
          </td>
          <td><span class="name-field" data-index="${index}" style="cursor: pointer; display: inline-block; min-width: 100px; padding: 4px;" title="Click to edit name">${displayName || '<span style="color: #94a3b8;">‚Äî</span>'}</span></td>
          <td>
            <select class="tabbed-dropdown" data-index="${index}" data-reddit="${participant.redditUser}">
              ${dropdownOptions}
            </select>
          </td>
          <td><span class="comment-muted">${participant.comment || ''}</span></td>
          <td><span class="spots-pill" data-index="${index}" style="cursor: pointer;" title="Double-click to edit">${participant.spots}</span></td>
          <td>$${parseFloat(participant.owed).toFixed(2)}</td>
          <td style="text-align: center;">
            <input type="checkbox" class="paid-checkbox" data-index="${index}" ${participant.paid ? 'checked' : ''} />
          </td>
          <td><span class="status-chip ${statusClass}"><span class="dot">${statusIcon}</span>${statusText}</span></td>
        `;

        fragment.appendChild(row);
      });

      // Single DOM update instead of multiple appendChild calls
      tbody.appendChild(fragment);

      // Add double-click edit functionality
      attachSpotEditListeners();

      // Add name edit functionality
      attachNameEditListeners();

      // Add checkbox event listeners
      attachPaidCheckboxListeners();

      // Add tabbed dropdown listeners
      attachTabbedDropdownListeners();

      // Add click handlers for tab rows
      if (typeof window.attachTabRowClickHandlers === 'function') {
        attachTabRowClickHandlers();
      }
    }

    function attachSpotEditListeners() {
      const spotsPills = document.querySelectorAll('.spots-pill');

      spotsPills.forEach(pill => {
        pill.addEventListener('dblclick', function() {
          const index = parseInt(this.dataset.index);
          const currentSpots = appState.participants[index].spots;

          // Create input field
          const input = document.createElement('input');
          input.type = 'number';
          input.value = currentSpots;
          input.min = '0';
          input.style.width = '50px';
          input.style.padding = '4px 8px';
          input.style.border = '2px solid #6E5FFC';
          input.style.borderRadius = '999px';
          input.style.textAlign = 'center';
          input.style.fontSize = '12px';
          input.style.fontWeight = '700';
          input.style.color = '#6E5FFC';
          input.style.background = '#efe9ff';
          input.style.outline = 'none';

          // Replace pill with input
          const originalContent = this.textContent;
          this.textContent = '';
          this.appendChild(input);
          input.focus();
          input.select();

          // Save on Enter or blur
          const saveEdit = async () => {
            const newSpots = parseInt(input.value) || 0;

            if (newSpots < 0) {
              showErrorToast('Invalid Spot Value', ['Spots cannot be negative']);
              input.value = currentSpots;
              return;
            }

            // Update participant data
            appState.participants[index].spots = newSpots;
            appState.participants[index].owed = newSpots * appState.costPerSpot;

            // Save to database
            await saveState();

            // Rebuild table
            rebuildTable();
            updateStats();
            updateFooter();

            // Show toast
            showToast('Spots Updated', [`${appState.participants[index].redditUser}: ${currentSpots} ‚Üí ${newSpots} spots`]);
          };

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              saveEdit();
            } else if (e.key === 'Escape') {
              rebuildTable();
            }
          });

          input.addEventListener('blur', saveEdit);
        });
      });
    }

    // ============ NAME MAPPING LOCALSTORAGE ============
    const NAME_MAPPING_KEY = 'raffleui_reddit_name_mapping';

    function saveNameMapping(redditUser, realName) {
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');
        mappings[redditUser] = realName;
        localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(mappings));
      } catch (e) {
        console.error('Failed to save name mapping:', e);
      }
    }

    function getNameFromMapping(redditUser) {
      try {
        const mappings = JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');
        return mappings[redditUser] || '';
      } catch (e) {
        return '';
      }
    }

    function loadAllMappings() {
      try {
        return JSON.parse(localStorage.getItem(NAME_MAPPING_KEY) || '{}');
      } catch (e) {
        return {};
      }
    }

    function saveAllMappings(mappings) {
      try {
        localStorage.setItem(NAME_MAPPING_KEY, JSON.stringify(mappings));
      } catch (e) {
        console.error('Failed to save mappings:', e);
      }
    }

    function clearAllMappings() {
      localStorage.removeItem(NAME_MAPPING_KEY);
    }

    function exportMappingsAsCSV() {
      const mappings = loadAllMappings();
      let csv = 'reddit_user,real_name\n';
      for (const [reddit, name] of Object.entries(mappings)) {
        csv += `${reddit},${name}\n`;
      }
      return csv;
    }

    // ============ TABBED MAPPING LOCALSTORAGE ============
    const TABBED_MAPPING_KEY = 'raffleui_tabbed_mapping';

    function saveTabbedMapping(redditUser, tabbedToUser) {
      try {
        const mappings = JSON.parse(localStorage.getItem(TABBED_MAPPING_KEY) || '{}');
        if (tabbedToUser) {
          mappings[redditUser] = tabbedToUser;
        } else {
          delete mappings[redditUser]; // Remove if set to empty
        }
        localStorage.setItem(TABBED_MAPPING_KEY, JSON.stringify(mappings));
        console.log('‚úÖ Tabbed mapping saved:', redditUser, '‚Üí', tabbedToUser || 'none');
      } catch (e) {
        console.error('Failed to save tabbed mapping:', e);
      }
    }

    function getTabbedMapping(redditUser) {
      try {
        const mappings = JSON.parse(localStorage.getItem(TABBED_MAPPING_KEY) || '{}');
        return mappings[redditUser] || '';
      } catch (e) {
        return '';
      }
    }

    function attachTabbedDropdownListeners() {
      const dropdowns = document.querySelectorAll('.tabbed-dropdown');
      
      dropdowns.forEach(dropdown => {
        dropdown.addEventListener('change', async function() {
          const index = parseInt(this.dataset.index);
          const redditUser = this.dataset.reddit;
          const tabbedToUser = this.value;
          
          // Save to THIS SPECIFIC participant row (not all rows with same user)
          if (appState.participants[index]) {
            appState.participants[index].tabbed = tabbedToUser || null;
            await saveState();
          }
          
          // Show feedback
          if (tabbedToUser) {
            showToast('Tab Assignment Updated', [`${redditUser} tabbed to ${tabbedToUser}`]);
          } else {
            showToast('Tab Removed', [`${redditUser} tab assignment cleared`]);
          }
          
          // Refresh table to update display
          renderParticipantsTable();
        });
      });
    }

    // ============ NAME EDIT FUNCTIONALITY ============
    function attachNameEditListeners() {
      const nameFields = document.querySelectorAll('.name-field');

      nameFields.forEach(field => {
        field.addEventListener('click', function() {
          const index = parseInt(this.dataset.index);
          const participant = appState.participants[index];
          const currentName = getNameFromMapping(participant.redditUser) || participant.name || '';

          // Create input field
          const input = document.createElement('input');
          input.type = 'text';
          input.value = currentName;
          input.style.width = '140px';
          input.style.padding = '4px 8px';
          input.style.border = '1px solid #cbd5e1';
          input.style.borderRadius = '4px';
          input.style.fontSize = '14px';
          input.style.fontFamily = 'Inter, sans-serif';

          // Replace field with input
          const parentTd = this.parentElement;
          parentTd.innerHTML = '';
          parentTd.appendChild(input);
          input.focus();
          input.select();

          const saveEdit = async () => {
            const newName = input.value.trim();

            // Save to localStorage
            if (newName) {
              saveNameMapping(participant.redditUser, newName);
            }

            // Update participant object
            appState.participants[index].name = newName;
            await saveState();
            rebuildTable();

            // Show toast
            showToast('Name Updated', [`${participant.redditUser} ‚Üí ${newName || '(cleared)'}`]);
          };

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              saveEdit();
            } else if (e.key === 'Escape') {
              rebuildTable();
            }
          });

          input.addEventListener('blur', saveEdit);
        });
      });
    }

    function attachPaidCheckboxListeners() {
      const checkboxes = document.querySelectorAll('.paid-checkbox');

      checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', async function() {
          const index = parseInt(this.dataset.index);
          const newPaidStatus = this.checked;
          const participant = appState.participants[index];

          // Update participant paid status
          appState.participants[index].paid = newPaidStatus;

          // Save to database
          await saveState();

          // Rebuild table to update status chip
          rebuildTable();
          
          // Reapply current filter/search (so filtered participants disappear if they no longer match)
          filterAndSearch();
          
          updateStats();

          // Log activity
          await API.logActivity({
            type: newPaidStatus ? 'payment' : 'edit',
            title: newPaidStatus ? 'Payment received' : 'Payment unmarked',
            details: `${participant.redditUser} ‚Ä¢ $${parseFloat(participant.owed).toFixed(2)}`,
            badge: newPaidStatus ? 'Payment' : 'Edit'
          });

          // Show toast
          const statusText = newPaidStatus ? 'marked as paid' : 'marked as unpaid';
          showToast('Payment Status Updated', [`${participant.redditUser} ${statusText}`]);
        });
      });
    }

    // ============ UTILITY FUNCTIONS ============
    function showToast(title, details) {
      const toast = document.getElementById("successToast");
      const toastTitle = document.getElementById("toastTitle");
      const toastMessage = document.getElementById("toastMessage");

      // Clear any existing toast and timeout
      toast.classList.remove("show");
      
      // Use requestAnimationFrame to ensure the removal takes effect before re-showing
      requestAnimationFrame(() => {
        toastTitle.textContent = title;
        toastMessage.innerHTML = details.map(d => `<div class="toast-detail">${d}</div>`).join('');

        toast.classList.add("show");

        setTimeout(() => {
          toast.classList.remove("show");
        }, 8000);
      });
    }

    function showErrorToast(title, details) {
      const errorToast = document.getElementById("errorToast");
      const errorToastTitle = document.getElementById("errorToastTitle");
      const errorToastMessage = document.getElementById("errorToastMessage");

      errorToastTitle.textContent = title;
      errorToastMessage.innerHTML = details.map(d => `<div class="toast-detail">${d}</div>`).join('');

      errorToast.classList.add("show");

      setTimeout(() => {
        errorToast.classList.remove("show");
      }, 5000);
    }

function updateStats() {
      const totalSpotsEl = document.getElementById("totalSpots");
      const spotsRemainingEl = document.getElementById("spotsRemaining");
      const costPerSpotEl = document.getElementById("costPerSpot");
      const totalOwedEl = document.getElementById("totalOwed");
      const totalPaidEl = document.getElementById("totalPaid");

      totalSpotsEl.textContent = appState.totalSpots !== null ? appState.totalSpots : '-';
      costPerSpotEl.textContent = appState.costPerSpot !== null ? `$${parseFloat(appState.costPerSpot).toFixed(2)}` : '-';

      const spotsClaimed = appState.participants.reduce((sum, p) => sum + (p.spots || 0), 0);
      const spotsRemaining = appState.totalSpots !== null ? Math.max(0, appState.totalSpots - spotsClaimed) : '-';  // ADD Math.max(0, ...)
      spotsRemainingEl.textContent = spotsRemaining;

      // Stop auto-polling when raffle is full (0 spots remaining)
      if (spotsRemaining === 0 && pollingInterval) {
        stopAutoPolling();
        console.log('üéØ Raffle is full! Auto-polling stopped.');
      }

      // Restart auto-polling if spots open up and polling is not running
      if (spotsRemaining > 0 && !pollingInterval && appState.redditLink && appState.costPerSpot) {
        startAutoPolling();
        console.log('üîÑ Spots available! Auto-polling restarted.');
      }

      const totalOwed = appState.participants.reduce((sum, p) => sum + (p.owed || 0), 0);
      const totalPaid = appState.participants.filter(p => p.paid).reduce((sum, p) => sum + (p.owed || 0), 0);

      totalOwedEl.textContent = `$${totalOwed.toFixed(2)}`;
      
      // Show the difference (Total Paid - Total Owed)
      const difference = totalPaid - totalOwed;
      totalPaidEl.textContent = `$${difference.toFixed(2)}`;
    }

    function updateFooter() {
      const tbody = document.getElementById("participantsTbody");
      const visibleRows = Array.from(tbody.querySelectorAll("tr:not(.hidden):not(#emptyRow)"));
      const totalCount = appState.participants.length;
      const visibleCount = visibleRows.length;

      const paidCount = appState.participants.filter(p => p.paid).length;
      const pendingCount = totalCount - paidCount;

      document.getElementById("footerShowing").textContent = `Showing ${visibleCount} of ${totalCount} participants`;
      document.getElementById("footerStats").innerHTML = `Paid: <strong>${paidCount}</strong> &nbsp;&nbsp; Pending: <strong>${pendingCount}</strong>`;
      document.getElementById("totalParticipants").textContent = totalCount;
    }

    function filterAndSearch() {
      const searchQuery = document.getElementById("participantSearch").value.toLowerCase();
      const paymentFilter = document.getElementById("paymentFilter").value;
      const tbody = document.getElementById("participantsTbody");
      const rows = Array.from(tbody.querySelectorAll("tr:not(#emptyRow)"));

      rows.forEach(row => {
        const redditUser = row.dataset.reddit?.toLowerCase() || '';
        const name = row.dataset.name?.toLowerCase() || '';
        const comment = row.dataset.comment?.toLowerCase() || '';
        const paid = row.dataset.paid === 'true';

        // Check if comment contains tab/tabbed
        const isTab = comment.includes('tab');

        const matchesSearch = redditUser.includes(searchQuery) ||
                            name.includes(searchQuery) ||
                            comment.includes(searchQuery);
        const matchesFilter = paymentFilter === 'all' ||
                             (paymentFilter === 'paid' && paid) ||
                             (paymentFilter === 'pending' && !paid) ||
                             (paymentFilter === 'tabs' && isTab);

        if (matchesSearch && matchesFilter) {
          row.classList.remove('hidden');
        } else {
          row.classList.add('hidden');
        }
      });

      updateFooter();
    }

    async function saveToHistory(status, winner = null) {
      try {
        // Get current user
        let currentUsername = null;
        try {
          const userResult = await API.checkAuth();
          if (userResult.ok && userResult.data) {
            currentUsername = userResult.data.username;
          }
        } catch (e) {
          console.error('Failed to get current user:', e);
        }

        await API.saveToHistory({
          raffleDate: new Date().toISOString(),
          status: status,
          redditLink: appState.redditLink,
          totalSpots: appState.totalSpots,
          costPerSpot: appState.costPerSpot,
          participants: appState.participants,
          totalOwed: appState.participants.reduce((sum, p) => sum + (p.owed || 0), 0),
          totalPaid: appState.participants.filter(p => p.paid).reduce((sum, p) => sum + (p.owed || 0), 0),
          winner: winner,
          username: currentUsername,
          fastRaffleEnabled: appState.fastRaffleEnabled,
          fastRaffleStartTime: appState.fastRaffleStartTime
        });

        console.log(`‚úÖ Saved raffle to history for user: ${currentUsername}`);

        // Also log activity
        await API.logActivity({
          type: status === 'completed' ? 'completed' : 'cancelled',
          title: status === 'completed'
            ? `Raffle completed${winner ? ` - Winner: <span class="activity-highlight">${winner.username}</span>` : ''}`
            : 'Raffle cancelled',
          details: status === 'completed'
            ? `${appState.participants.length} participants ‚Ä¢ Total value: $${appState.participants.reduce((sum, p) => sum + (p.owed || 0), 0).toLocaleString()}${winner ? ` ‚Ä¢ Winning spot: #${winner.spot}` : ''}`
            : `${appState.participants.length} participants ‚Ä¢ Raffle cancelled before completion`,
          badge: status === 'completed' ? 'Completed' : 'Cancelled'
        });
      } catch (e) {
        console.error('Failed to save to history:', e);
      }
    }

  async function resetRaffle() {
      console.log('üîÑ resetRaffle() called - clearing app state and database');
      appState.activeRaffleId = null;  // Clear raffle ID
      appState.redditLink = '';
      appState.totalSpots = null;
      appState.costPerSpot = null;
      appState.participants = [];
      appState.fastRaffleEnabled = false;
      appState.fastRaffleStartTime = null;

      await clearState();
      console.log('‚úÖ resetRaffle() complete - raffle cleared from database');
      
      // Stop and hide timer
      stopFastRaffleTimer();

      const tbody = document.getElementById("participantsTbody");
      tbody.innerHTML = '<tr id="emptyRow"><td colspan="8" style="padding:26px 24px; text-align:center; color:#64748b;">No participants yet. Click "Setup" to configure your raffle.</td></tr>';

      document.getElementById("redditLinkInput").value = '';
      document.getElementById("totalSpotsInput").value = ''; // CHANGED from '100' to ''
      document.getElementById("spotCostInput").value = ''; // CHANGED from '50' to ''
      const fastRaffleCheckbox = document.getElementById("fastRaffleCheckbox");
      if (fastRaffleCheckbox) fastRaffleCheckbox.checked = false;
      document.getElementById("participantSearch").value = '';
      document.getElementById("paymentFilter").value = 'all';

      updateStats();
      updateFooter();
    }

    // ============ SIDEBAR NAVIGATION ============
    (function () {
      const nav = document.getElementById("sidebarNav");
      const square = document.getElementById("activeSquare");
      function moveSquareTo(item) {
        const navRect = nav.getBoundingClientRect();
        const itemRect = item.getBoundingClientRect();
        const navTop = parseFloat(getComputedStyle(nav).top) || 0;
        square.style.top = navTop + (itemRect.top - navRect.top) + "px";
      }
      const active = nav.querySelector(".is-active");
      if (active) {
        // Disable transition for initial positioning
        square.style.transition = "none";
        moveSquareTo(active);
        square.style.opacity = "1";
        // Re-enable transition after positioning
        setTimeout(() => {
          square.style.transition = "top 140ms ease";
        }, 50);
      }
    })();

    // ============ COLUMN RESIZE ============
    (function () {
      const table = document.getElementById("participantsTable");
      if (!table) return;

      const STORAGE_KEY = "raffleui_participants_colwidths_v1";
      const colgroup = table.querySelector("colgroup");
      const cols = Array.from(colgroup.querySelectorAll("col"));
      const ths = Array.from(table.querySelectorAll("thead th"));

      try {
        const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || "null");
        if (saved && Array.isArray(saved) && saved.length === cols.length) {
          saved.forEach((w, i) => {
            if (typeof w === "number" && w > 40) cols[i].style.width = Math.round(w) + "px";
          });
        }
      } catch (_) {}

      let isDragging = false;
      let startX = 0;
      let startWidth = 0;
      let colIndex = -1;

      function onMove(e) {
        if (!isDragging) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const dx = clientX - startX;
        const minW = 70;
        const newW = Math.max(minW, startWidth + dx);
        cols[colIndex].style.width = Math.round(newW) + "px";
        document.documentElement.classList.add("resizing");
      }

      function saveWidths() {
        const widths = cols.map(c => Math.round(parseFloat(getComputedStyle(c).width) || 0));
        localStorage.setItem(STORAGE_KEY, JSON.stringify(widths));
      }

      function onUp() {
        if (!isDragging) return;
        isDragging = false;
        colIndex = -1;
        document.documentElement.classList.remove("resizing");
        saveWidths();
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
        window.removeEventListener("touchmove", onMove, { passive:false });
        window.removeEventListener("touchend", onUp);
      }

      ths.forEach((th) => {
        const handle = th.querySelector(".col-resizer");
        if (!handle) return;

        handle.addEventListener("mousedown", (e) => {
          e.preventDefault();
          const idx = parseInt(th.dataset.col, 10);
          if (!Number.isFinite(idx)) return;

          isDragging = true;
          colIndex = idx;
          startX = e.clientX;
          startWidth = parseFloat(getComputedStyle(cols[idx]).width) || cols[idx].getBoundingClientRect().width;

          window.addEventListener("mousemove", onMove);
          window.addEventListener("mouseup", onUp);
        });

        handle.addEventListener("touchstart", (e) => {
          e.preventDefault();
          const idx = parseInt(th.dataset.col, 10);
          if (!Number.isFinite(idx)) return;

          isDragging = true;
          colIndex = idx;
          startX = e.touches[0].clientX;
          startWidth = parseFloat(getComputedStyle(cols[idx]).width) || cols[idx].getBoundingClientRect().width;

          window.addEventListener("touchmove", onMove, { passive:false });
          window.addEventListener("touchend", onUp);
        }, { passive:false });
      });
    })();

    // ============ SETTINGS BUTTON ============
    document.getElementById("settingsBtn").addEventListener("click", () => {
      window.location.href = "/settings";
    });

 // ============ SETUP MODAL ============
    (function () {
      const setupBtn = document.getElementById("setupBtn");
      const modal = document.getElementById("setupModal");
      const cancelBtn = document.getElementById("modalCancelBtn");
      const saveBtn = document.getElementById("modalSaveBtn");

      const redditLinkInput = document.getElementById("redditLinkInput");
      const totalSpotsInput = document.getElementById("totalSpotsInput");
      const spotCostInput = document.getElementById("spotCostInput");
      const pollingIntervalInput = document.getElementById("pollingIntervalInput");
      const fastRaffleCheckbox = document.getElementById("fastRaffleCheckbox");

      setupBtn.addEventListener("click", () => {
        modal.classList.add("show");
      });

      function closeModal() {
        modal.classList.remove("show");
      }

      cancelBtn.addEventListener("click", closeModal);

      // REMOVED: modal.addEventListener("click", ...) to prevent closing on outside click

      // Validate Reddit URL
      function validateRedditUrl(url) {
        if (!url || url.trim() === '') {
          return { valid: true, url: '' }; // Allow empty URLs
        }

        const trimmedUrl = url.trim();

        // Check if it's a valid Reddit post URL
        const redditRegex = /^https?:\/\/(www\.)?(reddit\.com|old\.reddit\.com)\/r\/[^\/]+\/comments\/[^\/]+\/[^\/]+\/?/i;

        if (!redditRegex.test(trimmedUrl)) {
          return {
            valid: false,
            error: 'Invalid Reddit URL format.\n\nPlease enter a complete Reddit post URL like:\nhttps://reddit.com/r/WatchURaffle/comments/abc123/post_title/'
          };
        }

        // Ensure it has https://
        let validUrl = trimmedUrl;
        if (!validUrl.startsWith('http://') && !validUrl.startsWith('https://')) {
          validUrl = 'https://' + validUrl;
        }

        return { valid: true, url: validUrl };
      }

      saveBtn.addEventListener("click", async () => {
        const redditLinkValue = redditLinkInput.value;

        // Validate all fields are filled out
        if (!redditLinkValue || !redditLinkValue.trim()) {
          showErrorToast('Reddit Link Required', [
            'Please enter a Reddit post URL to continue.',
            'Example: https://reddit.com/r/WatchURaffle/comments/abc123/post_title/'
          ]);
          redditLinkInput.focus();
          return;
        }

        if (!totalSpotsInput.value || totalSpotsInput.value.trim() === '') {
          showErrorToast('Total Spots Required', [
            'Please enter the total number of spots for this raffle.'
          ]);
          totalSpotsInput.focus();
          return;
        }

        if (!spotCostInput.value || spotCostInput.value.trim() === '') {
          showErrorToast('Cost Per Spot Required', [
            'Please enter the cost per spot in dollars.'
          ]);
          spotCostInput.focus();
          return;
        }

        // Validate numeric values
        const totalSpots = parseInt(totalSpotsInput.value);
        const spotCost = parseFloat(spotCostInput.value);

        if (isNaN(totalSpots) || totalSpots <= 0) {
          showErrorToast('Invalid Total Spots', [
            'Total spots must be a positive number.'
          ]);
          totalSpotsInput.focus();
          return;
        }

        if (isNaN(spotCost) || spotCost <= 0) {
          showErrorToast('Invalid Cost Per Spot', [
            'Cost per spot must be a positive number (minimum $0.01).'
          ]);
          spotCostInput.focus();
          return;
        }

        // Validate Reddit URL
        const validation = validateRedditUrl(redditLinkValue);
        if (!validation.valid) {
          showErrorToast('Invalid Reddit URL format', [
            'Please enter a complete Reddit post URL like:',
            'https://reddit.com/r/WatchURaffle/comments/abc123/post_title/'
          ]);
          redditLinkInput.focus();
          return;
        }

        const data = {
          redditLink: validation.url,
          totalSpots: totalSpots,
          spotCost: spotCost,
          fastRaffleEnabled: fastRaffleCheckbox.checked
        };

        appState.redditLink = data.redditLink;
        appState.totalSpots = data.totalSpots;
        appState.costPerSpot = data.spotCost;
        appState.fastRaffleEnabled = data.fastRaffleEnabled;
        
        // Set creation timestamp if this is the first time setup is saved
        if (!appState.createdAt) {
          appState.createdAt = new Date().toISOString();
          console.log('üïê Raffle creation timestamp set:', appState.createdAt);
        }

        // Start fast raffle timer if enabled
        if (data.fastRaffleEnabled) {
          appState.fastRaffleStartTime = Date.now();
          startFastRaffleTimer();
        } else {
          stopFastRaffleTimer();
        }

        await saveState();
        
        // Debug: Verify raffle ID was saved
        console.log('üîç After saveState(), activeRaffleId =', appState.activeRaffleId);
        
        updateStats();

        // Log activity
        await API.logActivity({
          type: 'setup',
          title: 'Raffle setup configured',
          details: `${data.totalSpots} spots @ $${data.spotCost} each${data.redditLink ? ' ‚Ä¢ Reddit link added' : ''}`,
          badge: 'Raffle Setup'
        });

        const details = [];
        if (data.redditLink) {
          details.push('üìù Reddit post linked');
        }
        details.push(`üéØ ${data.totalSpots} spots @ $${data.spotCost} each`);
        details.push(`ü§ñ Auto-scanning every 30 sec`);

        showToast('Setup Saved Successfully!', details);
        closeModal();
      });
    })();

 // ============ SUMMARY MODAL ============
    (function () {
      const summaryBtn = document.getElementById("summaryBtn");
      const modal = document.getElementById("summaryModal");
      const closeBtn = document.getElementById("summaryCloseBtn");

      summaryBtn.addEventListener("click", () => {
        populateSummary();
        modal.classList.add("show");
      });

      function closeModal() {
        modal.classList.remove("show");
      }

      closeBtn.addEventListener("click", closeModal);

      modal.addEventListener("click", (e) => {
        if (e.target === modal) closeModal();
      });

      function populateSummary() {
        // Combine duplicates by reddit username (with TAB swap logic)
        // IMPORTANT: TAB spots go to the TABBED user, not the requester
        const combinedParticipants = {};
        appState.participants.forEach(p => {
          // Check if this is a TAB entry
          const isTab = p.comment && (p.comment.toLowerCase().includes('tab') || p.comment.toLowerCase().includes('tabbed'));
          const tabbedUser = p.tabbed || '';  // Use participant.tabbed instead of shared mapping
          
          // For TAB: spots go to TABBED user, requester pays
          let displayUser = p.redditUser;
          let paidBy = null;
          let key = p.redditUser;
          
          if (isTab && tabbedUser) {
            displayUser = tabbedUser;  // Tabbed user gets the spots
            paidBy = p.redditUser;  // Original requester is paying
            key = `${tabbedUser}__TAB__${p.redditUser}`;  // Unique key per row
          }
          
          if (!combinedParticipants[key]) {
            combinedParticipants[key] = {
              redditUser: displayUser,
              name: p.name,
              spots: 0,
              owed: 0,
              paid: p.paid,
              paidBy: paidBy  // Store who is paying
            };
          }
          combinedParticipants[key].spots += parseInt(p.spots) || 0;
          combinedParticipants[key].owed += parseFloat(p.owed) || 0;
        });

        const combinedArray = Object.values(combinedParticipants);
        // Filter out participants with 0 spots
        const paidParticipants = combinedArray.filter(p => p.paid && p.spots > 0);
        const unpaidParticipants = combinedArray.filter(p => !p.paid && p.spots > 0);

        const totalOwed = unpaidParticipants.reduce((sum, p) => sum + (p.owed || 0), 0);
        const totalPaid = paidParticipants.reduce((sum, p) => sum + (p.owed || 0), 0);
        const totalParticipants = combinedArray.length;

        document.getElementById("summaryTotalOwed").textContent = `$${totalOwed.toLocaleString()}`;
        document.getElementById("summaryTotalParticipants").textContent = totalParticipants;

        const summaryList = document.getElementById("summaryList");
        summaryList.innerHTML = '';

        if (appState.participants.length === 0) {
          summaryList.innerHTML = '<div style="padding: 40px; text-align: center; color: #9CA3AF;">No participants yet</div>';
          return;
        }

        // Add summary stats header
        const statsHeader = document.createElement('div');
        statsHeader.style.cssText = 'display: flex; gap: 16px; padding: 16px; background: #F3F4F6; border-radius: 8px; margin-bottom: 20px;';
        statsHeader.innerHTML = `
          <div style="flex: 1; text-align: center;">
            <div style="font-size: 12px; color: #6B7280; margin-bottom: 4px;">Total Collected</div>
            <div style="font-size: 20px; font-weight: 700; color: #16a34a;">$${totalPaid.toLocaleString()}</div>
          </div>
          <div style="flex: 1; text-align: center;">
            <div style="font-size: 12px; color: #6B7280; margin-bottom: 4px;">Still Owed</div>
            <div style="font-size: 20px; font-weight: 700; color: #dc2626;">$${totalOwed.toLocaleString()}</div>
          </div>
        `;
        summaryList.appendChild(statsHeader);

        // Unpaid participants section
        if (unpaidParticipants.length > 0) {
          const unpaidHeader = document.createElement('div');
          unpaidHeader.style.cssText = 'font-size: 14px; font-weight: 700; color: #dc2626; padding: 12px 0 8px 0; border-top: 2px solid #fee2e2;';
          unpaidHeader.innerHTML = `‚è± Pending Payment (${unpaidParticipants.length})`;
          summaryList.appendChild(unpaidHeader);

          unpaidParticipants.forEach(participant => {
            const initial = participant.redditUser.charAt(2).toUpperCase();
            const displayName = getNameFromMapping(participant.redditUser) || participant.name || '';
            const nameDisplay = displayName ? `<div style="font-size: 11px; color: #64748b; margin-top: 2px;">${displayName}</div>` : '';
            
            // Add "(via ...)" note if someone else is paying
            const viaNote = participant.paidBy ? ` <span style="font-size: 11px; color: #94a3b8;">(via ${participant.paidBy})</span>` : '';

            const participantEl = document.createElement('div');
            participantEl.className = 'summary-participant';
            participantEl.style.background = '#fef3c7';
            participantEl.innerHTML = `
              <div class="summary-user-info">
                <div class="summary-avatar">${initial}</div>
                <div>
                  <div class="summary-username">${participant.redditUser}${viaNote}</div>
                  ${nameDisplay}
                </div>
              </div>
              <div class="summary-stats">
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Spots</div>
                  <div class="summary-stat-value">${participant.spots}</div>
                </div>
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Owed</div>
                  <div class="summary-stat-value summary-owed-value" style="color: #dc2626; font-weight: 700;">$${parseFloat(participant.owed).toFixed(2)}</div>
                </div>
              </div>
            `;
            summaryList.appendChild(participantEl);
          });
        }

        // Paid participants section
        if (paidParticipants.length > 0) {
          const paidHeader = document.createElement('div');
          paidHeader.style.cssText = 'font-size: 14px; font-weight: 700; color: #16a34a; padding: 20px 0 8px 0; border-top: 2px solid #dcfce7; margin-top: 16px;';
          paidHeader.innerHTML = `‚úì Paid (${paidParticipants.length})`;
          summaryList.appendChild(paidHeader);

          paidParticipants.forEach(participant => {
            const initial = participant.redditUser.charAt(2).toUpperCase();
            const displayName = getNameFromMapping(participant.redditUser) || participant.name || '';
            const nameDisplay = displayName ? `<div style="font-size: 11px; color: #64748b; margin-top: 2px;">${displayName}</div>` : '';
            
            // Add "(via ...)" note if someone else is paying
            const viaNote = participant.paidBy ? ` <span style="font-size: 11px; color: #94a3b8;">(via ${participant.paidBy})</span>` : '';

            const participantEl = document.createElement('div');
            participantEl.className = 'summary-participant';
            participantEl.style.background = '#dcfce7';
            participantEl.innerHTML = `
              <div class="summary-user-info">
                <div class="summary-avatar">${initial}</div>
                <div>
                  <div class="summary-username">${participant.redditUser}${viaNote}</div>
                  ${nameDisplay}
                </div>
              </div>
              <div class="summary-stats">
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Spots</div>
                  <div class="summary-stat-value">${participant.spots}</div>
                </div>
                <div class="summary-stat-item">
                  <div class="summary-stat-label">Paid</div>
                  <div class="summary-stat-value" style="color: #16a34a; font-weight: 700;">$${parseFloat(participant.owed).toFixed(2)}</div>
                </div>
              </div>
            `;
            summaryList.appendChild(participantEl);
          });
        }
      }
    })();



 // ============ NAME IMPORT MODAL ============
    // Note: This modal is now primarily used in Settings page
    // Keeping the handler logic here for potential inline use
    (function () {
      const modal = document.getElementById("nameImportModal");
      if (!modal) return; // Modal might not exist on this page

      const closeBtn = document.getElementById("nameImportCloseBtn");
      const fileInput = document.getElementById("nameFileInput");
      const importNowBtn = document.getElementById("nameImportBtn");
      const exportBtn = document.getElementById("nameExportBtn");
      const clearBtn = document.getElementById("nameClearBtn");
      const preview = document.getElementById("importPreview");
      const previewList = document.getElementById("importPreviewList");
      const importCount = document.getElementById("importCount");

      let parsedData = null;

      function closeModal() {
        modal.classList.remove("show");
        fileInput.value = '';
        preview.style.display = 'none';
        parsedData = null;
        importNowBtn.disabled = true;
      }

      if (closeBtn) closeBtn.addEventListener("click", closeModal);

      if (modal) {
        modal.addEventListener("click", (e) => {
          if (e.target === modal) closeModal();
        });
      }

      // File input change handler
      fileInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          const data = await parseFile(file);
          parsedData = data;

          // Show preview
          const entries = Object.entries(data);
          const previewEntries = entries.slice(0, 5);

          previewList.innerHTML = previewEntries
            .map(([reddit, name]) => `${reddit} ‚Üí ${name}`)
            .join('<br>');

          importCount.textContent = `Ready to import ${entries.length} name mappings`;
          preview.style.display = 'block';
          importNowBtn.disabled = false;

        } catch (error) {
          showErrorToast('File Parse Error', [error.message]);
          preview.style.display = 'none';
          importNowBtn.disabled = true;
        }
      });

      // Parse file (CSV or Excel)
      async function parseFile(file) {
        const fileName = file.name.toLowerCase();

        if (fileName.endsWith('.csv') || fileName.endsWith('.tsv') || fileName.endsWith('.txt')) {
          return parseCSV(file);
        } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
          return parseExcel(file);
        } else {
          throw new Error('Unsupported file format. Use CSV, TSV, or Excel (.xlsx, .xls)');
        }
      }

      // Parse CSV
      async function parseCSV(file) {
        const text = await file.text();
        const lines = text.split('\n').filter(line => line.trim());
        const mappings = {};

        // Skip header if present
        const startIndex = lines[0].toLowerCase().includes('reddit') ? 1 : 0;

        for (let i = startIndex; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          const parts = line.split(',').map(p => p.trim());
          if (parts.length >= 2) {
            const reddit = parts[0];
            const name = parts.slice(1).join(',').replace(/^["']|["']$/g, ''); // Handle quoted names
            if (reddit && name) {
              mappings[reddit] = name;
            }
          }
        }

        return mappings;
      }

      // Parse Excel
      async function parseExcel(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = (e) => {
            try {
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
              const rows = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });

              const mappings = {};
              // Skip header if present
              const startIndex = rows[0] && String(rows[0][0]).toLowerCase().includes('reddit') ? 1 : 0;

              for (let i = startIndex; i < rows.length; i++) {
                const row = rows[i];
                if (row && row.length >= 2) {
                  const reddit = String(row[0]).trim();
                  const name = String(row[1]).trim();
                  if (reddit && name) {
                    mappings[reddit] = name;
                  }
                }
              }

              resolve(mappings);
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = () => reject(new Error('Failed to read file'));
          reader.readAsArrayBuffer(file);
        });
      }

      // Import button handler
      importNowBtn.addEventListener("click", () => {
        if (!parsedData) return;

        // Merge with existing mappings
        const existing = loadAllMappings();
        const merged = { ...existing, ...parsedData };
        saveAllMappings(merged);

        // Rebuild table to show new names
        rebuildTable();

        showToast('Names Imported!', [
          `‚úì ${Object.keys(parsedData).length} mappings imported`,
          `üìã Total mappings: ${Object.keys(merged).length}`,
          'üîÑ Names updated in table'
        ]);

        closeModal();
      });

      // Export button handler
      exportBtn.addEventListener("click", () => {
        const csv = exportMappingsAsCSV();
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `reddit_names_${new Date().toISOString().split('T')[0]}.csv`;
        a.click();
        URL.revokeObjectURL(url);

        showToast('Mappings Exported!', ['üì• CSV file downloaded']);
      });

      // Clear button handler
      clearBtn.addEventListener("click", () => {
        if (confirm('Are you sure you want to clear all name mappings? This cannot be undone.')) {
          clearAllMappings();
          rebuildTable();
          showToast('Mappings Cleared!', ['üóëÔ∏è All name mappings removed']);
        }
      });
    })();

 // ============ RESTRICTION MODAL ============
    (function () {
      const restrictionModal = document.getElementById("restrictionModal");
      const restrictionMessage = document.getElementById("restrictionMessage");
      const restrictionModalTitle = document.getElementById("restrictionModalTitle");
      const restrictionOkBtn = document.getElementById("restrictionOkBtn");
      const restrictionCancelRaffleBtn = document.getElementById("restrictionCancelRaffleBtn");

      window.showRestrictionModal = function(message, showCancelButton = false, title = "Cannot Finish Raffle!") {
        restrictionModalTitle.textContent = title;
        restrictionMessage.innerHTML = message;
        restrictionCancelRaffleBtn.style.display = showCancelButton ? "block" : "none";
        restrictionModal.classList.add("show");
      };

      restrictionOkBtn.addEventListener("click", () => {
        restrictionModal.classList.remove("show");
      });

      restrictionCancelRaffleBtn.addEventListener("click", () => {
        restrictionModal.classList.remove("show");
        showCancelConfirmModal();
      });

      restrictionModal.addEventListener("click", (e) => {
        if (e.target === restrictionModal) {
          restrictionModal.classList.remove("show");
        }
      });
    })();

 // ============ CANCEL RAFFLE CONFIRMATION MODAL ============
    (function () {
      const cancelConfirmModal = document.getElementById("cancelConfirmModal");
      const cancelConfirmOkBtn = document.getElementById("cancelConfirmOkBtn");
      const cancelConfirmCancelBtn = document.getElementById("cancelConfirmCancelBtn");

      window.showCancelConfirmModal = function() {
        cancelConfirmModal.classList.add("show");
      };

      cancelConfirmOkBtn.addEventListener("click", async () => {
        cancelConfirmModal.classList.remove("show");
        await saveToHistory('cancelled', null);
        showToast('Raffle Cancelled', ['Saved to history as cancelled']);
        await resetRaffle();
      });

      cancelConfirmCancelBtn.addEventListener("click", () => {
        cancelConfirmModal.classList.remove("show");
      });

      cancelConfirmModal.addEventListener("click", (e) => {
        if (e.target === cancelConfirmModal) {
          cancelConfirmModal.classList.remove("show");
        }
      });
    })();

 // ============ PAYPAL SCAN CONFIRMATION MODAL ============
    (function () {
      const paypalScanModal = document.getElementById("paypalScanModal");
      const paypalScanOkBtn = document.getElementById("paypalScanOkBtn");
      const paypalScanCancelBtn = document.getElementById("paypalScanCancelBtn");
      let scanCallback = null;

      window.showPaypalScanModal = function(onConfirm) {
        scanCallback = onConfirm;
        paypalScanModal.classList.add("show");
      };

      paypalScanOkBtn.addEventListener("click", () => {
        paypalScanModal.classList.remove("show");
        if (scanCallback) {
          scanCallback();
          scanCallback = null;
        }
      });

      paypalScanCancelBtn.addEventListener("click", () => {
        paypalScanModal.classList.remove("show");
        scanCallback = null;
      });

      paypalScanModal.addEventListener("click", (e) => {
        if (e.target === paypalScanModal) {
          paypalScanModal.classList.remove("show");
          scanCallback = null;
        }
      });
    })();

 // ============ FINISH RAFFLE MODAL ============
    (function () {
      const finishBtn = document.getElementById("finishRaffleBtn");
      const modal = document.getElementById("finishModal");
      const completeBtn = document.getElementById("finishCompleteBtn");
      const winnerEntriesContainer = document.getElementById("winnerEntriesContainer");
      let winnerCount = 1;

   finishBtn.addEventListener("click", () => {
        // Check if setup is complete first
        if (!appState.redditLink || !appState.costPerSpot || appState.totalSpots === null) {
          showRestrictionModal(`Setup is incomplete.<br>Please configure Reddit Link, Total Spots, and Cost Per Spot before finishing the raffle.`);
          return;
        }

        // Calculate current stats
        const spotsClaimed = appState.participants.reduce((sum, p) => sum + (p.spots || 0), 0);
        const spotsRemaining = appState.totalSpots !== null ? Math.max(0, appState.totalSpots - spotsClaimed) : 0;
        const totalOwed = appState.participants.reduce((sum, p) => sum + (p.owed || 0), 0);
        const totalPaid = appState.participants.filter(p => p.paid).reduce((sum, p) => sum + (p.owed || 0), 0);
        const unpaidAmount = totalOwed - totalPaid;

        // Check if raffle can be finished
        if (spotsRemaining > 0) {
          showRestrictionModal(`There are still <strong>${spotsRemaining}</strong> spots remaining.<br>All spots must be filled before selecting a winner.`, true);
          return;
        }

        if (unpaidAmount > 0) {
          showRestrictionModal(`There is still <strong>$${unpaidAmount.toLocaleString()}</strong> owed.<br>All payments must be collected before selecting a winner.`, true);
          return;
        }

        // If all checks pass, open the modal
        winnerCount = 1;
        updateWinnerCountButtons();
        renderWinnerEntries();
        completeBtn.disabled = true;

        modal.classList.add("show");

        // Populate username dropdown
        populateUsernameDropdown();
      });

      function closeModal() {
        modal.classList.remove("show");
      }

      modal.addEventListener("click", (e) => {
        if (e.target === modal) closeModal();
      });

      // Winner count button handlers
      document.querySelectorAll('.winner-count-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          winnerCount = parseInt(btn.dataset.count);
          updateWinnerCountButtons();
          renderWinnerEntries();
          validateWinnerInput();
        });
      });

      function updateWinnerCountButtons() {
        document.querySelectorAll('.winner-count-btn').forEach(btn => {
          if (parseInt(btn.dataset.count) === winnerCount) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });

        // Update modal text
        const modalText = document.getElementById('finishModalText');
        if (modalText) {
          if (winnerCount === 1) {
            modalText.textContent = 'Enter the winner\'s information to complete the raffle.';
          } else {
            modalText.textContent = `Enter information for all ${winnerCount} winners to complete the raffle.`;
          }
        }
      }

      function renderWinnerEntries() {
        winnerEntriesContainer.innerHTML = '';
        const totalSpots = appState.totalSpots || 100;

        for (let i = 0; i < winnerCount; i++) {
          const entry = document.createElement('div');
          entry.className = 'winner-entry';
          entry.innerHTML = `
            <div class="winner-entry-header">${winnerCount === 1 ? 'Winner' : `Winner #${i + 1}`}</div>
            <div class="form-group" style="margin-bottom: 12px;">
              <label class="form-label">Reddit Username</label>
              <div class="username-dropdown-container">
                <input
                  type="text"
                  class="form-input winner-username-input"
                  data-index="${i}"
                  placeholder="Search Reddit username..."
                  autocomplete="off"
                />
                <div class="username-dropdown-list" data-index="${i}"></div>
              </div>
            </div>
            <div class="form-group">
              <label class="form-label">Winning Spot Number</label>
              <input
                type="number"
                class="form-input winner-spot-input"
                data-index="${i}"
                placeholder="Enter spot number (1-${totalSpots})"
                min="1"
                max="${totalSpots}"
              />
            </div>
          `;
          winnerEntriesContainer.appendChild(entry);
        }

        // Attach event listeners
        attachWinnerInputListeners();
      }

      function attachWinnerInputListeners() {
        // Username inputs
        document.querySelectorAll('.winner-username-input').forEach(input => {
          input.addEventListener('input', (e) => {
            filterUsernameDropdown(e.target.value, parseInt(e.target.dataset.index));
            validateWinnerInput();
          });

          input.addEventListener('focus', (e) => {
            if (e.target.value) {
              filterUsernameDropdown(e.target.value, parseInt(e.target.dataset.index));
            }
          });
        });

        // Spot inputs
        document.querySelectorAll('.winner-spot-input').forEach(input => {
          input.addEventListener('input', validateWinnerInput);
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.username-dropdown-container')) {
            document.querySelectorAll('.username-dropdown-list').forEach(list => {
              list.classList.remove('show');
            });
          }
        });
      }

         // Populate username dropdown with unique Reddit usernames
      function populateUsernameDropdown() {
        // Get unique Reddit usernames
        const usernames = [...new Set(appState.participants.map(p => p.redditUser))].sort();
        
        // Store for filtering
        window.allUsernames = usernames;
      }

      // Filter and display username dropdown
      function filterUsernameDropdown(searchTerm, index) {
        const dropdownList = document.querySelector(`.username-dropdown-list[data-index="${index}"]`);
        if (!dropdownList) return;

        const searchLower = searchTerm.toLowerCase();

        // Filter usernames
        const filtered = window.allUsernames.filter(u => u.toLowerCase().includes(searchLower));

        // Clear list
        dropdownList.innerHTML = '';

        if (searchTerm && filtered.length > 0) {
          filtered.forEach(username => {
            const item = document.createElement('div');
            item.className = 'username-dropdown-item';
            item.textContent = username;
            item.addEventListener('click', () => {
              const input = document.querySelector(`.winner-username-input[data-index="${index}"]`);
              input.value = username;
              dropdownList.classList.remove('show');
              validateWinnerInput();
              
              // Focus on spot input
              const spotInput = document.querySelector(`.winner-spot-input[data-index="${index}"]`);
              if (spotInput) spotInput.focus();
            });
            dropdownList.appendChild(item);
          });
          dropdownList.classList.add('show');
        } else {
          dropdownList.classList.remove('show');
        }
      }

      function validateWinnerInput() {
        const totalSpots = appState.totalSpots || 100;
        let allValid = true;

        const usernameInputs = document.querySelectorAll('.winner-username-input');
        const spotInputs = document.querySelectorAll('.winner-spot-input');

        // Check each winner entry
        for (let i = 0; i < winnerCount; i++) {
          const username = usernameInputs[i]?.value.trim();
          const spotValue = parseInt(spotInputs[i]?.value);
          const hasUsername = username !== '';
          const hasSpot = spotInputs[i]?.value !== '' && spotValue > 0 && spotValue <= totalSpots;

          if (!hasUsername || !hasSpot) {
            allValid = false;
            break;
          }
        }

        // Check for duplicate spots
        if (allValid) {
          const spots = Array.from(spotInputs).map(input => parseInt(input.value));
          const uniqueSpots = new Set(spots);
          if (uniqueSpots.size !== spots.length) {
            allValid = false;
          }
        }

        completeBtn.disabled = !allValid;
      }

      completeBtn.addEventListener("click", async () => {
        const totalSpots = appState.totalSpots || 100;
        const winners = [];

        // Collect all winner data
        const usernameInputs = document.querySelectorAll('.winner-username-input');
        const spotInputs = document.querySelectorAll('.winner-spot-input');

        for (let i = 0; i < winnerCount; i++) {
          const username = usernameInputs[i].value.trim();
          const spot = parseInt(spotInputs[i].value);

          if (!username || !spot) {
            showErrorToast('Missing Information', [`Please enter username and spot for Winner #${i + 1}.`]);
            return;
          }

          if (spot < 1 || spot > totalSpots) {
            showErrorToast('Invalid Spot Number', [`Spot number for Winner #${i + 1} must be between 1 and ${totalSpots}.`]);
            return;
          }

          winners.push({ username, spot });
        }

        // Check for duplicate spots
        const spots = winners.map(w => w.spot);
        const uniqueSpots = new Set(spots);
        if (uniqueSpots.size !== spots.length) {
          showErrorToast('Duplicate Spots', ['Each winner must have a unique spot number.']);
          return;
        }

        // Save with single winner or multiple winners
        const winnerData = winnerCount === 1 ? winners[0] : winners;

        await saveToHistory('completed', winnerData);
        
        // Stop fast raffle timer
        stopFastRaffleTimer();
        
        // Show toast
        if (winnerCount === 1) {
          showToast(
            `üèÜ Winner: ${winners[0].username}`,
            [`Spot #${winners[0].spot}`]
          );
        } else {
          showToast(
            `üèÜ ${winnerCount} Winners Selected!`,
            winners.map((w, i) => `#${i + 1}: ${w.username} (Spot #${w.spot})`)
          );
        }

        await resetRaffle();
        closeModal();
      });
    })();

    // ============ SCAN EMAIL BUTTON ============
    document.getElementById("scanEmailBtn").addEventListener("click", async () => {
      // Debug: Log the current app state
      console.log('üîç Scan Email clicked. Current state:', {
        activeRaffleId: appState.activeRaffleId,
        redditLink: appState.redditLink,
        totalSpots: appState.totalSpots,
        costPerSpot: appState.costPerSpot,
        participantCount: appState.participants.length
      });
      
      // Check if raffle exists
      if (!appState.activeRaffleId) {
        console.error('‚ùå Cannot scan email: No active raffle ID found');
        showErrorToast('No Active Raffle', [
          'Please save your raffle configuration first.',
          'Click "Setup" ‚Üí enter raffle details ‚Üí click "Save"'
        ]);
        return;
      }
      
      console.log('‚úÖ Active raffle ID found:', appState.activeRaffleId);

      // Check if Gmail OAuth credentials are configured
      try {
        const checkResponse = await fetch('/api/paypal/check-credentials');
        const checkResult = await checkResponse.json();
        
        if (!checkResult.ok || !checkResult.hasCredentials) {
          showRestrictionModal(
            `Please upload your Gmail OAuth credentials in <b>Settings</b> before scanning emails.<br><br>Go to Settings ‚Üí Bot Configuration ‚Üí Upload Gmail OAuth JSON file.`,
            false,
            "Gmail OAuth Not Configured"
          );
          return;
        }
      } catch (error) {
        console.error('Failed to check Gmail credentials:', error);
        // Continue anyway - the actual scan will catch this error
      }

      // Show confirmation modal before scanning
      showPaypalScanModal(async () => {
        try {
        const requestBody = {
          raffle_id: appState.activeRaffleId
        };
        
        // Send timestamp if available, otherwise fall back to days_back
        if (appState.createdAt) {
          requestBody.since_timestamp = appState.createdAt;
        } else {
          requestBody.days_back = 7;
        }
        
        const response = await fetch('/api/paypal/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });

        const result = await response.json();

        if (!result.ok) {
          // Check if credentials are missing
          if (result.error && result.error.includes('Gmail credentials not found')) {
            showRestrictionModal(`Gmail not connected.<br><br>Please upload your Gmail OAuth credentials in <b>Settings</b> to use this feature.`);
          } else {
            showRestrictionModal(`Scan failed.<br><br>${result.error || 'Unknown error'}`);
          }
          return;
        }

        // Show results
        const details = [
          `üìß Emails scanned: ${result.processed || 0}`,
          `‚úÖ Payments matched: ${result.matched || 0}`
        ];

        // Add specific match details if available
        if (result.results && result.results.length > 0) {
          const matched = result.results.filter(r => r.status === 'matched');
          
          if (matched.length > 0) {
            details.push('');
            details.push('‚úÖ Matched Payments:');
            matched.forEach(m => {
              details.push(`‚Ä¢ ${m.payer_name || 'Unknown'}: $${m.amount} ‚Üí u/${m.reddit_user}`);
            });
          }
        }

        showToast('Email Scan Complete!', details);

        // Reload participants to show updated payment status
        if (result.matched > 0) {
          loadState();
        }

      } catch (error) {
        console.error('Scan email error:', error);
        showRestrictionModal(`Failed to scan emails.<br><br>${error.message}`);
      }
      });
    });

    // ============ CLEAR IDS BUTTON ============
    document.getElementById("clearIdsBtn").addEventListener("click", async () => {
      if (!appState.activeRaffleId) {
        showRestrictionModal(`No active raffle found.`);
        return;
      }

      try {
        // Call backend to clear processed PayPal transaction records
        const response = await fetch('/api/paypal/clear', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            raffle_id: appState.activeRaffleId
          })
        });

        const result = await response.json();

        if (!result.ok) {
          showRestrictionModal(`Failed to clear email records.<br><br>${result.error || 'Unknown error'}`);
          return;
        }

        // Log activity
        await API.logActivity({
          type: 'modification',
          title: 'Cleared processed email records',
          details: `${result.deleted} processed PayPal transaction records cleared - emails can now be rescanned`,
          badge: 'Email Records Cleared'
        });

        const details = [
          `üóëÔ∏è ${result.deleted} email records cleared`,
          `üîÑ Emails can now be rescanned`,
          'üí° Previous payments can be matched again'
        ];
        showToast('Email IDs Cleared!', details);

      } catch (error) {
        console.error('Clear IDs error:', error);
        showRestrictionModal(`Failed to clear records.<br><br>${error.message}`);
      }
    });

    // ============ MARK ALL PAID BUTTON ============
    document.getElementById("markPaidBtn").addEventListener("click", async () => {
      // Check if setup is complete first
      if (!appState.redditLink || !appState.costPerSpot || appState.totalSpots === null) {
        showRestrictionModal(`Setup is incomplete.<br>Please configure Reddit Link, Total Spots, and Cost Per Spot before marking payments.`);
        return;
      }

      const pendingCount = appState.participants.filter(p => !p.paid).length;
      const totalAmount = appState.participants.reduce((sum, p) => sum + (p.owed || 0), 0);

      appState.participants.forEach(p => p.paid = true);
      await saveState();
      rebuildTable();
      updateStats();
      updateFooter();

      // Log activity
      await API.logActivity({
        type: 'payment',
        title: 'All participants marked as paid',
        details: `${pendingCount} payments confirmed ‚Ä¢ Total: $${totalAmount.toLocaleString()}`,
        badge: 'Payment Confirmed'
      });

      const details = [
        `‚úì ${pendingCount} participants marked as paid`,
        `üí∞ Total confirmed: $${totalAmount.toLocaleString()}`,
        'üéâ All payments complete!'
      ];
      showToast('Payments Updated!', details);
    });

    // ============ SEARCH & FILTER ============
    document.getElementById("participantSearch").addEventListener("input", filterAndSearch);
    document.getElementById("paymentFilter").addEventListener("change", filterAndSearch);

    // ============ TOAST CLOSE ============
    document.getElementById("toastClose").addEventListener("click", () => {
      document.getElementById("successToast").classList.remove("show");
    });

    document.getElementById("errorToastClose").addEventListener("click", () => {
      document.getElementById("errorToast").classList.remove("show");
    });

    // ============ INITIALIZE ============
    (async function init() {
      // Initialize user cache FIRST
      await API.initUser();
      
      // Load state (now with user cached)
      await loadState();

      // Defer heavy operations slightly to let the page render
      requestAnimationFrame(() => {
        updateStats();
        updateFooter();

        // Start auto-polling after a short delay to avoid blocking initial render
        setTimeout(() => {
          startAutoPolling();
        }, 100);
      });
    })();

    // ============ AUTO-POLLING REDDIT SCAN ============
    let pollingInterval = null;

    async function performAutoScan() {
      // Only scan if Reddit link and cost per spot are configured
      if (!appState.redditLink || !appState.costPerSpot) {
        return;
      }

      // Check if there are any spots remaining
      const spotsClaimed = appState.participants.reduce((sum, p) => sum + (p.spots || 0), 0);
      const spotsRemaining = appState.totalSpots !== null ? Math.max(0, appState.totalSpots - spotsClaimed) : null;
      
      if (spotsRemaining === 0) {
        console.log('üéØ Raffle is full! Skipping auto-scan.');
        return;
      }

      // Validate Reddit URL format before scanning
      const redditRegex = /^https?:\/\/(www\.)?(reddit\.com|old\.reddit\.com)\/r\/[^\/]+\/comments\/[^\/]+\/[^\/]+\/?/i;
      if (!redditRegex.test(appState.redditLink)) {
        console.error('‚ùå Invalid Reddit URL format detected. Auto-scan skipped.');
        return;
      }

      console.log('üîÑ Auto-scanning Reddit...');

      try {
        // OPTIMIZATION: Pass existing comment IDs to backend to skip AI parsing
        const existingCommentIds = appState.participants.map(p => p.commentId).filter(Boolean);
        console.log(`üìä Passing ${existingCommentIds.length} existing comment IDs to skip AI parsing`);

        const result = await API.scanReddit(appState.redditLink, appState.costPerSpot, appState.totalSpots, existingCommentIds);

        if (!result.ok) {
          console.error('Auto-scan failed:', result.error);
          return;
        }

        const newParticipants = result.participants || [];

        if (newParticipants.length === 0) {
          console.log('‚úì Auto-scan complete - no new participants');
          return;
        }

        // DEBUG: Log comment IDs for auto-scan
        console.log('üîÑ AUTO-SCAN - Existing participants:', appState.participants.length);
        console.log('üîÑ AUTO-SCAN - Existing comment IDs:', existingCommentIds);
        console.log('üîÑ AUTO-SCAN - New participants from Reddit:', newParticipants.length);
        console.log('üîÑ AUTO-SCAN - New comment IDs:', newParticipants.map(p => p.commentId));

        // FILTER OUT DUPLICATES: Only add comments we haven't seen before
        const existingCommentIdsSet = new Set(existingCommentIds);
        const trulyNewParticipants = newParticipants.filter(newP => !existingCommentIdsSet.has(newP.commentId));

        console.log('üîÑ AUTO-SCAN - Filtered to truly new:', trulyNewParticipants.length);

        if (trulyNewParticipants.length === 0) {
          console.log('‚úì Auto-scan complete - no new comments (all already added)');
          return;
        }

        // Add only NEW participants
        trulyNewParticipants.forEach(newP => {
          appState.participants.push(newP);
        });

        await saveState();
        rebuildTable();
        updateStats();
        updateFooter();

        // Log activity
        await API.logActivity({
          type: 'participant',
          title: `Auto-scan: ${trulyNewParticipants.length} entries added`,
          details: `${trulyNewParticipants.length} participant entries found via automatic Reddit scan`,
          badge: 'Auto-Scan'
        });

        // Show notification
        const details = [
          `üë• ${trulyNewParticipants.length} new entries found`,
          `üìä Total entries: ${appState.participants.length}`
        ];
        showToast('Auto-Scan Complete!', details);

        console.log(`‚úì Auto-scan complete - ${trulyNewParticipants.length} new participants added`);

      } catch (error) {
        console.error('Auto-scan error:', error);
      }
    }

    function startAutoPolling() {
      // Clear any existing interval
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }

      // Only start polling if setup is configured
      if (!appState.redditLink || !appState.costPerSpot) {
        document.getElementById('autoScanIndicator').style.display = 'none';
        localStorage.setItem('autoPollingActive', 'false');
        return;
      }

      // Show indicator
      document.getElementById('autoScanIndicator').style.display = 'inline-flex';

      // Mark polling as active in localStorage so other pages know (user-specific)
      localStorage.setItem(getUserLocalStorageKey('autoPollingActive'), 'true');
      localStorage.setItem(getUserLocalStorageKey('autoPollingRaffleId'), appState.activeRaffleId);

      // Start polling every 10 seconds (10000ms)
      pollingInterval = setInterval(() => {
        performAutoScan();
        resetPollCountdown();
      }, 10000);

      // Start countdown timer
      startPollCountdown();

      console.log('‚úì Auto-polling started - scanning every 10 seconds (active across all pages)');
    }

    function stopAutoPolling() {
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      document.getElementById('autoScanIndicator').style.display = 'none';
      
      // Stop countdown timer
      if (typeof stopPollCountdown === 'function') {
        stopPollCountdown();
      }
      
      // Mark polling as inactive in localStorage
      localStorage.setItem('autoPollingActive', 'false');
      
      console.log('‚úì Auto-polling stopped');
    }

    // Don't stop polling when navigating away - let it run in background
    // window.addEventListener('beforeunload', stopAutoPolling);

    // Restart polling when setup is saved
    const originalSaveBtn = document.getElementById("modalSaveBtn");
    if (originalSaveBtn) {
      originalSaveBtn.addEventListener("click", () => {
        setTimeout(() => {
          startAutoPolling();
        }, 500);
      });
    }

    // ===== CHECK AND RESUME POLLING ON PAGE LOAD =====
    (function() {
      // Wait for page to fully load and appState to be populated
      setTimeout(() => {
        const isPollingActive = localStorage.getItem('autoPollingActive') === 'true';
        const savedRaffleId = localStorage.getItem('autoPollingRaffleId');
        
        // If polling was active and we have the same raffle loaded
        if (isPollingActive && savedRaffleId && appState.activeRaffleId == savedRaffleId) {
          console.log('üîÑ Resuming auto-polling from previous session...');
          startAutoPolling();
        }
      }, 1000);
    })();

    // ===== LISTEN FOR BACKGROUND SCAN EVENTS =====
    window.addEventListener('backgroundScanComplete', async (event) => {
      console.log('üîî Background scan completed on another page. Reloading data...');
      
      // Reload participant data
      await loadState();
      
      // Show subtle notification
      const details = [
        `üë• ${event.detail.newCount} new participant(s) found`,
        `üíú Scanned while you were away`
      ];
      showToast('Auto-Scan Complete!', details);
    });

        // ===== AUTO-OPEN SETUP MODAL FROM DASHBOARD =====
(function() {
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('setup') === 'open') {
    // Wait for page to fully load
    setTimeout(() => {
      const setupBtn = document.getElementById('setupBtn');
      if (setupBtn) {
        setupBtn.click();
      }
    }, 500);

    // Clean URL (remove ?setup=open)
    window.history.replaceState({}, document.title, '/active-raffle');
  }
})();

// ===== ACCESS DENIED MODAL =====
function showAccessDenied() {
  const overlay = document.getElementById('accessDeniedOverlay');
  if (!overlay) {
    showErrorToast('Access Denied', ['Admins only']);
    return;
  }
  overlay.classList.add('show');
  document.body.style.overflow = 'hidden';
}

function closeAccessDenied(event) {
  if (!event || event.target === document.getElementById('accessDeniedOverlay')) {
    const overlay = document.getElementById('accessDeniedOverlay');
    if (overlay) {
      overlay.classList.remove('show');
      document.body.style.overflow = '';
    }
  }
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const overlay = document.getElementById('accessDeniedOverlay');
    if (overlay && overlay.classList.contains('show')) {
      closeAccessDenied({ target: overlay });
    }
  }
});

// ============ FAST RAFFLE TIMER ============
let fastRaffleTimerInterval = null;

function startFastRaffleTimer() {
  const timerElement = document.getElementById('fastRaffleTimer');
  const displayElement = document.getElementById('timerDisplay');
  
  if (!timerElement || !displayElement) return;
  
  // Show the timer
  timerElement.classList.add('active');
  
  // Clear any existing interval
  if (fastRaffleTimerInterval) {
    clearInterval(fastRaffleTimerInterval);
  }
  
  function updateTimer() {
    if (!appState.fastRaffleStartTime) {
      stopFastRaffleTimer();
      return;
    }
    
    // Calculate elapsed time
    const elapsed = Date.now() - appState.fastRaffleStartTime;
    const totalDuration = 75 * 60 * 1000; // 1 hour 15 minutes in milliseconds
    const remaining = Math.max(0, totalDuration - elapsed);
    
    if (remaining === 0) {
      displayElement.textContent = '00:00:00';
      timerElement.classList.add('warning');
      stopFastRaffleTimer();
      return;
    }
    
    // Convert to hours, minutes, seconds
    const hours = Math.floor(remaining / (60 * 60 * 1000));
    const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
    const seconds = Math.floor((remaining % (60 * 1000)) / 1000);
    
    // Format as HH:MM:SS
    const formatted = 
      String(hours).padStart(2, '0') + ':' +
      String(minutes).padStart(2, '0') + ':' +
      String(seconds).padStart(2, '0');
    
    displayElement.textContent = formatted;
    
    // Turn red when under 1 hour
    if (remaining < 60 * 60 * 1000) {
      timerElement.classList.add('warning');
    } else {
      timerElement.classList.remove('warning');
    }
  }
  
  // Update immediately
  updateTimer();
  
  // Update every second
  fastRaffleTimerInterval = setInterval(updateTimer, 1000);
  
  console.log('‚è±Ô∏è Fast raffle timer started');
}

function stopFastRaffleTimer() {
  const timerElement = document.getElementById('fastRaffleTimer');
  
  if (fastRaffleTimerInterval) {
    clearInterval(fastRaffleTimerInterval);
    fastRaffleTimerInterval = null;
  }
  
  if (timerElement) {
    timerElement.classList.remove('active');
    timerElement.classList.remove('warning');
  }
  
  console.log('‚è±Ô∏è Fast raffle timer stopped');
}

  </script>

  <!-- ACCESS DENIED MODAL -->
  <div class="access-denied-overlay" id="accessDeniedOverlay" onclick="closeAccessDenied(event)">
    <div class="access-denied-modal" onclick="event.stopPropagation()">
      <div class="access-modal-header">
        <div class="access-modal-icon">üîí</div>
        <h2 class="access-modal-title">Access Denied</h2>
        <p class="access-modal-subtitle">Admin privileges required</p>
      </div>
      <div class="access-modal-body">
        <p class="access-modal-message">
          You don't have permission to access this page. This area is restricted to administrators only.
        </p>
        <div class="access-modal-actions">
          <button class="access-modal-btn access-modal-btn-primary" onclick="closeAccessDenied()">
            Got it
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Poll Countdown Timer -->
  <script>
    let pollCountdownInterval = null;
    let pollTimeRemaining = 10; // 10 seconds

    function startPollCountdown() {
      pollTimeRemaining = 10;
      updatePollTimerDisplay();
      
      if (pollCountdownInterval) {
        clearInterval(pollCountdownInterval);
      }
      
      pollCountdownInterval = setInterval(() => {
        if (pollTimeRemaining > 0) {
          pollTimeRemaining--;
          updatePollTimerDisplay();
        }
      }, 1000);
    }

    function resetPollCountdown() {
      pollTimeRemaining = 10;
      updatePollTimerDisplay();
    }

    function updatePollTimerDisplay() {
      const timerEl = document.getElementById('nextPollTimer');
      if (timerEl) {
        timerEl.textContent = pollTimeRemaining;
      }
    }

    function stopPollCountdown() {
      if (pollCountdownInterval) {
        clearInterval(pollCountdownInterval);
        pollCountdownInterval = null;
      }
    }
  </script>

</body>
</html>
