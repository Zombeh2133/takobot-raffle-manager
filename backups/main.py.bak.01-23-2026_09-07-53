from fastapi import FastAPI, Request, UploadFile, File, Form
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from starlette.middleware.sessions import SessionMiddleware
from pydantic import BaseModel
from pathlib import Path
from PIL import Image
from datetime import datetime
from . import reddit as Reddit
import json
import sqlite3
import os
import hashlib
import base64
import secrets
import httpx
import subprocess
import sys
import psycopg2
from psycopg2.extras import RealDictCursor

app = FastAPI()
# =========================
# Sessions (cookie-based)
# =========================
SESSION_SECRET = os.environ.get("SESSION_SECRET", "CHANGE_ME_SESSION_SECRET")
app.add_middleware(SessionMiddleware, secret_key=SESSION_SECRET, same_site="lax", https_only=False)

# =========================
# Paths
# =========================
APP_DIR = Path(__file__).resolve().parent
TEMPLATES_DIR = APP_DIR / "templates"
STATIC_DIR = APP_DIR / "static"

DATA_DIR = APP_DIR / "data"
DATA_DIR.mkdir(parents=True, exist_ok=True)

USERS_DIR = DATA_DIR / "users"

# =========================
# PostgreSQL Connection
# =========================
DATABASE_URL = os.environ.get("DATABASE_URL", "postgresql://postgres:makii@localhost:5432/raffle_manager")

def get_pg_connection():
    """Get PostgreSQL connection"""
    return psycopg2.connect(DATABASE_URL, cursor_factory=RealDictCursor)

# =========================
# Templates + Static
# =========================
templates = Jinja2Templates(directory=str(TEMPLATES_DIR))
app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")

# =========================
# Image paths
# =========================
SOURCE_IMG = STATIC_DIR / "assets" / "Background" / "Sidebar.png"
OUTPUT_IMG = STATIC_DIR / "processed" / "sidebar_processed.png"

# =========================
# DB helpers
# =========================
def db_connect():
    con = sqlite3.connect(str(DB_PATH))
    con.row_factory = sqlite3.Row
    return con

def ensure_db():
    con = db_connect()
    cur = con.cursor()

    cur.execute("""
    CREATE TABLE IF NOT EXISTS users (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       username TEXT UNIQUE NOT NULL,
       password_hash TEXT
    )
    """)

    con.commit()
    con.close()

@app.on_event("startup")
async def on_startup():
    """Initialize on startup"""
    USERS_DIR.mkdir(parents=True, exist_ok=True)
    # Ensure password_hash column exists in PostgreSQL
    try:
        conn = get_pg_connection()
        cur = conn.cursor()
        cur.execute("""
            ALTER TABLE users ADD COLUMN IF NOT EXISTS password_hash TEXT;
        """)
        cur.execute("""
            ALTER TABLE users ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT NOW();
        """)
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"Startup DB migration info: {e}")

def get_current_user(request: Request):
    """Get current user from session (PostgreSQL)"""
    uid = request.session.get("user_id")
    if not uid:
        return None
    try:
        conn = get_pg_connection()
        cur = conn.cursor()
        cur.execute("SELECT id, username, is_admin FROM users WHERE id = %s", (uid,))
        row = cur.fetchone()
        conn.close()
        return dict(row) if row else None
    except Exception:
        return None

def get_or_create_active_raffle_id(user_id: int) -> int:
    con = db_connect()
    cur = con.cursor()

    row = cur.execute("""
        SELECT id FROM raffles
        WHERE user_id=? AND status='active'
        ORDER BY id DESC
        LIMIT 1
    """, (user_id,)).fetchone()

    if row:
        con.close()
        return int(row["id"])

    cur.execute("""
        INSERT INTO raffles (user_id, status, reddit_post_url, created_at)
        VALUES (?, 'active', '', ?)
    """, (user_id, now_iso()))
    con.commit()

    rid = cur.execute("SELECT last_insert_rowid() AS id").fetchone()["id"]
    con.close()
    return int(rid)

def now_iso():
    return datetime.utcnow().isoformat(timespec="seconds") + "Z"

def db_init_raffle_tables():
    con = db_connect()
    cur = con.cursor()

    cur.execute("""
    CREATE TABLE IF NOT EXISTS raffles (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        status TEXT NOT NULL DEFAULT 'active',
        reddit_post_url TEXT DEFAULT '',
        created_at TEXT NOT NULL
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS participants (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        raffle_id INTEGER NOT NULL,
        reddit_comment_id TEXT NOT NULL,
        reddit_author TEXT NOT NULL,
        comment_body TEXT NOT NULL,
        spots INTEGER NULL,
        created_utc INTEGER NOT NULL DEFAULT 0,
        permalink TEXT DEFAULT '',
        created_at TEXT NOT NULL,
        UNIQUE(raffle_id, reddit_comment_id)
    )
    """)

    con.commit()
    con.close()

# =========================
# Password hashing (PBKDF2)
# =========================
def hash_password(password: str) -> str:
    # format: pbkdf2$iterations$salt_b64$hash_b64
    iterations = 200_000
    salt = secrets.token_bytes(16)
    dk = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, iterations)
    return "pbkdf2${}${}${}".format(
        iterations,
        base64.b64encode(salt).decode("ascii"),
        base64.b64encode(dk).decode("ascii"),
    )

def verify_password(password: str, stored: str) -> bool:
    try:
        scheme, iters, salt_b64, hash_b64 = stored.split("$", 3)
        if scheme != "pbkdf2":
            return False
        iterations = int(iters)
        salt = base64.b64decode(salt_b64.encode("ascii"))
        expected = base64.b64decode(hash_b64.encode("ascii"))
        dk = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, iterations)
        return secrets.compare_digest(dk, expected)
    except Exception:
        return False

# =========================
# Admin API (check is_admin from PostgreSQL)
# =========================
@app.get("/api/admin/users")
async def admin_list_users(request: Request):
    user = get_current_user(request)
    if not user:
        return JSONResponse({"ok": False, "error": "Not logged in"}, status_code=401)

    if not user.get("is_admin"):
        return JSONResponse({"ok": False, "error": "Forbidden"}, status_code=403)

    try:
        conn = get_pg_connection()
        cur = conn.cursor()
        cur.execute("SELECT id, username, is_admin FROM users ORDER BY id ASC")
        rows = cur.fetchall()
        conn.close()

        items = []
        for r in rows:
            uid = int(r["id"])
            creds_dir = str(USERS_DIR / str(uid) / "credentials")
            oauth_path = str(USERS_DIR / str(uid) / "credentials" / "gmail_oauth_client.json")
            items.append({
                "id": uid,
                "username": r["username"],
                "is_admin": r["is_admin"],
                "creds_dir": creds_dir,
                "gmail_oauth_client_path": oauth_path,
            })

        return {"ok": True, "users": items}
    except Exception as e:
        return JSONResponse({"ok": False, "error": str(e)}, status_code=500)

@app.get("/api/whoami")
async def whoami(request: Request):
    user = get_current_user(request)
    if not user:
        return {"ok": False, "user": None}
    return {"ok": True, "user": user}

@app.get("/api/auth/current-user")
async def current_user(request: Request):
    """Get current user with admin status - for frontend auth checks"""
    user = get_current_user(request)
    if not user:
        return {"ok": False, "data": None}
    return {
        "ok": True,
        "data": {
            "id": user["id"],
            "username": user["username"],
            "isAdmin": user.get("is_admin", False)
        }
    }

@app.post("/api/auth/logout")
@app.get("/api/auth/logout")
async def api_auth_logout(request: Request):
    """Auth API endpoint for logout - clears session and returns JSON"""
    request.session.clear()
    return {"ok": True, "message": "Logged out successfully"}

# =========================
# API: Upload Gmail OAuth (per-user, numeric folder)
# =========================
@app.post("/api/settings/upload-gmail-oauth")
async def upload_gmail_oauth(request: Request, file: UploadFile = File(...)):
    try:
        user = get_current_user(request)
        if not user:
            return JSONResponse({"ok": False, "error": "Not logged in"}, status_code=401)

        if not file.filename.lower().endswith(".json"):
            return JSONResponse({"ok": False, "error": "Please upload a .json file."}, status_code=400)

        raw = await file.read()

        try:
            obj = json.loads(raw.decode("utf-8"))
        except Exception:
            return JSONResponse({"ok": False, "error": "Invalid JSON file."}, status_code=400)

        if not isinstance(obj, dict) or ("installed" not in obj and "web" not in obj):
            return JSONResponse(
                {"ok": False, "error": "JSON does not look like a Google OAuth client credentials file."},
                status_code=400
            )

        user_creds_dir = USERS_DIR / str(user["id"]) / "credentials"
        user_creds_dir.mkdir(parents=True, exist_ok=True)

        out_path = user_creds_dir / "gmail_oauth_client.json"
        out_path.write_bytes(raw)

        return {
            "ok": True,
            "saved_to": str(out_path),
            "user_id": user["id"],
            "username": user["username"],
        }

    except Exception as e:
        return JSONResponse({"ok": False, "error": str(e)}, status_code=500)

from pydantic import BaseModel
from fastapi import HTTPException

# =========================
# Auth routes
# =========================
@app.get("/login", response_class=HTMLResponse)
async def login_page(request: Request):
    page = TEMPLATES_DIR / "pages" / "login.html"
    if not page.exists():
        return HTMLResponse(
            "<h1>login.html not found</h1><p>Create: app/templates/pages/login.html</p>",
            status_code=404,
        )
    return templates.TemplateResponse("pages/login.html", {"request": request, "error": None})

@app.post("/login")
async def login_post(request: Request, username: str = Form(...), password: str = Form(...)):
    try:
        conn = get_pg_connection()
        cur = conn.cursor()
        cur.execute("SELECT id, username, password_hash, is_admin FROM users WHERE username = %s", (username,))
        row = cur.fetchone()
        conn.close()

        if not row:
            return templates.TemplateResponse(
                "pages/login.html",
                {"request": request, "error": "Invalid username or password"},
                status_code=401
            )

        # If password_hash exists, enforce it; otherwise fallback (older rows)
        stored = row["password_hash"]
        if stored:
            if not verify_password(password, stored):
                return templates.TemplateResponse(
                    "pages/login.html",
                    {"request": request, "error": "Invalid username or password"},
                    status_code=401
                )

        request.session["user_id"] = int(row["id"])
        return RedirectResponse(url="/settings", status_code=303)
    except Exception as e:
        return templates.TemplateResponse(
            "pages/login.html",
            {"request": request, "error": f"Login error: {e}"},
            status_code=500
        )

@app.get("/register", response_class=HTMLResponse)
async def register_page(request: Request):
    page = TEMPLATES_DIR / "pages" / "register.html"
    if not page.exists():
        return HTMLResponse(
            "<h1>register.html not found</h1><p>Create: app/templates/pages/register.html</p>",
            status_code=404,
        )
    return templates.TemplateResponse("pages/register.html", {"request": request, "error": None})

@app.post("/register")
async def register_post(request: Request, username: str = Form(...), password: str = Form(...)):
    username = username.strip()

    # Simple username rules (safe + predictable)
    if len(username) < 3 or len(username) > 24:
        return templates.TemplateResponse(
            "pages/register.html",
            {"request": request, "error": "Username must be 3â€“24 characters."},
            status_code=400
        )
    if not all(c.isalnum() or c in ("-", "_") for c in username):
        return templates.TemplateResponse(
            "pages/register.html",
            {"request": request, "error": "Username can only contain letters, numbers, - or _."},
            status_code=400
        )
    if len(password) < 6:
        return templates.TemplateResponse(
            "pages/register.html",
            {"request": request, "error": "Password must be at least 6 characters."},
            status_code=400
        )

    pw_hash = hash_password(password)

    try:
        conn = get_pg_connection()
        cur = conn.cursor()
        # Insert with default is_admin=false
        cur.execute(
            "INSERT INTO users (username, password_hash, is_admin, created_at) VALUES (%s, %s, %s, NOW()) RETURNING id",
            (username, pw_hash, False)
        )
        new_id = cur.fetchone()["id"]
        conn.commit()
        conn.close()
        
        request.session["user_id"] = int(new_id)
        return RedirectResponse(url="/settings", status_code=303)
    except psycopg2.IntegrityError:
        return templates.TemplateResponse(
            "pages/register.html",
            {"request": request, "error": "That username is already taken."},
            status_code=400
        )
    except Exception as e:
        return templates.TemplateResponse(
            "pages/register.html",
            {"request": request, "error": f"Registration error: {e}"},
            status_code=500
        )

@app.get("/logout")
async def logout(request: Request):
    request.session.clear()
    return RedirectResponse(url="/login", status_code=303)

@app.post("/api/logout")
@app.get("/api/logout")
async def api_logout(request: Request):
    """API endpoint for logout - clears session and returns JSON"""
    request.session.clear()
    return {"ok": True, "message": "Logged out successfully"}

# =========================
# Reddit Scan API (matches frontend)
# =========================
@app.get("/api/reddit/scan")
async def scan_reddit_endpoint(request: Request):
    """Scan Reddit post and extract participants - matches frontend API call"""
    try:
        url = request.query_params.get('url')
        costPerSpot = request.query_params.get('costPerSpot')

        if not url or not costPerSpot:
            return JSONResponse(
                {"ok": False, "error": "Missing url or costPerSpot parameter"},
                status_code=400
            )

        parser_path = APP_DIR / "reddit_parser.py"
        if not parser_path.exists():
            return JSONResponse(
                {"ok": False, "error": f"Reddit parser not found at {parser_path}"},
                status_code=500
            )

        # Run the Python parser script (it expects URL and cost per spot as arguments)
        result = subprocess.run(
            ["python3", str(parser_path), url, costPerSpot],
            capture_output=True,
            text=True,
            timeout=30
        )

        # Check for errors
        if result.returncode != 0:
            error_msg = result.stderr or result.stdout or "Unknown error"
            return JSONResponse(
                {"ok": False, "error": f"Parser error: {error_msg}"},
                status_code=500
            )

        # Parse the JSON response
        try:
            response_data = json.loads(result.stdout)
        except json.JSONDecodeError as e:
            return JSONResponse(
                {"ok": False, "error": f"Invalid JSON from parser: {str(e)}\nOutput: {result.stdout[:500]}"},
                status_code=500
            )

        # Map 'username' to 'redditUser' for frontend compatibility
        if response_data.get("ok") and "participants" in response_data:
            for participant in response_data["participants"]:
                if "username" in participant:
                    participant["redditUser"] = participant.pop("username")
                # Ensure redditUser exists even if username was missing
                if "redditUser" not in participant:
                    participant["redditUser"] = "unknown"

        return JSONResponse(response_data)

    except subprocess.TimeoutExpired:
        return JSONResponse(
            {"ok": False, "error": "Reddit scan timed out"},
            status_code=500
        )
    except Exception as e:
        import traceback
        return JSONResponse(
            {"ok": False, "error": f"Failed to scan Reddit: {str(e)}\n{traceback.format_exc()}"},
            status_code=500
        )

# =========================
# API Proxy to Node.js Backend
# =========================
@app.api_route("/api/{path:path}", methods=["GET", "POST", "PUT", "DELETE", "PATCH"])
async def proxy_to_nodejs(path: str, request: Request):
    """
    Forward all /api/* requests to Node.js backend on port 3000
    """
    try:
        # Build the target URL
        target_url = f"http://localhost:3000/api/{path}"

        # Get request body if present
        body = await request.body()

        # Get current user from session
        user = get_current_user(request)
        
        # Debug logging
        print(f"[PROXY] Path: /api/{path}")
        print(f"[PROXY] Session user_id: {request.session.get('user_id')}")
        print(f"[PROXY] Current user: {user}")
        
        # Prepare headers - add user info for Node.js backend
        headers = {k: v for k, v in request.headers.items() if k.lower() != "host"}
        
        # Add custom headers with user info (if logged in)
        if user:
            headers["X-User-Id"] = str(user["id"])
            headers["X-User-Name"] = user["username"]
            headers["X-User-Admin"] = "true" if user.get("is_admin") else "false"
            print(f"[PROXY] Adding headers: X-User-Id={user['id']}, X-User-Name={user['username']}, X-User-Admin={user.get('is_admin')}")

        # Forward the request
        async with httpx.AsyncClient() as client:
            response = await client.request(
                method=request.method,
                url=target_url,
                headers=headers,
                content=body,
                timeout=30.0
            )

            return JSONResponse(
                content=response.json() if response.text else {},
                status_code=response.status_code
            )
    except Exception as e:
        return JSONResponse(
            {"ok": False, "error": f"Proxy error: {str(e)}"},
            status_code=500
        )
# =========================
# Page routes
# =========================
@app.get("/", response_class=HTMLResponse)
@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request):
    user = get_current_user(request)
    if not user:
        return RedirectResponse(url="/login", status_code=303)
    return templates.TemplateResponse("index.html", {"request": request, "user": user})

@app.get("/active-raffle", response_class=HTMLResponse)
async def active_raffle(request: Request):
    page = TEMPLATES_DIR / "pages" / "active_raffle.html"
    if not page.exists():
        return HTMLResponse("<h1>active_raffle.html not found</h1>", status_code=404)
    return templates.TemplateResponse("pages/active_raffle.html", {"request": request})

@app.get("/raffle-history", response_class=HTMLResponse)
async def raffle_history(request: Request):
    page = TEMPLATES_DIR / "pages" / "raffle_history.html"
    if not page.exists():
        return HTMLResponse("<h1>raffle_history.html not found</h1>", status_code=404)
    return templates.TemplateResponse("pages/raffle_history.html", {"request": request})

@app.get("/activity-log", response_class=HTMLResponse)
async def activity_log(request: Request):
    page = TEMPLATES_DIR / "pages" / "activity_log.html"
    if not page.exists():
        return HTMLResponse("<h1>activity_log.html not found</h1>", status_code=404)
    return templates.TemplateResponse("pages/activity_log.html", {"request": request})

@app.get("/profile", response_class=HTMLResponse)
async def profile(request: Request):
    page = TEMPLATES_DIR / "pages" / "profile.html"
    if not page.exists():
        return HTMLResponse("<h1>profile.html not found</h1>", status_code=404)
    return templates.TemplateResponse("pages/profile.html", {"request": request})

@app.get("/settings", response_class=HTMLResponse)
async def settings_page(request: Request):
    user = get_current_user(request)
    if not user:
        return RedirectResponse(url="/login", status_code=303)
    page = TEMPLATES_DIR / "pages" / "settings.html"
    if not page.exists():
        return HTMLResponse("<h1>settings.html not found</h1>", status_code=404)
    return templates.TemplateResponse("pages/settings.html", {"request": request, "user": user})

@app.get("/admin", response_class=HTMLResponse)
async def admin_page(request: Request):
    """Admin dashboard page - requires admin privileges"""
    user = get_current_user(request)
    if not user:
        return RedirectResponse(url="/login", status_code=303)
    
    if not user.get("is_admin"):
        return HTMLResponse("<h1>403 Forbidden</h1><p>You must be an admin to access this page.</p>", status_code=403)
    
    page = TEMPLATES_DIR / "pages" / "admin.html"
    if not page.exists():
        return HTMLResponse("<h1>admin.html not found</h1><p>Create: app/templates/pages/admin.html</p>", status_code=404)
    
    return templates.TemplateResponse("pages/admin.html", {"request": request, "user": user})

# =========================
# Existing image processing route (kept)
# =========================
@app.get("/process-image")
async def process_image():
    try:
        if not SOURCE_IMG.exists():
            return JSONResponse({"ok": False, "error": f"Source image not found: {SOURCE_IMG}"}, status_code=404)

        img = Image.open(SOURCE_IMG)
        img = img.convert("L")
        img = img.resize((250, 700))

        OUTPUT_IMG.parent.mkdir(parents=True, exist_ok=True)
        img.save(OUTPUT_IMG)

        return {"ok": True, "output": "/static/processed/sidebar_processed.png"}

    except Exception as e:
        return JSONResponse({"ok": False, "error": str(e)}, status_code=500)
